---
title: Ortak web uygulaması mimarileri
description: ASP.NET Core ve Azure ile modern web uygulamalarını mimarın Ortak Web uygulaması mimarilerini keşfet
author: ardalis
ms.author: wiwagn
ms.date: 01/30/2019
ms.openlocfilehash: 8985434467346acc360e9a89c052803f495e87d1
ms.sourcegitcommit: 8b8dd14dde727026fd0b6ead1ec1df2e9d747a48
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 09/27/2019
ms.locfileid: "71332003"
---
# <a name="common-web-application-architectures"></a><span data-ttu-id="b7c92-103">Ortak web uygulaması mimarileri</span><span class="sxs-lookup"><span data-stu-id="b7c92-103">Common web application architectures</span></span>

> <span data-ttu-id="b7c92-104">"İyi mimari maliyetli düşünüyorsanız, kötü bir mimari deneyin."</span><span class="sxs-lookup"><span data-stu-id="b7c92-104">"If you think good architecture is expensive, try bad architecture."</span></span>  
> <span data-ttu-id="b7c92-105">_-Brian PTE ve Joseph Yoder_</span><span class="sxs-lookup"><span data-stu-id="b7c92-105">_- Brian Foote and Joseph Yoder_</span></span>

<span data-ttu-id="b7c92-106">En geleneksel .NET uygulamaları, tek bir IIS AppDomain içinde çalışan bir yürütülebilir dosyaya veya tek bir Web uygulamasına karşılık gelen tek bir birim olarak dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-106">Most traditional .NET applications are deployed as single units corresponding to an executable or a single web application running within a single IIS appdomain.</span></span> <span data-ttu-id="b7c92-107">Bu en basit dağıtım modelidir ve çok sayıda iç ve daha küçük genel uygulama sunar.</span><span class="sxs-lookup"><span data-stu-id="b7c92-107">This is the simplest deployment model and serves many internal and smaller public applications very well.</span></span> <span data-ttu-id="b7c92-108">Ancak, bu tek dağıtım birimi de verildiğinde, önemsiz olmayan iş uygulamalarının çoğu, bazı mantıksal ayırmalardan birkaç katmana faydalanır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-108">However, even given this single unit of deployment, most non-trivial business applications benefit from some logical separation into several layers.</span></span>

## <a name="what-is-a-monolithic-application"></a><span data-ttu-id="b7c92-109">Tek parçalı uygulama nedir?</span><span class="sxs-lookup"><span data-stu-id="b7c92-109">What is a monolithic application?</span></span>

<span data-ttu-id="b7c92-110">Tek parçalı bir uygulama, davranışı bakımından tamamen kendine dahil olan bir uygulamadır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-110">A monolithic application is one that is entirely self-contained, in terms of its behavior.</span></span> <span data-ttu-id="b7c92-111">İşlemlerini gerçekleştirme sürecinde diğer hizmetler veya veri depolarıyla etkileşime geçebilir, ancak davranışının çekirdeği kendi sürecinde çalışır ve tüm uygulama genellikle tek bir birim olarak dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-111">It may interact with other services or data stores in the course of performing its operations, but the core of its behavior runs within its own process and the entire application is typically deployed as a single unit.</span></span> <span data-ttu-id="b7c92-112">Bu tür bir uygulamanın yatay olarak ölçeklendirilmesi gerekiyorsa, genellikle uygulamanın tamamı birden çok sunucu veya sanal makine arasında yinelenir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-112">If such an application needs to scale horizontally, typically the entire application is duplicated across multiple servers or virtual machines.</span></span>

## <a name="all-in-one-applications"></a><span data-ttu-id="b7c92-113">Hepsi bir arada uygulama</span><span class="sxs-lookup"><span data-stu-id="b7c92-113">All-in-one applications</span></span>

<span data-ttu-id="b7c92-114">Bir uygulama mimarisi için mümkün olan en az sayıda proje vardır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-114">The smallest possible number of projects for an application architecture is one.</span></span> <span data-ttu-id="b7c92-115">Bu mimaride, uygulamanın bütün mantığı tek bir derlemede bulunur, tek bir derlemeye derlenir ve tek bir birim olarak dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-115">In this architecture, the entire logic of the application is contained in a single project, compiled to a single assembly, and deployed as a single unit.</span></span>

<span data-ttu-id="b7c92-116">Visual Studio 'da veya komut satırından oluşturulan yeni bir ASP.NET Core projesi, basit bir "hepsi bir arada" monoya olarak başlatılır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-116">A new ASP.NET Core project, whether created in Visual Studio or from the command line, starts out as a simple "all-in-one" monolith.</span></span> <span data-ttu-id="b7c92-117">Sunu, iş ve veri erişim mantığı dahil olmak üzere uygulamanın tüm davranışlarını içerir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-117">It contains all of the behavior of the application, including presentation, business, and data access logic.</span></span> <span data-ttu-id="b7c92-118">Şekil 5-1, tek projem uygulamanın dosya yapısını gösterir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-118">Figure 5-1 shows the file structure of a single-project app.</span></span>

![Tek bir proje ASP.NET Core uygulaması](./media/image5-1.png)

<span data-ttu-id="b7c92-120">**Şekil 5-1.**</span><span class="sxs-lookup"><span data-stu-id="b7c92-120">**Figure 5-1.**</span></span> <span data-ttu-id="b7c92-121">Tek bir proje ASP.NET Core uygulaması.</span><span class="sxs-lookup"><span data-stu-id="b7c92-121">A single project ASP.NET Core app.</span></span>

<span data-ttu-id="b7c92-122">Tek bir proje senaryosunda, sorun ayrımı klasörler kullanılarak elde edilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-122">In a single project scenario, separation of concerns is achieved through the use of folders.</span></span> <span data-ttu-id="b7c92-123">Varsayılan şablon, modeller, görünümler ve denetleyicilerin MVC model sorumlulukları ve veri ve hizmetlere yönelik ek klasörler için ayrı klasörler içerir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-123">The default template includes separate folders for MVC pattern responsibilities of Models, Views, and Controllers, as well as additional folders for Data and Services.</span></span> <span data-ttu-id="b7c92-124">Bu düzenlemede, sunum ayrıntıları görünümler klasörü için mümkün olduğunca sınırlı olmalıdır ve veri erişimi uygulama ayrıntıları veri klasöründe tutulan sınıflarla sınırlı olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-124">In this arrangement, presentation details should be limited as much as possible to the Views folder, and data access implementation details should be limited to classes kept in the Data folder.</span></span> <span data-ttu-id="b7c92-125">İş mantığı modeller klasörü içindeki hizmetler ve sınıflarda bulunmalıdır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-125">Business logic should reside in services and classes within the Models folder.</span></span>

<span data-ttu-id="b7c92-126">Basit olsa da, tek projem tek parçalı çözüm, bazı dezavantajlara sahiptir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-126">Although simple, the single-project monolithic solution has some disadvantages.</span></span> <span data-ttu-id="b7c92-127">Projenin boyutu ve karmaşıklığı büyüdükçe, dosya ve klasör sayısı da büyümeye devam edecektir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-127">As the project's size and complexity grows, the number of files and folders will continue to grow as well.</span></span> <span data-ttu-id="b7c92-128">Kullanıcı arabirimi (UI) konuları (modeller, görünümler, denetleyiciler), alfabetik olarak Gruplanmayan birden çok klasörde bulunur.</span><span class="sxs-lookup"><span data-stu-id="b7c92-128">User interface (UI) concerns (models, views, controllers) reside in multiple folders, which aren't grouped together alphabetically.</span></span> <span data-ttu-id="b7c92-129">Bu sorun, yalnızca filtreler veya Modelciltler gibi ek UI düzeyi yapılar kendi klasörlerine eklendiğinde daha kötü olur.</span><span class="sxs-lookup"><span data-stu-id="b7c92-129">This issue only gets worse when additional UI-level constructs, such as Filters or ModelBinders, are added in their own folders.</span></span> <span data-ttu-id="b7c92-130">İş mantığı modeller ve hizmetler klasörleri arasında dağınık ve klasörlere hangi sınıfların bağımlı olması gerektiğine dair net bir gösterge yoktur.</span><span class="sxs-lookup"><span data-stu-id="b7c92-130">Business logic is scattered between the Models and Services folders, and there's no clear indication of which classes in which folders should depend on which others.</span></span> <span data-ttu-id="b7c92-131">Proje düzeyindeki bu kuruluş eksikliği genellikle [spaghfeti koduna](https://deviq.com/spaghetti-code/)yol açar.</span><span class="sxs-lookup"><span data-stu-id="b7c92-131">This lack of organization at the project level frequently leads to [spaghetti code](https://deviq.com/spaghetti-code/).</span></span>

<span data-ttu-id="b7c92-132">Uygulamalar, bu sorunları çözmek için genellikle her projenin uygulamanın belirli bir _katmanında_ yer aldığı kabul edildiği çoklu proje çözümlerinde gelişmektedir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-132">To address these issues, applications often evolve into multi-project solutions, where each project is considered to reside in a particular _layer_ of the application.</span></span>

## <a name="what-are-layers"></a><span data-ttu-id="b7c92-133">Katmanlar nelerdir?</span><span class="sxs-lookup"><span data-stu-id="b7c92-133">What are layers?</span></span>

<span data-ttu-id="b7c92-134">Uygulamalar karmaşıklıkla büyüdükçe, bu karmaşıklığı yönetmenin bir yolu, uygulamayı sorumluluklara veya kaygılarına göre kesmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-134">As applications grow in complexity, one way to manage that complexity is to break up the application according to its responsibilities or concerns.</span></span> <span data-ttu-id="b7c92-135">Bu, endişeleri ayırmayı izler ve geliştiricilerin belirli işlevlerin uygulandığı yeri kolayca bulabilmeleri için büyüyen bir kod temelinin düzenlenmesine devam etmenize yardımcı olabilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-135">This follows the separation of concerns principle, and can help keep a growing codebase organized so that developers can easily find where certain functionality is implemented.</span></span> <span data-ttu-id="b7c92-136">Katmanlı mimari, yalnızca kod kuruluşunun ötesinde çok sayıda avantaj sunar, ancak.</span><span class="sxs-lookup"><span data-stu-id="b7c92-136">Layered architecture offers a number of advantages beyond just code organization, though.</span></span>

<span data-ttu-id="b7c92-137">Kodu katmanlara düzenleyerek, yaygın alt düzey işlevler uygulama genelinde yeniden kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-137">By organizing code into layers, common low-level functionality can be reused throughout the application.</span></span> <span data-ttu-id="b7c92-138">Bu yeniden kullanım yararlı olur çünkü bu, daha az kodun yazılması ve uygulamanın tek bir uygulamada standartlaştırılmasına izin verebileceğinden, [kendinizi yinelemeyin (kuru)](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) prensibi bir uygulamadır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-138">This reuse is beneficial because it means less code needs to be written and because it can allow the application to standardize on a single implementation, following the [don't repeat yourself (DRY)](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) principle.</span></span>

<span data-ttu-id="b7c92-139">Katmanlı mimari sayesinde uygulamalar, diğer katmanlarla iletişim kurabildiği katmanların kısıtlamalarını uygulayabilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-139">With a layered architecture, applications can enforce restrictions on which layers can communicate with other layers.</span></span> <span data-ttu-id="b7c92-140">Bu, kapsülleme elde etmenize yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="b7c92-140">This helps to achieve encapsulation.</span></span> <span data-ttu-id="b7c92-141">Bir katman değiştirildiğinde veya değiştirildiğinde, yalnızca onunla birlikte çalışan katmanların etkilenmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-141">When a layer is changed or replaced, only those layers that work with it should be impacted.</span></span> <span data-ttu-id="b7c92-142">Hangi katmanların diğer katmanlara bağlı olduğunu sınırlayarak, tek bir değişikliğin uygulamanın tamamını etkilememesi için değişikliklerin etkileri azaltılabilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-142">By limiting which layers depend on which other layers, the impact of changes can be mitigated so that a single change doesn't impact the entire application.</span></span>

<span data-ttu-id="b7c92-143">Katmanlar (ve Kapsülleme), uygulama içinde işlevselliğin değiştirilmesini çok daha kolay hale getirir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-143">Layers (and encapsulation) make it much easier to replace functionality within the application.</span></span> <span data-ttu-id="b7c92-144">Örneğin, bir uygulama başlangıçta kendi SQL Server veritabanını kalıcılık için kullanabilir, ancak daha sonra bulut tabanlı bir kalıcılık stratejisi veya bir Web API 'sinin arkasında bir tane kullanmayı tercih edebilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-144">For example, an application might initially use its own SQL Server database for persistence, but later could choose to use a cloud-based persistence strategy, or one behind a web API.</span></span> <span data-ttu-id="b7c92-145">Uygulama, kalıcılık uygulamasını mantıksal bir katmanda doğru şekilde kapsülleniyorsa, bu SQL Server belirli katman aynı ortak arabirimi uygulayan yeni bir katman ile değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-145">If the application has properly encapsulated its persistence implementation within a logical layer, that SQL Server specific layer could be replaced by a new one implementing the same public interface.</span></span>

<span data-ttu-id="b7c92-146">Uygulama katmanları, gereksinimlerdeki gelecekteki değişikliklere yanıt olarak, uygulamaların takas edilmesine ek olarak, uygulamaları test amacıyla değiştirmeyi de kolaylaştırabilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-146">In addition to the potential of swapping out implementations in response to future changes in requirements, application layers can also make it easier to swap out implementations for testing purposes.</span></span> <span data-ttu-id="b7c92-147">Uygulamanın gerçek veri katmanına veya Kullanıcı arabirimi katmanına karşı çalışan testler yazmak yerine, bu katmanlar, isteklere bilinen yanıtlar sağlayan sahte uygulamalarla birlikte test sırasında değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-147">Instead of having to write tests that operate against the real data layer or UI layer of the application, these layers can be replaced at test time with fake implementations that provide known responses to requests.</span></span> <span data-ttu-id="b7c92-148">Bu genellikle testlerin, uygulamanın gerçek altyapısına karşı testleri çalıştırmaya kıyasla daha kolay yazma ve çalışmayı çok daha kolay hale getirir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-148">This typically makes tests much easier to write and much faster to run when compared to running tests against the application's real infrastructure.</span></span>

<span data-ttu-id="b7c92-149">Mantıksal katmanlama, kurumsal yazılım uygulamalarında kod organizasyonunu iyileştirmeye yönelik yaygın bir tekniktir ve kodun katmanlara düzenlenebilmesinin birkaç yolu vardır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-149">Logical layering is a common technique for improving the organization of code in enterprise software applications, and there are several ways in which code can be organized into layers.</span></span>

> [!NOTE]
 > <span data-ttu-id="b7c92-150">_Katmanlar_ , uygulama içindeki mantıksal ayrımı temsil eder.</span><span class="sxs-lookup"><span data-stu-id="b7c92-150">_Layers_ represent logical separation within the application.</span></span> <span data-ttu-id="b7c92-151">Uygulama mantığının fiziksel olarak ayrı sunuculara veya işlemlere dağıtıldığı olayda, bu ayrı fiziksel dağıtım hedeflerine _Katman_olarak başvurulur.</span><span class="sxs-lookup"><span data-stu-id="b7c92-151">In the event that application logic is physically distributed to separate servers or processes, these separate physical deployment targets are referred to as _tiers_.</span></span> <span data-ttu-id="b7c92-152">Tek bir katmana dağıtılan N katmanlı bir uygulamanın olması mümkündür ve oldukça yaygındır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-152">It's possible, and quite common, to have an N-Layer application that is deployed to a single tier.</span></span>

## <a name="traditional-n-layer-architecture-applications"></a><span data-ttu-id="b7c92-153">Geleneksel "N katmanlı" mimari uygulamaları</span><span class="sxs-lookup"><span data-stu-id="b7c92-153">Traditional "N-Layer" architecture applications</span></span>

<span data-ttu-id="b7c92-154">En yaygın uygulama mantığı organizasyonu Şekil 5-2 ' de gösterilmiştir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-154">The most common organization of application logic into layers is shown in Figure 5-2.</span></span>

![Tipik uygulama katmanları](./media/image5-2.png)

<span data-ttu-id="b7c92-156">**Şekil 5-2.**</span><span class="sxs-lookup"><span data-stu-id="b7c92-156">**Figure 5-2.**</span></span> <span data-ttu-id="b7c92-157">Tipik uygulama katmanları.</span><span class="sxs-lookup"><span data-stu-id="b7c92-157">Typical application layers.</span></span>

<span data-ttu-id="b7c92-158">Bu katmanlar genellikle UI, BLL (Iş mantığı katmanı) ve DAL (veri erişim katmanı) olarak kısaltılır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-158">These layers are frequently abbreviated as UI, BLL (Business Logic Layer), and DAL (Data Access Layer).</span></span> <span data-ttu-id="b7c92-159">Kullanıcılar, bu mimariyi kullanarak yalnızca BLL ile etkileşime geçen Kullanıcı arabirimi katmanı üzerinden istek yapabilirler.</span><span class="sxs-lookup"><span data-stu-id="b7c92-159">Using this architecture, users make requests through the UI layer, which interacts only with the BLL.</span></span> <span data-ttu-id="b7c92-160">BLL, sırasıyla veri erişim istekleri için DAL çağırabilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-160">The BLL, in turn, can call the DAL for data access requests.</span></span> <span data-ttu-id="b7c92-161">Kullanıcı arabirimi katmanı, doğrudan DAL için herhangi bir istek yapmamalıdır ve doğrudan diğer yollarla kalıcı hale gelmelidir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-161">The UI layer shouldn't make any requests to the DAL directly, nor should it interact with persistence directly through other means.</span></span> <span data-ttu-id="b7c92-162">Benzer şekilde, BLL yalnızca DAL üzerinden gezinerek kalıcılığı ile etkileşime girebilmelidir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-162">Likewise, the BLL should only interact with persistence by going through the DAL.</span></span> <span data-ttu-id="b7c92-163">Bu şekilde, her katmanın kendi iyi bilinen sorumluluğu vardır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-163">In this way, each layer has its own well-known responsibility.</span></span>

<span data-ttu-id="b7c92-164">Bu geleneksel katmanlama yaklaşımının bir dezavantajı, derleme zamanı bağımlılıklarının üstten alta kadar çalıştırılmasıdır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-164">One disadvantage of this traditional layering approach is that compile-time dependencies run from the top to the bottom.</span></span> <span data-ttu-id="b7c92-165">Diğer bir deyişle, Kullanıcı arabirimi katmanı, DAL 'ye bağlı olan BLL 'e bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-165">That is, the UI layer depends on the BLL, which depends on the DAL.</span></span> <span data-ttu-id="b7c92-166">Bu, genellikle uygulamada en önemli mantığı tutan BLL 'in, veri erişimi uygulama ayrıntılarına (ve genellikle bir veritabanının varlığına) bağlı olduğu anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-166">This means that the BLL, which usually holds the most important logic in the application, is dependent on data access implementation details (and often on the existence of a database).</span></span> <span data-ttu-id="b7c92-167">Bu tür bir mimaride iş mantığını test etmek genellikle zordur ve test veritabanı gerektirir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-167">Testing business logic in such an architecture is often difficult, requiring a test database.</span></span> <span data-ttu-id="b7c92-168">Bu sorunu gidermek için, sonraki bölümde gördüğünüz gibi bağımlılık Inversion ilkesi kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-168">The dependency inversion principle can be used to address this issue, as you'll see in the next section.</span></span>

<span data-ttu-id="b7c92-169">Şekil 5-3, uygulamayı sorumluluğa (veya katmana) göre üç projeye bölmek için örnek bir çözüm gösterir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-169">Figure 5-3 shows an example solution, breaking the application into three projects by responsibility (or layer).</span></span>

![Üç projeyle oluşan basit bir tek parçalı uygulama](./media/image5-3.png)

<span data-ttu-id="b7c92-171">**Şekil 5-3.**</span><span class="sxs-lookup"><span data-stu-id="b7c92-171">**Figure 5-3.**</span></span> <span data-ttu-id="b7c92-172">Üç projeyle oluşan basit bir tek parçalı uygulama.</span><span class="sxs-lookup"><span data-stu-id="b7c92-172">A simple monolithic application with three projects.</span></span>

<span data-ttu-id="b7c92-173">Bu uygulama, kurumsal amaçlar için birkaç proje kullanmasına karşın, hala tek bir birim olarak dağıtılır ve istemcileri tek bir Web uygulaması olarak onunla etkileşime girecektir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-173">Although this application uses several projects for organizational purposes, it's still deployed as a single unit and its clients will interact with it as a single web app.</span></span> <span data-ttu-id="b7c92-174">Bu çok basit dağıtım sürecine izin verir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-174">This allows for very simple deployment process.</span></span> <span data-ttu-id="b7c92-175">Şekil 5-4, bu tür bir uygulamanın Azure kullanarak nasıl barındırıldığını gösterir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-175">Figure 5-4 shows how such an app might be hosted using Azure.</span></span>

![Azure Web uygulaması 'nın basit dağıtımı](./media/image5-4.png)

<span data-ttu-id="b7c92-177">**Şekil 5-4.**</span><span class="sxs-lookup"><span data-stu-id="b7c92-177">**Figure 5-4.**</span></span> <span data-ttu-id="b7c92-178">Azure Web uygulaması 'nın basit dağıtımı</span><span class="sxs-lookup"><span data-stu-id="b7c92-178">Simple deployment of Azure Web App</span></span>

<span data-ttu-id="b7c92-179">Uygulamanın büyümesi için daha karmaşık ve güçlü dağıtım çözümleri gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-179">As application needs grow, more complex and robust deployment solutions may be required.</span></span> <span data-ttu-id="b7c92-180">Şekil 5-5, ek özellikleri destekleyen daha karmaşık bir dağıtım planına bir örnek gösterir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-180">Figure 5-5 shows an example of a more complex deployment plan that supports additional capabilities.</span></span>

![Bir Web uygulamasını Azure App Service dağıtma](./media/image5-5.png)

<span data-ttu-id="b7c92-182">**Şekil 5-5.**</span><span class="sxs-lookup"><span data-stu-id="b7c92-182">**Figure 5-5.**</span></span> <span data-ttu-id="b7c92-183">Bir Web uygulamasını Azure App Service dağıtma</span><span class="sxs-lookup"><span data-stu-id="b7c92-183">Deploying a web app to an Azure App Service</span></span>

<span data-ttu-id="b7c92-184">Dahili olarak, bu projenin organizasyonu sorumluluğa göre birden çok projeye, uygulamanın bakım durumunu geliştirir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-184">Internally, this project's organization into multiple projects based on responsibility improves the maintainability of the application.</span></span>

<span data-ttu-id="b7c92-185">Bu birim, bulut tabanlı isteğe bağlı ölçeklenebilirlikten faydalanmak için yukarı veya dışarı genişletilebilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-185">This unit can be scaled up or out to take advantage of cloud-based on-demand scalability.</span></span> <span data-ttu-id="b7c92-186">Ölçeği artırma, uygulamanızı barındıran sunucuya ek CPU, bellek, disk alanı veya diğer kaynakları ekleme anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-186">Scaling up means adding additional CPU, memory, disk space, or other resources to the server(s) hosting your app.</span></span> <span data-ttu-id="b7c92-187">Ölçeği genişletme, bu tür sunucuların fiziksel sunucular, sanal makineler veya kapsayıcılar olup olmadığı gibi ek örnek ekleme anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-187">Scaling out means adding additional instances of such servers, whether these are physical servers, virtual machines, or containers.</span></span> <span data-ttu-id="b7c92-188">Uygulamanız birden çok örnek genelinde barındırılıyorsa, tek tek uygulama örneklerine istek atamak için bir yük dengeleyici kullanılır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-188">When your app is hosted across multiple instances, a load balancer is used to assign requests to individual app instances.</span></span>

<span data-ttu-id="b7c92-189">Azure 'da bir Web uygulamasını ölçeklendirmeye yönelik en basit yaklaşım, uygulamanın App Service planındaki ölçeklendirmeyi el ile yapılandırmaktır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-189">The simplest approach to scaling a web application in Azure is to configure scaling manually in the application's App Service Plan.</span></span> <span data-ttu-id="b7c92-190">Şekil 5-6, bir uygulamaya hizmet veren kaç örnek olduğunu yapılandırmak için uygun Azure panosu ekranını gösterir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-190">Figure 5-6 shows the appropriate Azure dashboard screen to configure how many instances are serving an app.</span></span>

![Azure 'da plan ölçeklendirmeyi App Service](./media/image5-6.png)

<span data-ttu-id="b7c92-192">**Şekil 5-6.**</span><span class="sxs-lookup"><span data-stu-id="b7c92-192">**Figure 5-6.**</span></span> <span data-ttu-id="b7c92-193">Azure 'da plan ölçeklendirmeyi App Service.</span><span class="sxs-lookup"><span data-stu-id="b7c92-193">App Service Plan scaling in Azure.</span></span>

## <a name="clean-architecture"></a><span data-ttu-id="b7c92-194">Mimariyi temizle</span><span class="sxs-lookup"><span data-stu-id="b7c92-194">Clean architecture</span></span>

<span data-ttu-id="b7c92-195">Bağımlılık Inversion Ilkesini ve etki alanı odaklı tasarım (DDD) ilkelerini izleyen uygulamalar benzer bir mimariye ulaşacak.</span><span class="sxs-lookup"><span data-stu-id="b7c92-195">Applications that follow the Dependency Inversion Principle as well as the Domain-Driven Design (DDD) principles tend to arrive at a similar architecture.</span></span> <span data-ttu-id="b7c92-196">Bu mimari, yıl boyunca pek çok adla geçmiş.</span><span class="sxs-lookup"><span data-stu-id="b7c92-196">This architecture has gone by many names over the years.</span></span> <span data-ttu-id="b7c92-197">İlk adlardan biri altılık mimariydi ve bağlantı noktaları ve bağdaştırıcılar tarafından izlenir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-197">One of the first names was Hexagonal Architecture, followed by Ports-and-Adapters.</span></span> <span data-ttu-id="b7c92-198">Daha yakın zamanda, [Çoklu kare mimarisi](https://jeffreypalermo.com/blog/the-onion-architecture-part-1/) veya [Temizleme mimarisi](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html)olarak alıntı yapılır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-198">More recently, it's been cited as the [Onion Architecture](https://jeffreypalermo.com/blog/the-onion-architecture-part-1/) or [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span></span> <span data-ttu-id="b7c92-199">İkinci ad, temiz mimari, bu e-kitapta bu mimarinin adı olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-199">The latter name, Clean Architecture, is used as the name for this architecture in this e-book.</span></span>

> [!NOTE]
> <span data-ttu-id="b7c92-200">Temiz mimari terimi, DDD Ilkeleri kullanılarak oluşturulan uygulamalara ve DDD kullanılarak oluşturulmayan uygulamalara uygulanabilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-200">The term Clean Architecture can be applied to applications that are built using DDD Principles as well as to those that are not built using DDD.</span></span> <span data-ttu-id="b7c92-201">Önceki durumda, Bu bileşim "Temizleme DDD mimarisi" olarak adlandırılabilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-201">In the case of the former, this combination may be referred to as "Clean DDD Architecture".</span></span>

<span data-ttu-id="b7c92-202">Temizleme mimarisi, iş mantığını ve uygulama modelini uygulamanın ortasına koyar.</span><span class="sxs-lookup"><span data-stu-id="b7c92-202">Clean architecture puts the business logic and application model at the center of the application.</span></span> <span data-ttu-id="b7c92-203">İş mantığını veri erişimine veya diğer altyapı kaygılarına bağlı olmak yerine, bu bağımlılık tersine çevrilir: altyapı ve uygulama ayrıntıları uygulama çekirdeğinize bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-203">Instead of having business logic depend on data access or other infrastructure concerns, this dependency is inverted: infrastructure and implementation details depend on the Application Core.</span></span> <span data-ttu-id="b7c92-204">Bu, uygulama çekirdeği içinde, daha sonra altyapı katmanında tanımlanan türler tarafından uygulanan soyutlamalar veya arabirimler tanımlayarak elde edilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-204">This is achieved by defining abstractions, or interfaces, in the Application Core, which are then implemented by types defined in the Infrastructure layer.</span></span> <span data-ttu-id="b7c92-205">Bu mimariyi görselleştirmenin yaygın bir yolu, bir çoklu kare ile benzer bir dizi Eşmerkezli daire kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-205">A common way of visualizing this architecture is to use a series of concentric circles, similar to an onion.</span></span> <span data-ttu-id="b7c92-206">Şekil 5-7, mimari gösteriminin bu stilinin bir örneğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-206">Figure 5-7 shows an example of this style of architectural representation.</span></span>

![Mimariyi Temizleme; soğan görünümü](./media/image5-7.png)

<span data-ttu-id="b7c92-208">**Şekil 5-7.**</span><span class="sxs-lookup"><span data-stu-id="b7c92-208">**Figure 5-7.**</span></span> <span data-ttu-id="b7c92-209">Mimariyi Temizleme; soğan görünümü</span><span class="sxs-lookup"><span data-stu-id="b7c92-209">Clean Architecture; onion view</span></span>

<span data-ttu-id="b7c92-210">Bu diyagramda, bağımlılıklar en içteki daireye doğru akar.</span><span class="sxs-lookup"><span data-stu-id="b7c92-210">In this diagram, dependencies flow toward the innermost circle.</span></span> <span data-ttu-id="b7c92-211">Uygulama çekirdeği, bu diyagramın üzerindeki konumundan adını alır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-211">The Application Core takes its name from its position at the core of this diagram.</span></span> <span data-ttu-id="b7c92-212">Ve diyagramda uygulama çekirdeğinin diğer uygulama katmanlarında hiçbir bağımlılığı olmadığını görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b7c92-212">And you can see on the diagram that the Application Core has no dependencies on other application layers.</span></span> <span data-ttu-id="b7c92-213">Uygulamanın varlıkları ve arabirimleri, çok merkezdir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-213">The application's entities and interfaces are at the very center.</span></span> <span data-ttu-id="b7c92-214">Yalnızca dışarıdaki, ancak hala uygulama çekirdeği 'nde, genellikle iç daire içinde tanımlanan arabirimleri uygulayan etki alanı hizmetlerdir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-214">Just outside, but still in the Application Core, are domain services, which typically implement interfaces defined in the inner circle.</span></span> <span data-ttu-id="b7c92-215">Uygulama çekirdeği dışında, hem Kullanıcı arabirimi hem de altyapı katmanları uygulama çekirdeğinize bağlıdır, ancak başka bir (her zaman).</span><span class="sxs-lookup"><span data-stu-id="b7c92-215">Outside of the Application Core, both the UI and the Infrastructure layers depend on the Application Core, but not on one another (necessarily).</span></span>

<span data-ttu-id="b7c92-216">Şekil 5-8, UI ve diğer Katmanlar arasındaki bağımlılığı daha iyi yansıtan daha geleneksel bir yatay katman diyagramını gösterir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-216">Figure 5-8 shows a more traditional horizontal layer diagram that better reflects the dependency between the UI and other layers.</span></span>

![Mimariyi Temizleme; Yatay katman görünümü](./media/image5-8.png)

<span data-ttu-id="b7c92-218">**Şekil 5-8.**</span><span class="sxs-lookup"><span data-stu-id="b7c92-218">**Figure 5-8.**</span></span> <span data-ttu-id="b7c92-219">Mimariyi Temizleme; Yatay katman görünümü</span><span class="sxs-lookup"><span data-stu-id="b7c92-219">Clean Architecture; horizontal layer view</span></span>

<span data-ttu-id="b7c92-220">Düz okların derleme zamanı bağımlılıklarını temsil ettiğini, kesikli ok ise yalnızca çalışma zamanı bağımlılığını temsil ettiğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="b7c92-220">Note that the solid arrows represent compile-time dependencies, while the dashed arrow represents a runtime-only dependency.</span></span> <span data-ttu-id="b7c92-221">Temizleme mimarisi sayesinde, UI katmanı derleme zamanında uygulama çekirdeğinde tanımlanan arabirimlerle birlikte çalışarak, ideal olarak altyapı katmanında tanımlanan uygulama türleri hakkında bilgi vermemelisiniz.</span><span class="sxs-lookup"><span data-stu-id="b7c92-221">With the clean architecture, the UI layer works with interfaces defined in the Application Core at compile time, and ideally shouldn't know about the implementation types defined in the Infrastructure layer.</span></span> <span data-ttu-id="b7c92-222">Bununla birlikte, çalışma zamanında uygulamanın yürütülmesi için bu uygulama türleri gereklidir, bu nedenle, bağımlılık ekleme yoluyla uygulama çekirdeği arabirimlerine bağlanmaları ve bunların kablolu olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-222">At run time, however, these implementation types are required for the app to execute, so they need to be present and wired up to the Application Core interfaces via dependency injection.</span></span>

<span data-ttu-id="b7c92-223">Şekil 5-9, bu önerileri izleyerek ASP.NET Core uygulamasının mimarisinin daha ayrıntılı bir görünümünü gösterir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-223">Figure 5-9 shows a more detailed view of an ASP.NET Core application's architecture when built following these recommendations.</span></span>

![Temizleme mimarisini izleyen mimari diyagramı ASP.NET Core](./media/image5-9.png)

<span data-ttu-id="b7c92-225">**Şekil 5-9.**</span><span class="sxs-lookup"><span data-stu-id="b7c92-225">**Figure 5-9.**</span></span> <span data-ttu-id="b7c92-226">Temizleme mimarisini izleyen mimari diyagramı ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="b7c92-226">ASP.NET Core architecture diagram following Clean Architecture.</span></span>

<span data-ttu-id="b7c92-227">Uygulama çekirdeği altyapıya bağlı olmadığından, bu katman için otomatik birim testlerini yazmak çok kolaydır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-227">Because the Application Core doesn't depend on Infrastructure, it's very easy to write automated unit tests for this layer.</span></span> <span data-ttu-id="b7c92-228">Şekil 5-10 ve 5-11, testlerin bu mimariye nasıl uyduğunu gösterir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-228">Figures 5-10 and 5-11 show how tests fit into this architecture.</span></span>

![UnitTestCore](./media/image5-10.png)

<span data-ttu-id="b7c92-230">**Şekil 5-10.**</span><span class="sxs-lookup"><span data-stu-id="b7c92-230">**Figure 5-10.**</span></span> <span data-ttu-id="b7c92-231">Birim testi uygulama çekirdeği yalıtımına göre.</span><span class="sxs-lookup"><span data-stu-id="b7c92-231">Unit testing Application Core in isolation.</span></span>

![Tümleştirme Testleri](./media/image5-11.png)

<span data-ttu-id="b7c92-233">**Şekil 5-11.**</span><span class="sxs-lookup"><span data-stu-id="b7c92-233">**Figure 5-11.**</span></span> <span data-ttu-id="b7c92-234">Dış bağımlılıklarla tümleştirme test altyapısı uygulamaları.</span><span class="sxs-lookup"><span data-stu-id="b7c92-234">Integration testing Infrastructure implementations with external dependencies.</span></span>

<span data-ttu-id="b7c92-235">UI katmanının altyapı projesinde tanımlı türler üzerinde doğrudan bağımlılığı olmadığından, uygulamayı kolaylaştırmak ya da uygulama gereksinimlerini değiştirmeye yanıt vermek için uygulamaları değiştirmek çok kolay olur.</span><span class="sxs-lookup"><span data-stu-id="b7c92-235">Since the UI layer doesn't have any direct dependency on types defined in the Infrastructure project, it's likewise very easy to swap out implementations, either to facilitate testing or in response to changing application requirements.</span></span> <span data-ttu-id="b7c92-236">ASP.NET Core yerleşik kullanımı ve bağımlılık ekleme için destek, bu mimarinin, önemsiz olmayan tek parçalı uygulamalar sağlamak için en uygun yolu sağlar.</span><span class="sxs-lookup"><span data-stu-id="b7c92-236">ASP.NET Core's built-in use of and support for dependency injection makes this architecture the most appropriate way to structure non-trivial monolithic applications.</span></span>

<span data-ttu-id="b7c92-237">Tek parçalı uygulamalar için uygulama çekirdeği, altyapı ve Kullanıcı arabirimi projelerinin hepsi tek bir uygulama olarak çalıştırılır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-237">For monolithic applications the Application Core, Infrastructure, and UI projects are all run as a single application.</span></span> <span data-ttu-id="b7c92-238">Çalışma zamanı uygulama mimarisi Şekil 5-12 gibi görünebilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-238">The runtime application architecture might look something like Figure 5-12.</span></span>

![ASP.NET Core mimarisi 2](./media/image5-12.png)

<span data-ttu-id="b7c92-240">**Şekil 5-12.**</span><span class="sxs-lookup"><span data-stu-id="b7c92-240">**Figure 5-12.**</span></span> <span data-ttu-id="b7c92-241">Örnek bir ASP.NET Core uygulamasının çalışma zamanı mimarisi.</span><span class="sxs-lookup"><span data-stu-id="b7c92-241">A sample ASP.NET Core app's runtime architecture.</span></span>

### <a name="organizing-code-in-clean-architecture"></a><span data-ttu-id="b7c92-242">Temiz mimaride kod düzenleme</span><span class="sxs-lookup"><span data-stu-id="b7c92-242">Organizing code in Clean Architecture</span></span>

<span data-ttu-id="b7c92-243">Temiz bir mimari çözümünde, her projede açık sorumluluklar vardır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-243">In a Clean Architecture solution, each project has clear responsibilities.</span></span> <span data-ttu-id="b7c92-244">Bu nedenle, belirli türler her bir projeye aittir ve ilgili projede bu türlere karşılık gelen klasörleri sıkça bulabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b7c92-244">As such, certain types belong in each project and you'll frequently find folders corresponding to these types in the appropriate project.</span></span>

<span data-ttu-id="b7c92-245">Uygulama çekirdeği, varlıklar, hizmetler ve arabirimler içeren iş modelini barındırır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-245">The Application Core holds the business model, which includes entities, services, and interfaces.</span></span> <span data-ttu-id="b7c92-246">Bu arabirimler, veri erişimi, dosya sistemi erişimi, ağ çağrıları vb. gibi altyapı kullanılarak gerçekleştirilecek işlemler için soyutlamalar içerir. Bazen bu katmanda tanımlanan hizmetlerin veya arabirimlerin, Kullanıcı arabirimi veya altyapıda bağımlılığı olmayan varlık olmayan türlerle çalışması gerekir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-246">These interfaces include abstractions for operations that will be performed using Infrastructure, such as data access, file system access, network calls, etc. Sometimes services or interfaces defined at this layer will need to work with non-entity types that have no dependencies on UI or Infrastructure.</span></span> <span data-ttu-id="b7c92-247">Bunlar, basit Veri Aktarımı nesneleri (DTOs) olarak tanımlanabilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-247">These can be defined as simple Data Transfer Objects (DTOs).</span></span>

### <a name="application-core-types"></a><span data-ttu-id="b7c92-248">Uygulama çekirdek türleri</span><span class="sxs-lookup"><span data-stu-id="b7c92-248">Application Core types</span></span>

- <span data-ttu-id="b7c92-249">Varlıklar (kalıcı olan iş modeli sınıfları)</span><span class="sxs-lookup"><span data-stu-id="b7c92-249">Entities (business model classes that are persisted)</span></span>
- <span data-ttu-id="b7c92-250">Arabirimler</span><span class="sxs-lookup"><span data-stu-id="b7c92-250">Interfaces</span></span>
- <span data-ttu-id="b7c92-251">Hizmetler</span><span class="sxs-lookup"><span data-stu-id="b7c92-251">Services</span></span>
- <span data-ttu-id="b7c92-252">DTO</span><span class="sxs-lookup"><span data-stu-id="b7c92-252">DTOs</span></span>

<span data-ttu-id="b7c92-253">Altyapı projesi genellikle veri erişim uygulamalarını içerir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-253">The Infrastructure project typically includes data access implementations.</span></span> <span data-ttu-id="b7c92-254">Tipik bir ASP.NET Core Web uygulamasında bu uygulamalar, Entity Framework (EF) DbContext, tanımlanmış olan EF Core `Migration` nesneleri ve veri erişimi uygulama sınıflarını içerir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-254">In a typical ASP.NET Core web application, these implementations include the Entity Framework (EF) DbContext, any EF Core `Migration` objects that have been defined, and data access implementation classes.</span></span> <span data-ttu-id="b7c92-255">Soyut veri erişimi uygulama kodunun en yaygın yolu, [Depo tasarımı deseninin](https://deviq.com/repository-pattern/)kullanımıdır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-255">The most common way to abstract data access implementation code is through the use of the [Repository design pattern](https://deviq.com/repository-pattern/).</span></span>

<span data-ttu-id="b7c92-256">Veri erişimi uygulamalarına ek olarak, altyapı projesi altyapı sorunları ile etkileşimde bulunmak zorunda olan hizmetlerin uygulamalarını içermelidir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-256">In addition to data access implementations, the Infrastructure project should contain implementations of services that must interact with infrastructure concerns.</span></span> <span data-ttu-id="b7c92-257">Bu hizmetler uygulama çekirdeğinde tanımlanmış arabirimleri uygulamalıdır ve bu nedenle altyapının uygulama çekirdeği projesine bir başvurusu olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-257">These services should implement interfaces defined in the Application Core, and so Infrastructure should have a reference to the Application Core project.</span></span>

### <a name="infrastructure-types"></a><span data-ttu-id="b7c92-258">Altyapı türleri</span><span class="sxs-lookup"><span data-stu-id="b7c92-258">Infrastructure types</span></span>

- <span data-ttu-id="b7c92-259">EF Core türleri (`DbContext`, `Migration`)</span><span class="sxs-lookup"><span data-stu-id="b7c92-259">EF Core types (`DbContext`, `Migration`)</span></span>
- <span data-ttu-id="b7c92-260">Veri erişimi uygulama türleri (depolar)</span><span class="sxs-lookup"><span data-stu-id="b7c92-260">Data access implementation types (Repositories)</span></span>
- <span data-ttu-id="b7c92-261">Altyapıya özgü hizmetler (örneğin, `FileLogger` veya) `SmtpNotifier`</span><span class="sxs-lookup"><span data-stu-id="b7c92-261">Infrastructure-specific services (for example, `FileLogger` or `SmtpNotifier`)</span></span>

<span data-ttu-id="b7c92-262">ASP.NET Core MVC uygulamasındaki kullanıcı arabirimi katmanı, uygulamanın giriş noktasıdır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-262">The user interface layer in an ASP.NET Core MVC application is the entry point for the application.</span></span> <span data-ttu-id="b7c92-263">Bu proje, uygulama çekirdeği projesine başvurmalıdır ve kendi türleri uygulama çekirdeğinde tanımlanan arabirimler aracılığıyla altyapıyla kesinlikle etkileşimde bulunmalıdır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-263">This project should reference the Application Core project, and its types should interact with infrastructure strictly through interfaces defined in Application Core.</span></span> <span data-ttu-id="b7c92-264">Kullanıcı arabirimi katmanında altyapı katmanı türlerine yönelik doğrudan örnek oluşturma veya statik çağrılara izin verilmelidir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-264">No direct instantiation of or static calls to the Infrastructure layer types should be allowed in the UI layer.</span></span>

### <a name="ui-layer-types"></a><span data-ttu-id="b7c92-265">UI katman türleri</span><span class="sxs-lookup"><span data-stu-id="b7c92-265">UI layer types</span></span>

- <span data-ttu-id="b7c92-266">Denetleyiciler</span><span class="sxs-lookup"><span data-stu-id="b7c92-266">Controllers</span></span>
- <span data-ttu-id="b7c92-267">Filtreler</span><span class="sxs-lookup"><span data-stu-id="b7c92-267">Filters</span></span>
- <span data-ttu-id="b7c92-268">Görünümler</span><span class="sxs-lookup"><span data-stu-id="b7c92-268">Views</span></span>
- <span data-ttu-id="b7c92-269">ViewModel 'lar</span><span class="sxs-lookup"><span data-stu-id="b7c92-269">ViewModels</span></span>
- <span data-ttu-id="b7c92-270">Başlangıç</span><span class="sxs-lookup"><span data-stu-id="b7c92-270">Startup</span></span>

<span data-ttu-id="b7c92-271">Başlangıç sınıfı, uygulamayı yapılandırmadan ve uygulama türlerini arabirimlere bağlamak için, bağımlılık ekleme işleminin çalışma zamanında düzgün çalışmasına izin verir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-271">The Startup class is responsible for configuring the application, and for wiring up implementation types to interfaces, allowing dependency injection to work properly at run time.</span></span>

> [!NOTE]
> <span data-ttu-id="b7c92-272">Kullanıcı arabirimi projesinin Startup.cs dosyasında, ConfigureServices 'e bağımlılık ekleme eklemek için, projenin altyapı projesine başvurması gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-272">In order to wire up dependency injection in ConfigureServices in the Startup.cs file of the UI project, the project may need to reference the Infrastructure project.</span></span> <span data-ttu-id="b7c92-273">Bu bağımlılık, bir özel dı kapsayıcısı kullanılarak en kolay şekilde ortadan kaldırılabilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-273">This dependency can be eliminated, most easily by using a custom DI container.</span></span> <span data-ttu-id="b7c92-274">Bu örneğin amaçları doğrultusunda, en basit yaklaşım, UI projesinin altyapı projesine başvurmasına izin verkullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-274">For the purposes of this sample, the simplest approach is to allow the UI project to reference the Infrastructure project.</span></span>

## <a name="monolithic-applications-and-containers"></a><span data-ttu-id="b7c92-275">Tek parçalı uygulamalar ve kapsayıcılar</span><span class="sxs-lookup"><span data-stu-id="b7c92-275">Monolithic applications and containers</span></span>

<span data-ttu-id="b7c92-276">Tek ve tek parçalı dağıtım temelli bir Web uygulaması veya hizmeti oluşturabilir ve bunu bir kapsayıcı olarak dağıtabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b7c92-276">You can build a single and monolithic-deployment based Web Application or Service and deploy it as a container.</span></span> <span data-ttu-id="b7c92-277">Uygulama içinde tek parçalı olmayabilir, ancak birçok kitaplık, bileşen veya katmana düzenlenmiş olabilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-277">Within the application, it might not be monolithic but organized into several libraries, components, or layers.</span></span> <span data-ttu-id="b7c92-278">Dışarıdan, tek bir işlem, tek bir Web uygulaması veya tek hizmet gibi tek bir kapsayıcıdır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-278">Externally, it's a single container like a single process, single web application, or single service.</span></span>

<span data-ttu-id="b7c92-279">Bu modeli yönetmek için, uygulamayı temsil etmek üzere tek bir kapsayıcı dağıtırsınız.</span><span class="sxs-lookup"><span data-stu-id="b7c92-279">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="b7c92-280">Ölçeklemek için, yalnızca bir yük dengeleyiciye sahip ek kopyalar eklemeniz yeterlidir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-280">To scale, just add additional copies with a load balancer in front.</span></span> <span data-ttu-id="b7c92-281">Kolaylık, tek bir kapsayıcıda veya VM 'de tek bir dağıtımı yönetmekten gelir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-281">The simplicity comes from managing a single deployment in a single container or VM.</span></span>

![Şekil 5-13](./media/image5-13.png)

<span data-ttu-id="b7c92-283">Şekil 5-13 ' de gösterildiği gibi, her bir kapsayıcı içinde birden çok bileşen/kitaplık veya iç katman ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b7c92-283">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 5-13.</span></span> <span data-ttu-id="b7c92-284">Ancak, _"bir kapsayıcı tek bir işlem yaptığı ve tek bir işlemde_yaptığı" kapsayıcı ilkesini takip eden tek parçalı desenler bir çakışma olabilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-284">But, following the container principle of _"a container does one thing, and does it in one process_", the monolithic pattern might be a conflict.</span></span>

<span data-ttu-id="b7c92-285">Bu yaklaşımın downi, uygulamanın ne zaman büyüdüğü, ölçeklendirilmesi için de gelir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-285">The downside of this approach comes if/when the application grows, requiring it to scale.</span></span> <span data-ttu-id="b7c92-286">Uygulamanın tamamı ölçeklenmez, aslında bir sorun değildir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-286">If the entire application scales, it's not really a problem.</span></span> <span data-ttu-id="b7c92-287">Ancak çoğu durumda, uygulamanın birkaç bölümü ölçeklendirmeyi gerektiren sıkıştırma noktalarınken diğer bileşenler daha az kullanılır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-287">However, in most cases, a few parts of the application are the choke points requiring scaling, while other components are used less.</span></span>

<span data-ttu-id="b7c92-288">Genellikle, büyük olasılıkla ölçeklendirmeniz gereken, ürün bilgileri bileşeni olan tipik duyun örneğini kullanarak.</span><span class="sxs-lookup"><span data-stu-id="b7c92-288">Using the typical eCommerce example, what you likely need to scale is the product information component.</span></span> <span data-ttu-id="b7c92-289">Birçok müşteri, ürünleri satın almanızdan daha fazla sayıda müşteriye gözatmasını</span><span class="sxs-lookup"><span data-stu-id="b7c92-289">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="b7c92-290">Daha fazla müşteri, kendi sepetini ödeme işlem hattını kullanmından kullanıyor.</span><span class="sxs-lookup"><span data-stu-id="b7c92-290">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="b7c92-291">Daha az müşteri, yorum ekler veya satın alma geçmişini görüntüler.</span><span class="sxs-lookup"><span data-stu-id="b7c92-291">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="b7c92-292">Yalnızca, tek bir bölgede, içerik ve pazarlama kampanyalarını yönetmesi gereken birkaç çalışanın olması olasıdır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-292">And you likely only have a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="b7c92-293">Tek parçalı tasarımı ölçeklendirerek, tüm kod birden çok kez dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-293">By scaling the monolithic design, all the code is deployed multiple times.</span></span>

<span data-ttu-id="b7c92-294">"Her şeyi ölçeklendirin" sorununa ek olarak, tek bir bileşendeki değişiklikler tüm uygulamanın tam olarak yeniden test edilmesini ve tüm örneklerin tam yeniden dağıtım yapılmasını gerektirir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-294">In addition to the "scale everything" problem, changes to a single component require complete retesting of the entire application, and a complete redeployment of all the instances.</span></span>

<span data-ttu-id="b7c92-295">Tek parçalı yaklaşım yaygındır ve birçok kuruluş bu mimari yaklaşımla geliştirilmektedir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-295">The monolithic approach is common, and many organizations are developing with this architectural approach.</span></span> <span data-ttu-id="b7c92-296">Çoğu, diğerleri sınırlara vururken çok iyi sonuç elde edilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-296">Many are having good enough results, while others are hitting limits.</span></span> <span data-ttu-id="b7c92-297">Bu modelde birçok uygulama tasarlanıyor, çünkü araçlar ve altyapı hizmet yönelimli mimariler (SOA) oluşturmak için çok zor olduğundan, uygulama grew 'a kadar ihtiyacı görmez.</span><span class="sxs-lookup"><span data-stu-id="b7c92-297">Many designed their applications in this model, because the tools and infrastructure were too difficult to build service-oriented architectures (SOA), and they didn't see the need until the app grew.</span></span> <span data-ttu-id="b7c92-298">Tek parçalı yaklaşım sınırlarına ulaşacağınızı fark ederseniz, kapsayıcıyı daha iyi hale getirebilmesine olanak tanımak üzere uygulamayı bölmek ve mikro hizmetler bir sonraki mantıksal adım olabilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-298">If you find you're hitting the limits of the monolithic approach, breaking up the app to enable it to better leverage containers and microservices may be the next logical step.</span></span>

![Şekil 5-14](./media/image5-14.png)

<span data-ttu-id="b7c92-300">Microsoft Azure tek parçalı uygulamalar dağıtmak, her örnek için adanmış VM 'Ler kullanılarak elde edilebilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-300">Deploying monolithic applications in Microsoft Azure can be achieved using dedicated VMs for each instance.</span></span> <span data-ttu-id="b7c92-301">[Azure sanal makine ölçek kümelerini](https://docs.microsoft.com/azure/virtual-machine-scale-sets/)kullanarak VM 'leri kolayca ölçeklendirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b7c92-301">Using [Azure Virtual Machine Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can easily scale the VMs.</span></span> <span data-ttu-id="b7c92-302">[Azure Uygulama Hizmetleri](https://azure.microsoft.com/services/app-service/) tek parçalı uygulamalar çalıştırabilir ve VM 'leri yönetmek zorunda kalmadan örnekleri kolayca ölçeklendirebilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-302">[Azure App Services](https://azure.microsoft.com/services/app-service/) can run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="b7c92-303">Azure Uygulama Hizmetleri, tek tek Docker Kapsayıcıları örnekleri çalıştırabilir ve dağıtımı basitleştirir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-303">Azure App Services can run single instances of Docker containers as well, simplifying the deployment.</span></span> <span data-ttu-id="b7c92-304">Docker 'ı kullanarak tek bir VM 'yi Docker Konağı olarak dağıtabilir ve birden çok örnek çalıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b7c92-304">Using Docker, you can deploy a single VM as a Docker host, and run multiple instances.</span></span> <span data-ttu-id="b7c92-305">Şekil 5-14 ' de gösterildiği gibi Azure dengeleyicisi 'ni kullanarak ölçeklendirmeyi yönetebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b7c92-305">Using the Azure balancer, as shown in the Figure 5-14, you can manage scaling.</span></span>

<span data-ttu-id="b7c92-306">Çeşitli konaklara dağıtım, geleneksel dağıtım teknikleri ile yönetilebilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-306">The deployment to the various hosts can be managed with traditional deployment techniques.</span></span> <span data-ttu-id="b7c92-307">Docker konakları el ile gerçekleştirilen ve sürekli teslim (CD) işlem hatları gibi Otomasyon aracılığıyla **Docker Run** gibi komutlarla yönetilebilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-307">The Docker hosts can be managed with commands like **docker run** performed manually, or through automation such as Continuous Delivery (CD) pipelines.</span></span>

### <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="b7c92-308">Kapsayıcı olarak dağıtılan tek parçalı uygulama</span><span class="sxs-lookup"><span data-stu-id="b7c92-308">Monolithic application deployed as a container</span></span>

<span data-ttu-id="b7c92-309">Tek parçalı uygulama dağıtımlarını yönetmek için kapsayıcıları kullanmanın avantajları vardır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-309">There are benefits of using containers to manage monolithic application deployments.</span></span> <span data-ttu-id="b7c92-310">Kapsayıcı örneklerinin ölçeklendirilmesi, ek VM 'Leri dağıtmaktan daha hızlı ve daha kolaydır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-310">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="b7c92-311">VM 'Leri ölçeklendirmek için sanal makine ölçek kümeleri kullanılırken bile, örnek bir süre sürer.</span><span class="sxs-lookup"><span data-stu-id="b7c92-311">Even when using virtual machine scale sets to scale VMs, they take time to instance.</span></span> <span data-ttu-id="b7c92-312">Uygulama örnekleri olarak dağıtıldığında, uygulamanın yapılandırması VM 'nin bir parçası olarak yönetilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-312">When deployed as app instances, the configuration of the app is managed as part of the VM.</span></span>

<span data-ttu-id="b7c92-313">Docker görüntüsü olarak güncelleştirmelerin dağıtımı, çok daha hızlı ve daha verimlidir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-313">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="b7c92-314">Docker görüntüleri genellikle Saniyeler içinde başlar, piyasaya çıkarma hızlandırın.</span><span class="sxs-lookup"><span data-stu-id="b7c92-314">Docker Images typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="b7c92-315">Docker örneğini aşağı doğru artırma, genellikle bir saniyeden daha az bir şekilde `docker stop` tamamlanan bir komut vermek kadar kolaydır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-315">Tearing down a Docker instance is as easy as issuing a `docker stop` command, typically completing in less than a second.</span></span>

<span data-ttu-id="b7c92-316">Kapsayıcılar, Tasarım gereği doğal olarak değişmez, ancak güncelleştirme betikleri, diskte kalan belirli bir yapılandırma veya dosya için hesabı unutabilirken, bu durumda bozuk VM 'Lerde endişelenmenize gerek kalmaz.</span><span class="sxs-lookup"><span data-stu-id="b7c92-316">As containers are inherently immutable by design, you never need to worry about corrupted VMs, whereas update scripts might forget to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="b7c92-317">Docker kapsayıcılarını, daha basit Web uygulamalarının tek parçalı dağıtımı için kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b7c92-317">You can use Docker containers for monolithic deployment of simpler web applications.</span></span> <span data-ttu-id="b7c92-318">Bu, sürekli tümleştirme ve sürekli dağıtım işlem hatlarını geliştirir ve dağıtım-üretim başarısını elde etmenize yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="b7c92-318">This improves continuous integration and continuous deployment pipelines and helps achieve deployment-to-production success.</span></span> <span data-ttu-id="b7c92-319">Daha fazla "makinenizde çalışmıyor, neden üretimde çalışmıyor?"</span><span class="sxs-lookup"><span data-stu-id="b7c92-319">No more “It works in my machine, why does it not work in production?”</span></span>

<span data-ttu-id="b7c92-320">Mikro hizmet tabanlı mimarinin birçok avantajı vardır, ancak bu avantajlar artan karmaşıklık maliyetlerine göre gelir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-320">A microservices-based architecture has many benefits, but those benefits come at a cost of increased complexity.</span></span> <span data-ttu-id="b7c92-321">Bazı durumlarda, maliyetler avantajlardan yararlanır. böylece tek bir kapsayıcıda veya yalnızca birkaç kapsayıcıda çalışan tek parçalı bir dağıtım uygulaması daha iyi bir seçenektir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-321">In some cases, the costs outweigh the benefits, so a monolithic deployment application running in a single container or in just a few containers is a better option.</span></span>

<span data-ttu-id="b7c92-322">Tek parçalı bir uygulama iyi ayrılmış mikro hizmetlere kolayca parçalanmayabilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-322">A monolithic application might not be easily decomposable into well-separated microservices.</span></span> <span data-ttu-id="b7c92-323">Mikro hizmetler, daha esnek bir uygulama sağlamak için birbirinden bağımsız olarak çalışmalıdır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-323">Microservices should work independently of each other to provide a more resilient application.</span></span> <span data-ttu-id="b7c92-324">Uygulamanın bağımsız Özellik dilimlerini teslim ediyorsanız, yalnızca karmaşıklık ekler.</span><span class="sxs-lookup"><span data-stu-id="b7c92-324">If you can't deliver independent feature slices of the application, separating it only adds complexity.</span></span>

<span data-ttu-id="b7c92-325">Uygulamanın özellikleri bağımsız olarak ölçeklendirmeniz gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-325">An application might not yet need to scale features independently.</span></span> <span data-ttu-id="b7c92-326">Birçok uygulama, tek bir örneği aşmaları gerektiğinde bunu, tüm örneği klonlamak için görece basit bir süreç aracılığıyla yapabilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-326">Many applications, when they need to scale beyond a single instance, can do so through the relatively simple process of cloning that entire instance.</span></span> <span data-ttu-id="b7c92-327">Uygulamayı ayrık hizmetlere ayırmak için ek iş, uygulamanın tam örneklerinin ölçeklendirilmesi basit ve ekonomik hale geldiğinde en az avantaj sağlar.</span><span class="sxs-lookup"><span data-stu-id="b7c92-327">The additional work to separate the application into discrete services provides minimal benefit when scaling full instances of the application is simple and cost-effective.</span></span>

<span data-ttu-id="b7c92-328">Uygulamanın geliştirilmesi sırasında, doğal işlev sınırlarının bulunduğu açık bir fikriniz olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-328">Early in the development of an application, you might not have a clear idea where the natural functional boundaries are.</span></span> <span data-ttu-id="b7c92-329">En az uygulanabilir bir ürün geliştirirken doğal ayrım henüz ortaya çıkabilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-329">As you develop a minimum viable product, the natural separation might not yet have emerged.</span></span> <span data-ttu-id="b7c92-330">Bu koşullardan bazıları geçici olabilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-330">Some of these conditions might be temporary.</span></span> <span data-ttu-id="b7c92-331">Tek parçalı bir uygulama oluşturarak başlayabilir ve daha sonra bazı özellikleri, mikro hizmetler olarak geliştirilip dağıtılacak şekilde ayırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b7c92-331">You might start by creating a monolithic application, and later separate some features to be developed and deployed as microservices.</span></span> <span data-ttu-id="b7c92-332">Diğer koşullar uygulamanın sorun alanı için önemli olabilir, yani uygulama hiçbir şekilde birden fazla mikro hizmete parçalanmayabilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-332">Other conditions might be essential to the application’s problem space, meaning that the application might never be broken into multiple microservices.</span></span>

<span data-ttu-id="b7c92-333">Bir uygulamayı birçok ayrı işleme ayırmak de ek yük getirir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-333">Separating an application into many discrete processes also introduces overhead.</span></span> <span data-ttu-id="b7c92-334">Özellikleri farklı işlemlere ayırma daha karmaşıktır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-334">There's more complexity in separating features into different processes.</span></span> <span data-ttu-id="b7c92-335">İletişim protokolleri daha karmaşık hale gelir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-335">The communication protocols become more complex.</span></span> <span data-ttu-id="b7c92-336">Yöntem çağrıları yerine, hizmetler arasında zaman uyumsuz iletişimler kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-336">Instead of method calls, you must use asynchronous communications between services.</span></span> <span data-ttu-id="b7c92-337">Mikro hizmetler mimarisine geçtiğinizde, eShopOnContainers uygulamasının mikro hizmetler sürümünde uygulanan yapı taşlarından çoğunu eklemeniz gerekir: olay veri yolu işleme, ileti dayanıklılığı ve yeniden denemeler, nihai tutarlılık ve daha fazlası.</span><span class="sxs-lookup"><span data-stu-id="b7c92-337">As you move to a microservices architecture, you need to add many of the building blocks implemented in the microservices version of the eShopOnContainers application: event bus handling, message resiliency and retries, eventual consistency, and more.</span></span>

<span data-ttu-id="b7c92-338">Çok daha basit [Eshoponweb Reference uygulaması](https://github.com/dotnet-architecture/eShopOnWeb) , tek Kapsayıcılı tek parçalı kapsayıcı kullanımını destekler.</span><span class="sxs-lookup"><span data-stu-id="b7c92-338">The much simpler [eShopOnWeb reference application](https://github.com/dotnet-architecture/eShopOnWeb) supports single-container monolithic container usage.</span></span> <span data-ttu-id="b7c92-339">Uygulama, geleneksel MVC görünümlerini, Web API 'Lerini ve Razor Pages içeren bir Web uygulaması içerir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-339">The application includes one web application that includes traditional MVC views, web APIs, and Razor Pages.</span></span> <span data-ttu-id="b7c92-340">Bu uygulama, `docker-compose build` ve `docker-compose up` komutları kullanılarak çözüm kökünden başlatılabilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-340">This application can be launched from the solution root using the `docker-compose build` and `docker-compose up` commands.</span></span> <span data-ttu-id="b7c92-341">Bu komut, Web projesinin kökünde `Dockerfile` bulunan ' i kullanarak Web örneği için bir kapsayıcı yapılandırır ve kapsayıcıyı belirtilen bir bağlantı noktasında çalıştırır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-341">This command configures a container for the web instance, using the `Dockerfile` found in the web project's root, and runs the container on a specified port.</span></span> <span data-ttu-id="b7c92-342">Bu uygulamanın kaynağını GitHub 'dan indirebilir ve yerel olarak çalıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b7c92-342">You can download the source for this application from GitHub and run it locally.</span></span> <span data-ttu-id="b7c92-343">Bu tek parçalı uygulama avantajlarının bir kapsayıcı ortamında dağıtılması bile.</span><span class="sxs-lookup"><span data-stu-id="b7c92-343">Even this monolithic application benefits from being deployed in a container environment.</span></span>

<span data-ttu-id="b7c92-344">Bir tane için Kapsayıcılı dağıtım, uygulamanın her örneğinin aynı ortamda çalıştığı anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-344">For one, the containerized deployment means that every instance of the application runs in the same environment.</span></span> <span data-ttu-id="b7c92-345">Bu, erken test ve geliştirmenin gerçekleştiği geliştirici ortamını içerir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-345">This includes the developer environment where early testing and development take place.</span></span> <span data-ttu-id="b7c92-346">Geliştirme ekibi, uygulamayı üretim ortamıyla eşleşen kapsayıcılı bir ortamda çalıştırabilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-346">The development team can run the application in a containerized environment that matches the production environment.</span></span>

<span data-ttu-id="b7c92-347">Ayrıca, Kapsayıcılı uygulamalar daha düşük maliyette ölçeği azaltır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-347">In addition, containerized applications scale out at lower cost.</span></span> <span data-ttu-id="b7c92-348">Kapsayıcı ortamının kullanılması, geleneksel VM ortamlarından daha fazla kaynak paylaşımını mümkün bir şekilde sunar.</span><span class="sxs-lookup"><span data-stu-id="b7c92-348">Using a container environment enables greater resource sharing than traditional VM environments.</span></span>

<span data-ttu-id="b7c92-349">Son olarak, uygulamayı kapsayıcı iş mantığı ve depolama sunucusu arasında ayrımı zorlar.</span><span class="sxs-lookup"><span data-stu-id="b7c92-349">Finally, containerizing the application forces a separation between the business logic and the storage server.</span></span> <span data-ttu-id="b7c92-350">Uygulama ölçeklendirilirken, birden çok kapsayıcı tek bir fiziksel depolama ortamına bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-350">As the application scales out, the multiple containers will all rely on a single physical storage medium.</span></span> <span data-ttu-id="b7c92-351">Bu depolama ortamı genellikle SQL Server veritabanı çalıştıran yüksek kullanılabilirliğe sahip bir sunucu olur.</span><span class="sxs-lookup"><span data-stu-id="b7c92-351">This storage medium would typically be a high-availability server running a SQL Server database.</span></span>

## <a name="docker-support"></a><span data-ttu-id="b7c92-352">Docker desteği</span><span class="sxs-lookup"><span data-stu-id="b7c92-352">Docker support</span></span>

<span data-ttu-id="b7c92-353">`eShopOnWeb` Proje .NET Core üzerinde çalışır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-353">The `eShopOnWeb` project runs on .NET Core.</span></span> <span data-ttu-id="b7c92-354">Bu nedenle, Linux tabanlı veya Windows tabanlı kapsayıcılardan çalıştırılabilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-354">Therefore, it can run in either Linux-based or Windows-based containers.</span></span> <span data-ttu-id="b7c92-355">Docker dağıtımı için SQL Server aynı konak türünü kullanmak istediğinizi unutmayın.</span><span class="sxs-lookup"><span data-stu-id="b7c92-355">Note that for Docker deployment, you want to use the same host type for SQL Server.</span></span> <span data-ttu-id="b7c92-356">Linux tabanlı kapsayıcılar daha küçük bir ayak izine izin verir ve tercih edilir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-356">Linux-based containers allow a smaller footprint and are preferred.</span></span>

<span data-ttu-id="b7c92-357">**Çözüm Gezgini** bir projeye sağ tıklayıp**Docker desteği** **Ekle** > ' yi seçerek var olan bir uygulamaya Docker desteği eklemek için Visual Studio 2017 veya sonraki bir sürümünü kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b7c92-357">You can use Visual Studio 2017 or later to add Docker support to an existing application by right-clicking on a project in **Solution Explorer** and choosing **Add** > **Docker Support**.</span></span> <span data-ttu-id="b7c92-358">Bu, gerekli dosyaları ekler ve projeyi kullanmak için değiştirir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-358">This adds the files required and modifies the project to use them.</span></span> <span data-ttu-id="b7c92-359">Geçerli `eShopOnWeb` örnekte bu dosyalar zaten var.</span><span class="sxs-lookup"><span data-stu-id="b7c92-359">The current `eShopOnWeb` sample already has these files in place.</span></span>

<span data-ttu-id="b7c92-360">Çözüm düzeyi `docker-compose.yml` dosya, hangi görüntülerin derlemesinin ve hangi kapsayıcıların başlatılabileceğinize ilişkin bilgiler içerir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-360">The solution-level `docker-compose.yml` file contains information about what images to build and what containers to launch.</span></span> <span data-ttu-id="b7c92-361">Bu dosya, aynı anda birden çok `docker-compose` uygulamayı başlatmak için komutunu kullanmanıza olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="b7c92-361">The file allows you to use the `docker-compose` command to launch multiple applications at the same time.</span></span> <span data-ttu-id="b7c92-362">Bu durumda, yalnızca Web projesi başlatılıyor.</span><span class="sxs-lookup"><span data-stu-id="b7c92-362">In this case, it is only launching the Web project.</span></span> <span data-ttu-id="b7c92-363">Ayrıca, ayrı bir veritabanı kapsayıcısı gibi bağımlılıkları yapılandırmak için de kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b7c92-363">You can also use it to configure dependencies, such as a separate database container.</span></span>

```yml
version: '3'

services:
  eshopwebmvc:
    image: eshopwebmvc
    build:
      context: .
      dockerfile: src/Web/Dockerfile
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
    ports:
      - "5106:5106"

networks:
  default:
    external:
      name: nat
```

<span data-ttu-id="b7c92-364">Dosya, `Web` projedeki öğesine `Dockerfile` başvurur. `docker-compose.yml`</span><span class="sxs-lookup"><span data-stu-id="b7c92-364">The `docker-compose.yml` file references the `Dockerfile` in the `Web` project.</span></span> <span data-ttu-id="b7c92-365">`Dockerfile` Kullanılacak temel kapsayıcıyı ve uygulamanın nasıl yapılandırılacağını belirtmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="b7c92-365">The `Dockerfile` is used to specify which base container will be used and how the application will be configured on it.</span></span> <span data-ttu-id="b7c92-366">`Web`' :`Dockerfile`</span><span class="sxs-lookup"><span data-stu-id="b7c92-366">The `Web`' `Dockerfile`:</span></span>

```Dockerfile
FROM mcr.microsoft.com/dotnet/core/sdk:2.2 AS build
WORKDIR /app

COPY *.sln .
COPY . .
WORKDIR /app/src/Web
RUN dotnet restore

RUN dotnet publish -c Release -o out

FROM mcr.microsoft.com/dotnet/core/aspnet:2.2 AS runtime
WORKDIR /app
COPY --from=build /app/src/Web/out ./

# Optional: Set this here if not setting it from docker-compose.yml
# ENV ASPNETCORE_ENVIRONMENT Development

ENTRYPOINT ["dotnet", "Web.dll"]
```

### <a name="troubleshooting-docker-problems"></a><span data-ttu-id="b7c92-367">Docker sorunlarını giderme</span><span class="sxs-lookup"><span data-stu-id="b7c92-367">Troubleshooting Docker problems</span></span>

<span data-ttu-id="b7c92-368">Kapsayıcılı uygulamayı çalıştırdıktan sonra, siz durduruncaya kadar çalışmaya devam eder.</span><span class="sxs-lookup"><span data-stu-id="b7c92-368">Once you run the containerized application, it continues to run until you stop it.</span></span> <span data-ttu-id="b7c92-369">`docker ps` Komutuyla hangi kapsayıcıların çalıştığını görüntüleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b7c92-369">You can view which containers are running with the `docker ps` command.</span></span> <span data-ttu-id="b7c92-370">`docker stop` Komutu kullanarak ve kapsayıcı kimliğini belirterek çalışan kapsayıcıyı durdurabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b7c92-370">You can stop a running container by using the `docker stop` command and specifying the container ID.</span></span>

<span data-ttu-id="b7c92-371">Docker Kapsayıcıları çalıştırmanın, daha önce geliştirme ortamınızda kullanmayı deneyebileceğinizi belirten bağlantı noktalarına bağlanmadığını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="b7c92-371">Note that running Docker containers may be bound to ports you might otherwise try to use in your development environment.</span></span> <span data-ttu-id="b7c92-372">Çalışan bir Docker kapsayıcısı ile aynı bağlantı noktasını kullanarak bir uygulamayı çalıştırmaya veya hata ayıklamanıza çalışırsanız, sunucunun o bağlantı noktasına bağlanmadığını belirten bir hata alırsınız.</span><span class="sxs-lookup"><span data-stu-id="b7c92-372">If you try to run or debug an application using the same port as a running Docker container, you'll get an error stating that the server can't bind to that port.</span></span> <span data-ttu-id="b7c92-373">Bir kez daha, kapsayıcıyı durdurmak sorunu çözmelidir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-373">Once again, stopping the container should resolve the issue.</span></span>

<span data-ttu-id="b7c92-374">Visual Studio kullanarak uygulamanıza Docker desteği eklemek istiyorsanız, bunu yaptığınızda Docker Desktop 'ın çalıştığından emin olun.</span><span class="sxs-lookup"><span data-stu-id="b7c92-374">If you want to add Docker support to your application using Visual Studio, make sure Docker Desktop is running when you do so.</span></span> <span data-ttu-id="b7c92-375">Sihirbazı başlattığınızda Docker Desktop çalışmıyorsa sihirbaz düzgün çalışmaz.</span><span class="sxs-lookup"><span data-stu-id="b7c92-375">The wizard won't run correctly if Docker Desktop isn't running when you start the wizard.</span></span> <span data-ttu-id="b7c92-376">Ayrıca, sihirbaz geçerli kapsayıcı seçiminizi inceleyerek doğru Docker desteğini de ekler.</span><span class="sxs-lookup"><span data-stu-id="b7c92-376">In addition, the wizard examines your current container choice to add the correct Docker support.</span></span> <span data-ttu-id="b7c92-377">Windows kapsayıcıları için destek eklemek istiyorsanız, Windows kapsayıcılarıyla çalışan Docker Desktop 'ı kullanırken Sihirbazı çalıştırmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="b7c92-377">If you want to add support for Windows Containers, you need to run the wizard while you have Docker Desktop running with Windows Containers configured.</span></span> <span data-ttu-id="b7c92-378">Linux kapsayıcıları için destek eklemek istiyorsanız, Linux kapsayıcılarıyla çalışırken Docker çalışırken Sihirbazı çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="b7c92-378">If you want to add support for Linux containers, run the wizard while you have Docker running with Linux containers configured.</span></span>

### <a name="references--common-web-architectures"></a><span data-ttu-id="b7c92-379">Başvurular – ortak Web mimarileri</span><span class="sxs-lookup"><span data-stu-id="b7c92-379">References – Common web architectures</span></span>

- <span data-ttu-id="b7c92-380">**Temizleme mimarisi**</span><span class="sxs-lookup"><span data-stu-id="b7c92-380">**The Clean Architecture**</span></span>  
  <https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html>
- <span data-ttu-id="b7c92-381">**Soğan mimarisi**</span><span class="sxs-lookup"><span data-stu-id="b7c92-381">**The Onion Architecture**</span></span>  
  <https://jeffreypalermo.com/blog/the-onion-architecture-part-1/>
- <span data-ttu-id="b7c92-382">**Depo deseninin**</span><span class="sxs-lookup"><span data-stu-id="b7c92-382">**The Repository Pattern**</span></span>  
  <https://deviq.com/repository-pattern/>
- <span data-ttu-id="b7c92-383">**Temizleme mimarisi çözüm örneği**</span><span class="sxs-lookup"><span data-stu-id="b7c92-383">**Clean Architecture Solution Sample**</span></span>  
  <https://github.com/ardalis/cleanarchitecture>
- <span data-ttu-id="b7c92-384">**Mikro hizmetler e-kitabı mimarisi**</span><span class="sxs-lookup"><span data-stu-id="b7c92-384">**Architecting Microservices e-book**</span></span>  
  <https://aka.ms/MicroservicesEbook>

>[!div class="step-by-step"]
><span data-ttu-id="b7c92-385">[Önceki](architectural-principles.md)
>[İleri](common-client-side-web-technologies.md)</span><span class="sxs-lookup"><span data-stu-id="b7c92-385">[Previous](architectural-principles.md)
[Next](common-client-side-web-technologies.md)</span></span>
