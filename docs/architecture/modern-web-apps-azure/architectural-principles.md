---
title: Mimari ilkeleri
description: ASP.NET Core ve Azure ile modern web uygulamalarını mimarın Mimari ilkeler
author: ardalis
ms.author: wiwagn
ms.date: 02/16/2019
ms.openlocfilehash: 656c92c417283366e4bb757489c189ecbc0ea815
ms.sourcegitcommit: 14ad34f7c4564ee0f009acb8bfc0ea7af3bc9541
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 11/01/2019
ms.locfileid: "73416697"
---
# <a name="architectural-principles"></a><span data-ttu-id="90a69-103">Mimari ilkeleri</span><span class="sxs-lookup"><span data-stu-id="90a69-103">Architectural principles</span></span>

> <span data-ttu-id="90a69-104">"Oluşturucular, programcıların programlar yazdığı şekilde bina gerçekleştirmişse, birlikte gelen ilk Woodpecker, Civil 'ı yok eder."</span><span class="sxs-lookup"><span data-stu-id="90a69-104">"If builders built buildings the way programmers wrote programs, then the first woodpecker that came along would destroy civilization."</span></span>  
> <span data-ttu-id="90a69-105">_\- Gerald Weinberg_</span><span class="sxs-lookup"><span data-stu-id="90a69-105">_\- Gerald Weinberg_</span></span>

<span data-ttu-id="90a69-106">Bakım yaparken yazılım çözümlerini mimariyle mimarın ve tasarlayabilmelisiniz.</span><span class="sxs-lookup"><span data-stu-id="90a69-106">You should architect and design software solutions with maintainability in mind.</span></span> <span data-ttu-id="90a69-107">Bu bölümde özetlenen ilkeler, temiz ve sürdürülebilir uygulamalara yol açacak mimari kararlara kılavuzluk etmenize yardımcı olabilir.</span><span class="sxs-lookup"><span data-stu-id="90a69-107">The principles outlined in this section can help guide you toward architectural decisions that will result in clean, maintainable applications.</span></span> <span data-ttu-id="90a69-108">Genellikle, bu ilkeler, uygulamanızın diğer bölümlerine sıkı bir şekilde bağlı olmayan, ancak açık arabirimler veya mesajlaşma sistemleri aracılığıyla iletişim kuran ayrık bileşenlerden uygulamalar oluşturmaya nasıl kılavuzluk eder.</span><span class="sxs-lookup"><span data-stu-id="90a69-108">Generally, these principles will guide you toward building applications out of discrete components that are not tightly coupled to other parts of your application, but rather communicate through explicit interfaces or messaging systems.</span></span>

## <a name="common-design-principles"></a><span data-ttu-id="90a69-109">Ortak tasarım ilkeleri</span><span class="sxs-lookup"><span data-stu-id="90a69-109">Common design principles</span></span>

### <a name="separation-of-concerns"></a><span data-ttu-id="90a69-110">Kaygıları ayırma</span><span class="sxs-lookup"><span data-stu-id="90a69-110">Separation of concerns</span></span>

<span data-ttu-id="90a69-111">Geliştirme, **kaygılara ayrımı**olduğunda bir temel ilke.</span><span class="sxs-lookup"><span data-stu-id="90a69-111">A guiding principle when developing is **Separation of Concerns**.</span></span> <span data-ttu-id="90a69-112">Bu ilke, yazılımın gerçekleştirdiği iş türlerine göre ayrılması gerektiğini onaylar.</span><span class="sxs-lookup"><span data-stu-id="90a69-112">This principle asserts that software should be separated based on the kinds of work it performs.</span></span> <span data-ttu-id="90a69-113">Örneğin, kullanıcıya görüntülenecek önemli öğeleri tanımlamaya yönelik mantığı ve bu tür öğeleri daha dikkat çekici hale getirmek için belirli bir şekilde biçimlendiren bu uygulamayı düşünün.</span><span class="sxs-lookup"><span data-stu-id="90a69-113">For instance, consider an application that includes logic for identifying noteworthy items to display to the user, and which formats such items in a particular way to make them more noticeable.</span></span> <span data-ttu-id="90a69-114">Yalnızca birbirleriyle ilişkili olan ayrı konular olduğundan, hangi öğelerin biçimlendirileceğini seçmekten sorumlu davranış, öğelerin biçimlendirmesinden sorumlu davranışlardan ayrı tutulmalıdır.</span><span class="sxs-lookup"><span data-stu-id="90a69-114">The behavior responsible for choosing which items to format should be kept separate from the behavior responsible for formatting the items, since these are separate concerns that are only coincidentally related to one another.</span></span>

<span data-ttu-id="90a69-115">Mimari türsel uygulamalar, temel iş davranışını altyapı ve Kullanıcı arabirimi mantığından ayırarak bu ilkeyi izlemek üzere mantıksal olarak derlenebilir.</span><span class="sxs-lookup"><span data-stu-id="90a69-115">Architecturally, applications can be logically built to follow this principle by separating core business behavior from infrastructure and user interface logic.</span></span> <span data-ttu-id="90a69-116">İdeal olarak, iş kuralları ve Logic, uygulamadaki diğer projelere bağlı olmaması gereken ayrı bir projede yer almalıdır.</span><span class="sxs-lookup"><span data-stu-id="90a69-116">Ideally, business rules and logic should reside in a separate project, which should not depend on other projects in the application.</span></span> <span data-ttu-id="90a69-117">Bu, iş modelinin test etmek kolay olduğundan ve alt düzey uygulama ayrıntılarına sıkı bir şekilde yönlendirilmeden geliştirilebilen sağlanmasına yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="90a69-117">This helps ensure that the business model is easy to test and can evolve without being tightly coupled to low-level implementation details.</span></span> <span data-ttu-id="90a69-118">Kaygıları ayrımı, uygulama mimarilerinde katmanların kullanımı arkasında önemli bir noktadır.</span><span class="sxs-lookup"><span data-stu-id="90a69-118">Separation of concerns is a key consideration behind the use of layers in application architectures.</span></span>

### <a name="encapsulation"></a><span data-ttu-id="90a69-119">Kapsül</span><span class="sxs-lookup"><span data-stu-id="90a69-119">Encapsulation</span></span>

<span data-ttu-id="90a69-120">Uygulamanın farklı bölümlerinin uygulamanın diğer bölümlerinden yalıtılmış olması için **kapsülleme** kullanması gerekir.</span><span class="sxs-lookup"><span data-stu-id="90a69-120">Different parts of an application should use **encapsulation** to insulate them from other parts of the application.</span></span> <span data-ttu-id="90a69-121">Dış sözleşmelerin ihlal olmaması koşuluyla, uygulama bileşenleri ve katmanları, kendi ortak bileşenlerini bozmadan iç uygulamasını ayarlayabilmelidir.</span><span class="sxs-lookup"><span data-stu-id="90a69-121">Application components and layers should be able to adjust their internal implementation without breaking their collaborators as long as external contracts are not violated.</span></span> <span data-ttu-id="90a69-122">Doğru kapsülleme kullanımı, nesne ve paketlerin farklı uygulamalarla değiştirilmesini sağlamak için uygulama tasarımlarında gevşek Pave modülerlik sağlamaya yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="90a69-122">Proper use of encapsulation helps achieve loose coupling and modularity in application designs, since objects and packages can be replaced with alternative implementations so long as the same interface is maintained.</span></span>

<span data-ttu-id="90a69-123">Sınıflarda, sınıfın iç durumuna erişimi dışarıdan kısıtlamak için kapsülleme elde edilir.</span><span class="sxs-lookup"><span data-stu-id="90a69-123">In classes, encapsulation is achieved by limiting outside access to the class's internal state.</span></span> <span data-ttu-id="90a69-124">Bir dış aktör nesnenin durumunu işlemek istiyorsa, nesnenin özel durumuna doğrudan erişim sağlamak yerine iyi tanımlanmış bir işlev (veya özellik ayarlayıcısı) aracılığıyla bunu yapması gerekir.</span><span class="sxs-lookup"><span data-stu-id="90a69-124">If an outside actor wants to manipulate the state of the object, it should do so through a well-defined function (or property setter), rather than having direct access to the private state of the object.</span></span> <span data-ttu-id="90a69-125">Benzer şekilde, uygulama bileşenlerinin ve uygulamaların kendisi, durumunun doğrudan değiştirilmesine izin vermek yerine, kendi ortak çalışanları için iyi tanımlanmış arabirimler kullanıma sunmalıdır.</span><span class="sxs-lookup"><span data-stu-id="90a69-125">Likewise, application components and applications themselves should expose well-defined interfaces for their collaborators to use, rather than allowing their state to be modified directly.</span></span> <span data-ttu-id="90a69-126">Bu, uygulamanın dahili tasarımını zaman içinde geliştikçe, genel sözleşmelerin bakımını yaptığı sürece iş çalışanları kesintiye uğratır.</span><span class="sxs-lookup"><span data-stu-id="90a69-126">This frees the application's internal design to evolve over time without worrying that doing so will break collaborators, so long as the public contracts are maintained.</span></span>

### <a name="dependency-inversion"></a><span data-ttu-id="90a69-127">Bağımlılık Inversion</span><span class="sxs-lookup"><span data-stu-id="90a69-127">Dependency inversion</span></span>

<span data-ttu-id="90a69-128">Uygulamanın içindeki bağımlılığın yönü, uygulama ayrıntıları değil soyutlama yönünde olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="90a69-128">The direction of dependency within the application should be in the direction of abstraction, not implementation details.</span></span> <span data-ttu-id="90a69-129">Çoğu uygulama, çalışma zamanı yürütme yönündeki derleme zamanı bağımlılığı akışları gibi yazılır.</span><span class="sxs-lookup"><span data-stu-id="90a69-129">Most applications are written such that compile-time dependency flows in the direction of runtime execution.</span></span> <span data-ttu-id="90a69-130">Bu, doğrudan bağımlılık grafiği oluşturur.</span><span class="sxs-lookup"><span data-stu-id="90a69-130">This produces a direct dependency graph.</span></span> <span data-ttu-id="90a69-131">Diğer bir deyişle, A modülü C modülünde bir işlevi çağıran Modül B 'de bir işlevi çağırırsa, sonra da şekil 4-1 ' de gösterildiği gibi C 'ye bağlı olan B 'ye bağlı olarak değişir.</span><span class="sxs-lookup"><span data-stu-id="90a69-131">That is, if module A calls a function in module B, which calls a function in module C, then at compile time A will depend on B which will depend on C, as shown in Figure 4-1.</span></span>

![Doğrudan bağımlılık grafiği](./media/image4-1.png)

<span data-ttu-id="90a69-133">**Şekil 4-1.**</span><span class="sxs-lookup"><span data-stu-id="90a69-133">**Figure 4-1.**</span></span> <span data-ttu-id="90a69-134">Doğrudan bağımlılık grafiği.</span><span class="sxs-lookup"><span data-stu-id="90a69-134">Direct dependency graph.</span></span>

<span data-ttu-id="90a69-135">Bağımlılık Inversion ilkesini uygulamak, bir soyutlamalarda b 'nin uyguladığı bir soyutlama üzerinde Yöntemler çağırabilmesini, bir A 'nın çalışma zamanında B çağrısı yapmasını mümkün hale getirir, ancak B için derleme zamanında bir tarafından denetlenen bir arabirime bağımlı olur (Bu *nedenle, tipik olarak* derleme zamanı bağımlılığı).</span><span class="sxs-lookup"><span data-stu-id="90a69-135">Applying the dependency inversion principle allows A to call methods on an abstraction that B implements, making it possible for A to call B at runtime, but for B to depend on an interface controlled by A at compile time (thus, *inverting* the typical compile-time dependency).</span></span> <span data-ttu-id="90a69-136">Çalışma zamanında, program yürütme akışı değişmeden kalır, ancak arabirimlerin tanıtımı bu arabirimlerin farklı uygulamalarının kolayca takılmasına yol açabilir.</span><span class="sxs-lookup"><span data-stu-id="90a69-136">At run time, the flow of program execution remains unchanged, but the introduction of interfaces means that different implementations of these interfaces can easily be plugged in.</span></span>

![Ters bağımlılık grafiği](./media/image4-2.png)

<span data-ttu-id="90a69-138">**Şekil 4-2.**</span><span class="sxs-lookup"><span data-stu-id="90a69-138">**Figure 4-2.**</span></span> <span data-ttu-id="90a69-139">Ters bağımlılık grafiği.</span><span class="sxs-lookup"><span data-stu-id="90a69-139">Inverted dependency graph.</span></span>

<span data-ttu-id="90a69-140">**Bağımlılık Inversion** , gevşek olarak bağlanmış uygulamalar oluşturmanın önemli bir parçasıdır. bu sayede uygulama ayrıntıları, diğer bir yöntem yerine daha yüksek düzey soyutlamalar uygulamak ve uygulamak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="90a69-140">**Dependency inversion** is a key part of building loosely-coupled applications, since implementation details can be written to depend on and implement higher level abstractions, rather than the other way around.</span></span> <span data-ttu-id="90a69-141">Elde edilen uygulamalar daha kararlı, modüler ve sonuç olarak sürdürülebilir.</span><span class="sxs-lookup"><span data-stu-id="90a69-141">The resulting applications are more testable, modular, and maintainable as a result.</span></span> <span data-ttu-id="90a69-142">Bağımlılık/sürüm prensibi ile *bağımlılık ekleme* yöntemi mümkündür.</span><span class="sxs-lookup"><span data-stu-id="90a69-142">The practice of *dependency injection* is made possible by following the dependency inversion principle.</span></span>

### <a name="explicit-dependencies"></a><span data-ttu-id="90a69-143">Açık bağımlılıklar</span><span class="sxs-lookup"><span data-stu-id="90a69-143">Explicit dependencies</span></span>

<span data-ttu-id="90a69-144">**Yöntemler ve sınıflar, doğru çalışması için ihtiyaç duydukları tüm işbirliği nesneleri açıkça gerektirmelidir.**</span><span class="sxs-lookup"><span data-stu-id="90a69-144">**Methods and classes should explicitly require any collaborating objects they need in order to function correctly.**</span></span> <span data-ttu-id="90a69-145">Sınıf oluşturucular, sınıfların geçerli bir durumda olması ve düzgün çalışması için ihtiyaç duydukları şeyleri belirlemesine yönelik bir fırsat sağlar.</span><span class="sxs-lookup"><span data-stu-id="90a69-145">Class constructors provide an opportunity for classes to identify the things they need in order to be in a valid state and to function properly.</span></span> <span data-ttu-id="90a69-146">Oluşturulabilir ve çağrılabilir olan, ancak yalnızca belirli küresel veya altyapı bileşenleri varsa düzgün şekilde çalışacak sınıflar tanımlarsanız, bu sınıflar *istemcilerle birlikte kabul* edilir.</span><span class="sxs-lookup"><span data-stu-id="90a69-146">If you define classes that can be constructed and called, but which will only function properly if certain global or infrastructure components are in place, these classes are being *dishonest* with their clients.</span></span> <span data-ttu-id="90a69-147">Oluşturucu sözleşmesi, istemciye yalnızca belirtilen şeyleri (sınıf parametresiz bir Oluşturucu kullanıyorsa Nothing) ister, daha sonra çalışma zamanında nesneyi, başka bir şeye ihtiyaç duyması durumunda olduğunu bildiriyor.</span><span class="sxs-lookup"><span data-stu-id="90a69-147">The constructor contract is telling the client that it only needs the things specified (possibly nothing if the class is just using a parameterless constructor), but then at runtime it turns out the object really did need something else.</span></span>

<span data-ttu-id="90a69-148">Açık bağımlılıklar ilkesini izleyerek, sınıflarınız ve yöntemleriniz, işlevleri çalışması için ihtiyaç duydukları gibi istemcilerle birlikte kullanılır.</span><span class="sxs-lookup"><span data-stu-id="90a69-148">By following the explicit dependencies principle, your classes and methods are being honest with their clients about what they need in order to function.</span></span> <span data-ttu-id="90a69-149">Bu, kodunuzun daha kolay belgelendikleri ve kodlarınızın, yöntem veya Oluşturucu parametreleri biçiminde gerekli olanları sağladıklarında güveneceği ve üzerinde çalıştıkları nesneler olduğu sürece daha fazla Kullanıcı dostu hale gelmesine neden olur. çalışma zamanında düzgün şekilde.</span><span class="sxs-lookup"><span data-stu-id="90a69-149">This makes your code more self-documenting and your coding contracts more user-friendly, since users will come to trust that as long as they provide what's required in the form of method or constructor parameters, the objects they're working with will behave correctly at runtime.</span></span>

### <a name="single-responsibility"></a><span data-ttu-id="90a69-150">Tek sorumluluk</span><span class="sxs-lookup"><span data-stu-id="90a69-150">Single responsibility</span></span>

<span data-ttu-id="90a69-151">Tek sorumluluk ilkesi, nesne odaklı tasarım için geçerlidir, ancak sorunların ayrılılmasına benzer bir mimari prensibi olarak da düşünülebilir.</span><span class="sxs-lookup"><span data-stu-id="90a69-151">The single responsibility principle applies to object-oriented design, but can also be considered as an architectural principle similar to separation of concerns.</span></span> <span data-ttu-id="90a69-152">Nesnelerin yalnızca bir sorumluluğu olması gerektiğini ve yalnızca bir sorumluluğun olması gerektiğini belirtir.</span><span class="sxs-lookup"><span data-stu-id="90a69-152">It states that objects should have only one responsibility and that they should have only one reason to change.</span></span> <span data-ttu-id="90a69-153">Özellikle, nesnenin değiştirilmesi gereken tek durum, bir sorumluluğu tek bir sorumluluğu gerçekleştirmelidir.</span><span class="sxs-lookup"><span data-stu-id="90a69-153">Specifically, the only situation in which the object should change is if the manner in which it performs its one responsibility must be updated.</span></span> <span data-ttu-id="90a69-154">Bu prensibi, daha gevşek bağlanmış ve modüler sistemler oluşturulmasına yardımcı olur, çünkü birçok yeni davranış, mevcut sınıflara ek sorumluluk eklemek yerine yeni sınıflar olarak uygulanırlar.</span><span class="sxs-lookup"><span data-stu-id="90a69-154">Following this principle helps to produce more loosely-coupled and modular systems, since many kinds of new behavior can be implemented as new classes, rather than by adding additional responsibility to existing classes.</span></span> <span data-ttu-id="90a69-155">Yeni sınıflar eklemek, hiçbir kod henüz yeni sınıflara bağlı olmadığından, her zaman var olan sınıfları değiştirmekle daha güvenlidir.</span><span class="sxs-lookup"><span data-stu-id="90a69-155">Adding new classes is always safer than changing existing classes, since no code yet depends on the new classes.</span></span>

<span data-ttu-id="90a69-156">Tek parçalı bir uygulamada, tek sorumluluk ilkesini uygulamadaki katmanlara yüksek düzeyde uygulayabiliriz.</span><span class="sxs-lookup"><span data-stu-id="90a69-156">In a monolithic application, we can apply the single responsibility principle at a high level to the layers in the application.</span></span> <span data-ttu-id="90a69-157">Sunum sorumluluğu, veri erişimi sorumluluğunun bir altyapı projesi içinde tutulması gerektiği sırada, Kullanıcı arabirimi projesinde kalmalıdır.</span><span class="sxs-lookup"><span data-stu-id="90a69-157">Presentation responsibility should remain in the UI project, while data access responsibility should be kept within an infrastructure project.</span></span> <span data-ttu-id="90a69-158">İş mantığı, kolayca test edileceği ve diğer sorumluluklardan bağımsız olarak gelişebilecekleri uygulama çekirdeği projesinde tutulmalıdır.</span><span class="sxs-lookup"><span data-stu-id="90a69-158">Business logic should be kept in the application core project, where it can be easily tested and can evolve independently from other responsibilities.</span></span>

<span data-ttu-id="90a69-159">Bu ilke uygulama mimarisine uygulandığında ve mantıksal uç noktasına götürülürsünüz, mikro hizmetleri alırsınız.</span><span class="sxs-lookup"><span data-stu-id="90a69-159">When this principle is applied to application architecture, and taken to its logical endpoint, you get microservices.</span></span> <span data-ttu-id="90a69-160">Belirli bir mikro hizmet tek bir sorumluluğa sahip olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="90a69-160">A given microservice should have a single responsibility.</span></span> <span data-ttu-id="90a69-161">Bir sistemin davranışını genişletmenize ihtiyacınız varsa, var olan bir sorumluluğu eklemek yerine daha fazla mikro hizmet ekleyerek bunu yapmak genellikle daha iyidir.</span><span class="sxs-lookup"><span data-stu-id="90a69-161">If you need to extend the behavior of a system, it's usually better to do it by adding additional microservices, rather than by adding responsibility to an existing one.</span></span>

[<span data-ttu-id="90a69-162">Mikro hizmet mimarisi hakkında daha fazla bilgi edinin</span><span class="sxs-lookup"><span data-stu-id="90a69-162">Learn more about microservices architecture</span></span>](https://aka.ms/MicroservicesEbook)

### <a name="dont-repeat-yourself-dry"></a><span data-ttu-id="90a69-163">Kendinizi yinelemeyin (kuru)</span><span class="sxs-lookup"><span data-stu-id="90a69-163">Don't repeat yourself (DRY)</span></span>

<span data-ttu-id="90a69-164">Uygulama, sık karşılaşılan hataların bir kaynağı olduğundan, birden çok yerde belirli bir kavram ile ilgili davranışları belirtmekten kaçınmalıdır.</span><span class="sxs-lookup"><span data-stu-id="90a69-164">The application should avoid specifying behavior related to a particular concept in multiple places as this is a frequent source of errors.</span></span> <span data-ttu-id="90a69-165">Bir noktada, gereksinimlerde bir değişiklik bu davranışın değiştirilmesini gerektirir ve davranışın en az bir örneğinin güncelleştirilemeyebilir, sistemin tutarsız davranışına neden olur.</span><span class="sxs-lookup"><span data-stu-id="90a69-165">At some point, a change in requirements will require changing this behavior and the likelihood that at least one instance of the behavior will fail to be updated will result in inconsistent behavior of the system.</span></span>

<span data-ttu-id="90a69-166">Mantığı çoğaltmak yerine bir programlama yapısında kapsülleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="90a69-166">Rather than duplicating logic, encapsulate it in a programming construct.</span></span> <span data-ttu-id="90a69-167">Bu davranış üzerinde tek bir yetki oluşturun ve uygulamanın bu davranışı gerektiren başka bir bölümü yeni yapıyı kullanın.</span><span class="sxs-lookup"><span data-stu-id="90a69-167">Make this construct the single authority over this behavior, and have any other part of the application that requires this behavior use the new construct.</span></span>

> [!NOTE]
> <span data-ttu-id="90a69-168">Yalnızca tesadüfen yinelenen bir davranışı bağlamaktan kaçının.</span><span class="sxs-lookup"><span data-stu-id="90a69-168">Avoid binding together behavior that is only coincidentally repetitive.</span></span> <span data-ttu-id="90a69-169">Örneğin, yalnızca iki farklı sabit değerin aynı değere sahip olması nedeniyle, kavramsal olarak farklı şeylere başvurduklarında yalnızca bir sabit değeri olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="90a69-169">For example, just because two different constants both have the same value, that doesn't mean you should have only one constant, if conceptually they're referring to different things.</span></span>

### <a name="persistence-ignorance"></a><span data-ttu-id="90a69-170">Kalıcılık Ignorance</span><span class="sxs-lookup"><span data-stu-id="90a69-170">Persistence ignorance</span></span>

<span data-ttu-id="90a69-171">**Kalıcılık Ignorance** (PI), kalıcı olması gereken türlere başvurur, ancak kodu Kalıcılık teknolojisi seçimi tarafından etkilenmemiştir.</span><span class="sxs-lookup"><span data-stu-id="90a69-171">**Persistence ignorance** (PI) refers to types that need to be persisted, but whose code is unaffected by the choice of persistence technology.</span></span> <span data-ttu-id="90a69-172">.NET 'teki bu tür türler, belirli bir temel sınıftan devralması veya belirli bir arabirim uygulamak zorunda olmadıkları için bazen düz eski CLR nesneleri (POCOs) olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="90a69-172">Such types in .NET are sometimes referred to as Plain Old CLR Objects (POCOs), because they do not need to inherit from a particular base class or implement a particular interface.</span></span> <span data-ttu-id="90a69-173">Aynı iş modelinin birden çok şekilde kalıcı olmasını sağladığından, uygulama için ek esneklik sunarak Kalıcılık kalıcılığı önem taşır.</span><span class="sxs-lookup"><span data-stu-id="90a69-173">Persistence ignorance is valuable because it allows the same business model to be persisted in multiple ways, offering additional flexibility to the application.</span></span> <span data-ttu-id="90a69-174">Kalıcılık seçimleri zaman içinde, bir veritabanı teknolojisinden diğerine değişebilir ya da uygulamanın başladığı her şeyi (örneğin, bir Redsıs önbelleği veya Azure Cosmos DB ek olarak ilişkisel veritabanı).</span><span class="sxs-lookup"><span data-stu-id="90a69-174">Persistence choices might change over time, from one database technology to another, or additional forms of persistence might be required in addition to whatever the application started with (for example, using a Redis cache or Azure Cosmos DB in addition to a relational database).</span></span>

<span data-ttu-id="90a69-175">Bu ilkeye yönelik ihlallere örnek olarak şunlar verilebilir:</span><span class="sxs-lookup"><span data-stu-id="90a69-175">Some examples of violations of this principle include:</span></span>

- <span data-ttu-id="90a69-176">Gerekli bir temel sınıf.</span><span class="sxs-lookup"><span data-stu-id="90a69-176">A required base class.</span></span>

- <span data-ttu-id="90a69-177">Gerekli bir arabirim uygulamasıdır.</span><span class="sxs-lookup"><span data-stu-id="90a69-177">A required interface implementation.</span></span>

- <span data-ttu-id="90a69-178">Kendilerini kaydetmekten sorumlu sınıflar (örneğin, etkin kayıt deseninin).</span><span class="sxs-lookup"><span data-stu-id="90a69-178">Classes responsible for saving themselves (such as the Active Record pattern).</span></span>

- <span data-ttu-id="90a69-179">Parametresiz Oluşturucu gerekli.</span><span class="sxs-lookup"><span data-stu-id="90a69-179">Required parameterless constructor.</span></span>

- <span data-ttu-id="90a69-180">Sanal anahtar sözcük gerektiren özellikler.</span><span class="sxs-lookup"><span data-stu-id="90a69-180">Properties requiring virtual keyword.</span></span>

- <span data-ttu-id="90a69-181">Kalıcılığa özgü gerekli öznitelikler.</span><span class="sxs-lookup"><span data-stu-id="90a69-181">Persistence-specific required attributes.</span></span>

<span data-ttu-id="90a69-182">Sınıfların yukarıdaki özelliklerden veya davranışların herhangi birine sahip olması, kalıcı hale getirilmesi gereken türler ve kalıcılık teknolojileri seçimi arasında bir kuponu ekleyerek yeni veri erişim stratejilerini daha da benimsemeyi daha kolay hale getirir.</span><span class="sxs-lookup"><span data-stu-id="90a69-182">The requirement that classes have any of the above features or behaviors adds coupling between the types to be persisted and the choice of persistence technology, making it more difficult to adopt new data access strategies in the future.</span></span>

### <a name="bounded-contexts"></a><span data-ttu-id="90a69-183">Sınırlanmış bağlamlar</span><span class="sxs-lookup"><span data-stu-id="90a69-183">Bounded contexts</span></span>

<span data-ttu-id="90a69-184">**Sınırlanmış bağlamlar** , etki alanı odaklı tasarımda merkezi bir modeldir.</span><span class="sxs-lookup"><span data-stu-id="90a69-184">**Bounded contexts** are a central pattern in Domain-Driven Design.</span></span> <span data-ttu-id="90a69-185">Bu kişiler, büyük uygulamalarda veya kuruluşlarda, farklı kavramsal modüllere kadar bölmek için bir yol sağlar.</span><span class="sxs-lookup"><span data-stu-id="90a69-185">They provide a way of tackling complexity in large applications or organizations by breaking it up into separate conceptual modules.</span></span> <span data-ttu-id="90a69-186">Her kavramsal modül daha sonra diğer bağlamlardan ayrılan (Bu nedenle, sınırlı) bir bağlamı temsil eder ve bağımsız olarak gelişebilirler.</span><span class="sxs-lookup"><span data-stu-id="90a69-186">Each conceptual module then represents a context which is separated from other contexts (hence, bounded), and can evolve independently.</span></span> <span data-ttu-id="90a69-187">Her sınırlanmış bağlam, içindeki kavramlar için kendi adlarını seçmek üzere ideal olmalıdır ve kendi kalıcılık deposuna özel erişime sahip olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="90a69-187">Each bounded context should ideally be free to choose its own names for concepts within it, and should have exclusive access to its own persistence store.</span></span>

<span data-ttu-id="90a69-188">En azından, bireysel Web uygulamaları, bir veritabanını diğer uygulamalarla paylaşmak yerine kendi iş modeliyle ilgili kendi Kalıcılık depolarıyla birlikte kendi sınırlı bağlamlarına sahip olmaya devam etmelidir.</span><span class="sxs-lookup"><span data-stu-id="90a69-188">At a minimum, individual web applications should strive to be their own bounded context, with their own persistence store for their business model, rather than sharing a database with other applications.</span></span> <span data-ttu-id="90a69-189">Sınırlanmış bağlamlar arasındaki iletişim, paylaşılan bir veritabanı yerine, iş mantığı ve olayların gerçekleşen değişikliklere yanıt olarak gerçekleşmesini sağlayan, paylaşılan bir veritabanı yerine programlı arabirimler aracılığıyla oluşur.</span><span class="sxs-lookup"><span data-stu-id="90a69-189">Communication between bounded contexts occurs through programmatic interfaces, rather than through a shared database, which allows for business logic and events to take place in response to changes that take place.</span></span> <span data-ttu-id="90a69-190">Sınırlanmış bağlamlar, mikro hizmetlere yakın bir şekilde eşlenir ve ayrıca kendi kendine sınırlanmış bağlamlar olarak ideal şekilde uygulanır.</span><span class="sxs-lookup"><span data-stu-id="90a69-190">Bounded contexts map closely to microservices, which also are ideally implemented as their own individual bounded contexts.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="90a69-191">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="90a69-191">Additional resources</span></span>

- [<span data-ttu-id="90a69-192">JAVA tasarım desenleri: Ilkeler</span><span class="sxs-lookup"><span data-stu-id="90a69-192">JAVA Design Patterns: Principles</span></span>](https://java-design-patterns.com/principles/)
- [<span data-ttu-id="90a69-193">Sınırlanmış bağlam</span><span class="sxs-lookup"><span data-stu-id="90a69-193">Bounded Context</span></span>](https://martinfowler.com/bliki/BoundedContext.html)

>[!div class="step-by-step"]
><span data-ttu-id="90a69-194">[Önceki](choose-between-traditional-web-and-single-page-apps.md)
>[İleri](common-web-application-architectures.md)</span><span class="sxs-lookup"><span data-stu-id="90a69-194">[Previous](choose-between-traditional-web-and-single-page-apps.md)
[Next](common-web-application-architectures.md)</span></span>
