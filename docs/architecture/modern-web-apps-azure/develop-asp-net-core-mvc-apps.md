---
title: ASP.NET Core MVC uygulamaları geliştirme
description: ASP.NET Core ve Azure ile modern web uygulamalarını mimarın ASP.NET Core MVC uygulamaları geliştirme
author: ardalis
ms.author: wiwagn
ms.date: 08/12/2020
no-loc:
- Blazor
- WebAssembly
ms.openlocfilehash: 255a7f9b34752b3480ba5a8ffc5d506e6d7b05d3
ms.sourcegitcommit: 0c3ce6d2e7586d925a30f231f32046b7b3934acb
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 09/08/2020
ms.locfileid: "89515988"
---
# <a name="develop-aspnet-core-mvc-apps"></a><span data-ttu-id="a8471-103">ASP.NET Core MVC uygulamaları geliştirin</span><span class="sxs-lookup"><span data-stu-id="a8471-103">Develop ASP.NET Core MVC apps</span></span>

> <span data-ttu-id="a8471-104">"İlk kez bu hakkı almak önemli değildir.</span><span class="sxs-lookup"><span data-stu-id="a8471-104">"It's not important to get it right the first time.</span></span> <span data-ttu-id="a8471-105">Bu, son kez doğru bir şekilde almak için önemlidir. "</span><span class="sxs-lookup"><span data-stu-id="a8471-105">It's vitally important to get it right the last time."</span></span>  
> <span data-ttu-id="a8471-106">_-Andrew Hunt ve David Thomas_</span><span class="sxs-lookup"><span data-stu-id="a8471-106">_- Andrew Hunt and David Thomas_</span></span>

<span data-ttu-id="a8471-107">ASP.NET Core, bulutta iyileştirilmiş Modern Web uygulamaları oluşturmak için platformlar arası, açık kaynaklı bir çerçevedir.</span><span class="sxs-lookup"><span data-stu-id="a8471-107">ASP.NET Core is a cross-platform, open-source framework for building modern cloud-optimized web applications.</span></span> <span data-ttu-id="a8471-108">ASP.NET Core uygulamalar basit ve modüler olduğundan, bağımlılık ekleme desteği sayesinde daha fazla test ve bakım olanağı sağlanır.</span><span class="sxs-lookup"><span data-stu-id="a8471-108">ASP.NET Core apps are lightweight and modular, with built-in support for dependency injection, enabling greater testability and maintainability.</span></span> <span data-ttu-id="a8471-109">Görüntüleme tabanlı uygulamalara ek olarak Modern Web API 'Leri oluşturmayı destekleyen MVC ile birlikte ASP.NET Core, kurumsal web uygulamaları oluşturmak için kullanabileceğiniz güçlü bir çerçevedir.</span><span class="sxs-lookup"><span data-stu-id="a8471-109">Combined with MVC, which supports building modern web APIs in addition to view-based apps, ASP.NET Core is a powerful framework with which to build enterprise web applications.</span></span>

## <a name="mvc-and-razor-pages"></a><span data-ttu-id="a8471-110">MVC ve Razor Pages</span><span class="sxs-lookup"><span data-stu-id="a8471-110">MVC and Razor Pages</span></span>

<span data-ttu-id="a8471-111">ASP.NET Core MVC, Web tabanlı API 'Ler ve uygulamalar oluşturmak için yararlı olan birçok özellik sunar.</span><span class="sxs-lookup"><span data-stu-id="a8471-111">ASP.NET Core MVC offers many features that are useful for building web-based APIs and apps.</span></span> <span data-ttu-id="a8471-112">MVC terimi, Kullanıcı isteklerine birkaç parçaya yanıt verme sorumluluklarını kesen bir kullanıcı arabirimi modeli olan "model-görünüm-denetleyicisi" için temsil eder.</span><span class="sxs-lookup"><span data-stu-id="a8471-112">The term MVC stands for "Model-View-Controller", a UI pattern that breaks up the responsibilities of responding to user requests into several parts.</span></span> <span data-ttu-id="a8471-113">Bu düzenin yanı sıra, Razor Pages olarak ASP.NET Core uygulamalarında özellikler de uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-113">In addition to following this pattern, you can also implement features in your ASP.NET Core apps as Razor Pages.</span></span> <span data-ttu-id="a8471-114">Razor Pages, MVC ASP.NET Core yerleşik olarak bulunur ve yönlendirme, model bağlama, filtreler, yetkilendirme vb. için aynı özellikleri kullanır. Bununla birlikte, denetleyiciler, modeller, görünümler, vb. için ayrı klasörler ve dosyalar olması yerine, Razor Pages tek bir klasöre ("/Pages") konur, bu klasördeki göreli konumlarına göre rota ve istekleri denetleyici eylemleri yerine işleyicilerle işleyebilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-114">Razor Pages are built into ASP.NET Core MVC, and use the same features for routing, model binding, filters, authorization, etc. However, instead of having separate folders and files for Controllers, Models, Views, etc. and using attribute-based routing, Razor Pages are placed in a single folder ("/Pages"), route based on their relative location in this folder, and handle requests with handlers instead of controller actions.</span></span> <span data-ttu-id="a8471-115">Sonuç olarak, Razor Pages ile çalışırken, ihtiyacınız olan tüm dosya ve sınıflar genellikle Web projesi genelinde yayılmaz.</span><span class="sxs-lookup"><span data-stu-id="a8471-115">As a result, when working with Razor Pages, all of the files and classes you need are typically colocated, not spread throughout the web project.</span></span>

<span data-ttu-id="a8471-116">Yeni bir ASP.NET Core uygulaması oluşturduğunuzda, derlemek istediğiniz uygulama türü için bir plana sahip olmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="a8471-116">When you create a new ASP.NET Core App, you should have a plan in mind for the kind of app you want to build.</span></span> <span data-ttu-id="a8471-117">Visual Studio 'da çeşitli şablonlardan seçim yapmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="a8471-117">In Visual Studio, you'll choose from several templates.</span></span> <span data-ttu-id="a8471-118">En yaygın üç proje şablonu Web API 'SI, Web uygulaması ve Web uygulaması (Model-View-Controller).</span><span class="sxs-lookup"><span data-stu-id="a8471-118">The three most common project templates are Web API, Web Application, and Web Application (Model-View-Controller).</span></span> <span data-ttu-id="a8471-119">Bu kararı yalnızca bir proje oluştururken yapmanız mümkün olsa da, geri alınamaz bir karardır.</span><span class="sxs-lookup"><span data-stu-id="a8471-119">Although you can only make this decision when you first create a project, it's not an irrevocable decision.</span></span> <span data-ttu-id="a8471-120">Web API projesi standart model-görünüm-denetleyici denetleyicileri kullanır; varsayılan olarak yalnızca görünümler eksiktir.</span><span class="sxs-lookup"><span data-stu-id="a8471-120">The Web API project uses standard Model-View-Controller controllers – it just lacks Views by default.</span></span> <span data-ttu-id="a8471-121">Benzer şekilde, varsayılan Web uygulaması şablonu Razor Pages kullanır ve aynı zamanda bir görünümler klasörü eksiktir.</span><span class="sxs-lookup"><span data-stu-id="a8471-121">Likewise, the default Web Application template uses Razor Pages, and so also lacks a Views folder.</span></span> <span data-ttu-id="a8471-122">Görünüm tabanlı davranışı desteklemek için bu projelere daha sonra bir görünümler klasörü ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-122">You can add a Views folder to these projects later to support view-based behavior.</span></span> <span data-ttu-id="a8471-123">Web API ve model-görünüm-denetleyicisi projeleri varsayılan olarak bir Pages klasörü içermez, ancak daha sonra Razor Pages tabanlı davranışı desteklemek için bir tane ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-123">Web API and Model-View-Controller projects don't include a Pages folder by default, but you can add one later to support Razor Pages-based behavior.</span></span> <span data-ttu-id="a8471-124">Üç farklı türde varsayılan kullanıcı etkileşimini desteklemek için bu üç şablonu düşünebilirsiniz: veri (Web API 'SI), sayfa tabanlı ve görünüm tabanlı.</span><span class="sxs-lookup"><span data-stu-id="a8471-124">You can think of these three templates as supporting three different kinds of default user interaction: data (web API), page-based, and view-based.</span></span> <span data-ttu-id="a8471-125">Bununla birlikte, isterseniz tek bir proje içinde bunlardan herhangi birini veya tümünü karıştırabilir ve eşleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-125">However, you can mix and match any or all of these within a single project if you wish.</span></span>

### <a name="why-razor-pages"></a><span data-ttu-id="a8471-126">Neden Razor Pages?</span><span class="sxs-lookup"><span data-stu-id="a8471-126">Why Razor Pages?</span></span>

<span data-ttu-id="a8471-127">Razor Pages, Visual Studio 'da yeni Web uygulamaları için varsayılan yaklaşımdır.</span><span class="sxs-lookup"><span data-stu-id="a8471-127">Razor Pages is the default approach for new web applications in Visual Studio.</span></span> <span data-ttu-id="a8471-128">Razor Pages, SPA olmayan formlar gibi sayfa tabanlı uygulama özelliklerini oluşturmanın daha basit bir yolunu sunar.</span><span class="sxs-lookup"><span data-stu-id="a8471-128">Razor Pages offers a simpler way of building page-based application features, such as non-SPA forms.</span></span> <span data-ttu-id="a8471-129">Denetleyiciler ve görünümleri kullanarak, uygulamaların birçok farklı bağımlılıklarla çalışan çok büyük denetleyicileri olması ve modelleri görüntülemesi ve birçok farklı görünüm döndürdüğünden yaygındır.</span><span class="sxs-lookup"><span data-stu-id="a8471-129">Using controllers and views, it was common for applications to have very large controllers that worked with many different dependencies and view models and returned many different views.</span></span> <span data-ttu-id="a8471-130">Bu, daha karmaşıklığa neden olur ve genellikle tek sorumluluk Ilkesini veya açık/kapalı Ilkeleri etkili bir şekilde izleyen denetleyicilerle sonuçlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="a8471-130">This resulted in more complexity and often resulted in controllers that didn't follow the Single Responsibility Principle or Open/Closed Principles effectively.</span></span> <span data-ttu-id="a8471-131">Razor Pages, Razor işaretlemesi ile bir Web uygulamasındaki belirli bir mantıksal "sayfa" için sunucu tarafı mantığını kapsülleyerek bu sorunu giderir.</span><span class="sxs-lookup"><span data-stu-id="a8471-131">Razor Pages addresses this issue by encapsulating the server-side logic for a given logical "page" in a web application with its Razor markup.</span></span> <span data-ttu-id="a8471-132">Sunucu tarafı mantığı olmayan bir Razor sayfası, yalnızca bir Razor dosyasından (örneğin, "Index. cshtml") oluşabilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-132">A Razor Page that has no server-side logic can simply consist of a Razor file (for instance, "Index.cshtml").</span></span> <span data-ttu-id="a8471-133">Ancak, önemsiz olmayan Razor Pages ilişkili bir sayfa modeli sınıfına sahip olur. Bu, kurala göre, ". cs" uzantısıyla Razor dosyası ile aynı ada sahiptir (örneğin, "Index.cshtml.cs").</span><span class="sxs-lookup"><span data-stu-id="a8471-133">However, most non-trivial Razor Pages will have an associated page model class, which by convention is named the same as the Razor file with a ".cs" extension (for example, "Index.cshtml.cs").</span></span>

<span data-ttu-id="a8471-134">Bir Razor sayfasının sayfa modeli, bir MVC denetleyicisinin ve viewmodelinin sorumluluklarını birleştirir.</span><span class="sxs-lookup"><span data-stu-id="a8471-134">A Razor Page's page model combines the responsibilities of an MVC controller and a viewmodel.</span></span> <span data-ttu-id="a8471-135">İstekleri denetleyici eylem yöntemleriyle işlemek yerine, "OnGet ()" gibi sayfa modeli işleyicileri, ilişkili sayfaları varsayılan olarak işlenerek yürütülür.</span><span class="sxs-lookup"><span data-stu-id="a8471-135">Instead of handling requests with controller action methods, page model handlers like "OnGet()" are executed, rendering their associated page by default.</span></span> <span data-ttu-id="a8471-136">Razor Pages, ASP.NET Core MVC 'nin tüm mimari özelliklerini sağlamaya devam ederken, tek tek sayfaları bir ASP.NET Core uygulamasında oluşturma işlemini basitleştirir.</span><span class="sxs-lookup"><span data-stu-id="a8471-136">Razor Pages simplifies the process of building individual pages in an ASP.NET Core app, while still providing all the architectural features of ASP.NET Core MVC.</span></span> <span data-ttu-id="a8471-137">Bu, yeni sayfa tabanlı işlevselliği için iyi bir varsayılan seçenektir.</span><span class="sxs-lookup"><span data-stu-id="a8471-137">They're a good default choice for new page-based functionality.</span></span>

### <a name="when-to-use-mvc"></a><span data-ttu-id="a8471-138">MVC ne zaman kullanılır?</span><span class="sxs-lookup"><span data-stu-id="a8471-138">When to use MVC</span></span>

<span data-ttu-id="a8471-139">Web API 'Leri oluşturuyorsanız, MVC deseninin Razor Pages kullanmayı deneenden daha anlamlı hale gelir.</span><span class="sxs-lookup"><span data-stu-id="a8471-139">If you're building web APIs, the MVC pattern makes more sense than trying to use Razor Pages.</span></span> <span data-ttu-id="a8471-140">Projeniz yalnızca Web API uç noktalarını kullanıma sunacaktır, ideal olarak Web API proje şablonundan başlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="a8471-140">If your project will only expose web API endpoints, you should ideally start from the Web API project template.</span></span> <span data-ttu-id="a8471-141">Aksi takdirde, denetleyiciler ve ilgili API uç noktalarını herhangi bir ASP.NET Core uygulamasına eklemek kolaydır.</span><span class="sxs-lookup"><span data-stu-id="a8471-141">Otherwise, it's easy to add controllers and associated API endpoints to any ASP.NET Core app.</span></span> <span data-ttu-id="a8471-142">Var olan bir uygulamayı ASP.NET MVC 5 veya daha önceki bir sürümden ASP.NET Core MVC 'ye geçiriyorsanız ve en az çaba ile devam etmek istiyorsanız, görünüm tabanlı MVC yaklaşımını kullanın.</span><span class="sxs-lookup"><span data-stu-id="a8471-142">Use the view-based MVC approach if you're migrating an existing application from ASP.NET MVC 5 or earlier to ASP.NET Core MVC and you want to do so with the least amount of effort.</span></span> <span data-ttu-id="a8471-143">İlk geçişi yaptıktan sonra, yeni özellikler için Razor Pages benimsemek ve hatta toptan bir geçiş olarak, bunun mantıklı olup olmadığını değerlendirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-143">Once you've made the initial migration, you can evaluate whether it makes sense to adopt Razor Pages for new features or even as a wholesale migration.</span></span>

<span data-ttu-id="a8471-144">Razor Pages veya MVC görünümlerini kullanarak Web uygulamanızı oluşturmayı tercih etmeksizin, uygulamanız benzer performansa sahip olur ve bağımlılık ekleme, filtreler, model bağlama, doğrulama vb. için destek içerir.</span><span class="sxs-lookup"><span data-stu-id="a8471-144">Whether you choose to build your web app using Razor Pages or MVC views, your app will have similar performance and will include support for dependency injection, filters, model binding, validation, and so on.</span></span>

## <a name="mapping-requests-to-responses"></a><span data-ttu-id="a8471-145">İstekleri yanıtlara eşleme</span><span class="sxs-lookup"><span data-stu-id="a8471-145">Mapping requests to responses</span></span>

<span data-ttu-id="a8471-146">ASP.NET Core uygulamalar gelen istekleri giden yanıtlara eşler.</span><span class="sxs-lookup"><span data-stu-id="a8471-146">At its heart, ASP.NET Core apps map incoming requests to outgoing responses.</span></span> <span data-ttu-id="a8471-147">Düşük düzeyde bu işlem, ara yazılım ile yapılır ve basit ASP.NET Core uygulamalar ve mikro hizmetler yalnızca özel ara yazılım olabilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-147">At a low level, this is done with middleware, and simple ASP.NET Core apps and microservices may be comprised solely of custom middleware.</span></span> <span data-ttu-id="a8471-148">ASP.NET Core MVC kullanırken, _yollar_, _denetleyiciler_ve _Eylemler_açısından biraz daha yüksek bir düzeyde çalışabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-148">When using ASP.NET Core MVC, you can work at a somewhat higher level, thinking in terms of _routes_, _controllers_, and _actions_.</span></span> <span data-ttu-id="a8471-149">Her gelen istek, uygulamanın yönlendirme tablosuyla karşılaştırılır ve eşleşen bir yol bulunursa, isteği işlemek için ilişkili eylem yöntemi (bir denetleyiciye ait) çağırılır.</span><span class="sxs-lookup"><span data-stu-id="a8471-149">Each incoming request is compared with the application's routing table, and if a matching route is found, the associated action method (belonging to a controller) is called to handle the request.</span></span> <span data-ttu-id="a8471-150">Eşleşen yol bulunmazsa, bir hata işleyicisi (Bu durumda NotFound sonucu döndüren) çağırılır.</span><span class="sxs-lookup"><span data-stu-id="a8471-150">If no matching route is found, an error handler (in this case, returning a NotFound result) is called.</span></span>

<span data-ttu-id="a8471-151">ASP.NET Core MVC uygulamaları geleneksel yollar, öznitelik yolları veya her ikisini kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-151">ASP.NET Core MVC apps can use conventional routes, attribute routes, or both.</span></span> <span data-ttu-id="a8471-152">Geleneksel yollar kodda tanımlanmıştır ve aşağıdaki örnekte olduğu gibi sözdizimi kullanılarak yönlendirme _kurallarını_ belirtin:</span><span class="sxs-lookup"><span data-stu-id="a8471-152">Conventional routes are defined in code, specifying routing _conventions_ using syntax like in the example below:</span></span>

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapControllerRoute(name: "default", pattern: "{controller=Home}/{action=Index}/{id?}");
});
```

<span data-ttu-id="a8471-153">Bu örnekte, yönlendirme tablosuna "default" adlı bir yol eklenmiştir.</span><span class="sxs-lookup"><span data-stu-id="a8471-153">In this example, a route named "default" has been added to the routing table.</span></span> <span data-ttu-id="a8471-154">_Denetleyici_, _eylem_ve _kimlik_yer tutucuları olan bir rota şablonu tanımlar. Denetleyici ve eylem yer tutucuları, varsayılan olarak belirtilmiştir (sırasıyla "Home" ve "Dizin") ve kimlik yer tutucusu isteğe bağlıdır (bir "?" öğesinin virtuale tarafından).</span><span class="sxs-lookup"><span data-stu-id="a8471-154">It defines a route template with placeholders for _controller_, _action_, and _id_. The controller and action placeholders have default specified ("Home" and "Index", respectively), and the id placeholder is optional (by virtue of a "?" applied to it).</span></span> <span data-ttu-id="a8471-155">Burada tanımlanan kural, bir isteğin ilk bölümünün denetleyicinin adına, eylemin ikinci bölümüne karşılık gelmesi ve gerekirse üçüncü bir parçanın bir kimlik parametresini temsil etmesi gerektiğini belirtir.</span><span class="sxs-lookup"><span data-stu-id="a8471-155">The convention defined here states that the first part of a request should correspond to the name of the controller, the second part to the action, and then if necessary a third part will represent an id parameter.</span></span> <span data-ttu-id="a8471-156">Geleneksel yollar genellikle uygulama için, başlangıç sınıfındaki configure yönteminde olduğu gibi bir yerde tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="a8471-156">Conventional routes are typically defined in one place for the application, such as in the Configure method in the Startup class.</span></span>

<span data-ttu-id="a8471-157">Öznitelik yolları, genel olarak belirtitense, denetleyicilere ve eylemlere doğrudan uygulanır.</span><span class="sxs-lookup"><span data-stu-id="a8471-157">Attribute routes are applied to controllers and actions directly, rather than specified globally.</span></span> <span data-ttu-id="a8471-158">Bu, belirli bir yönteme baktığınızda çok daha keşfedilebilir hale getirme avantajına sahiptir, ancak yönlendirme bilgilerinin uygulamada tek bir yerde tutulmadığından emin olur.</span><span class="sxs-lookup"><span data-stu-id="a8471-158">This has the advantage of making them much more discoverable when you're looking at a particular method, but does mean that routing information is not kept in one place in the application.</span></span> <span data-ttu-id="a8471-159">Öznitelik rotalarıyla, belirli bir eylem için kolayca birden çok yol belirtebilir ve ayrıca, denetleyiciler ve Eylemler arasındaki yolları birleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-159">With attribute routes, you can easily specify multiple routes for a given action, as well as combine routes between controllers and actions.</span></span> <span data-ttu-id="a8471-160">Örnek:</span><span class="sxs-lookup"><span data-stu-id="a8471-160">For example:</span></span>

```csharp
[Route("Home")]
public class HomeController : Controller
{
    [Route("")] // Combines to define the route template "Home"
    [Route("Index")] // Combines to define route template "Home/Index"
    [Route("/")] // Does not combine, defines the route template ""
    public IActionResult Index() {}
}
```

<span data-ttu-id="a8471-161">Yollar [HttpGet] ve benzer özniteliklerde belirtilebilir ve ayrı [Route] öznitelikleri ekleme gereksinimini ortadan kaldırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-161">Routes can be specified on [HttpGet] and similar attributes, avoiding the need to add separate [Route] attributes.</span></span> <span data-ttu-id="a8471-162">Öznitelik yolları, aşağıda gösterildiği gibi denetleyicinin veya eylem adlarının yinelenmesi gereksinimini azaltmak için belirteçleri de kullanabilir:</span><span class="sxs-lookup"><span data-stu-id="a8471-162">Attribute routes can also use tokens to reduce the need to repeat controller or action names, as shown below:</span></span>

```csharp
[Route("[controller]")]
public class ProductsController : Controller
{
    [Route("")] // Matches 'Products'
    [Route("Index")] // Matches 'Products/Index'
    public IActionResult Index() {}
}
```

<span data-ttu-id="a8471-163">Razor Pages öznitelik yönlendirme kullanmaz.</span><span class="sxs-lookup"><span data-stu-id="a8471-163">Razor Pages doesn't use attribute routing.</span></span> <span data-ttu-id="a8471-164">Bir Razor sayfasına yönelik ek yol şablonu bilgilerini yönergesinin bir parçası olarak belirtebilirsiniz `@page` :</span><span class="sxs-lookup"><span data-stu-id="a8471-164">You can specify additional route template information for a Razor Page as part of its `@page` directive:</span></span>

```csharp
@page "{id:int}"
```

<span data-ttu-id="a8471-165">Önceki örnekte, söz konusu sayfa bir tamsayı parametresiyle bir rota ile eşleşir `id` .</span><span class="sxs-lookup"><span data-stu-id="a8471-165">In the previous example, the page in question would match a route with an integer `id` parameter.</span></span> <span data-ttu-id="a8471-166">Örneğin, kökünde bulunan *Products. cshtml* sayfasında `/Pages` Bu yol olacaktır:</span><span class="sxs-lookup"><span data-stu-id="a8471-166">For example, the *Products.cshtml* page located in the root of `/Pages` would have this route:</span></span>

```csharp
"/Products/123"
```

<span data-ttu-id="a8471-167">Verilen bir istek bir rota ile eşleştirildiği halde, eylem yöntemi çağrılmadan önce ASP.NET Core MVC, istek üzerinde [model bağlama](/aspnet/core/mvc/models/model-binding) ve [model doğrulaması](/aspnet/core/mvc/models/validation) gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="a8471-167">Once a given request has been matched to a route, but before the action method is called, ASP.NET Core MVC will perform [model binding](/aspnet/core/mvc/models/model-binding) and [model validation](/aspnet/core/mvc/models/validation) on the request.</span></span> <span data-ttu-id="a8471-168">Model bağlama, gelen HTTP verilerini çağrılacak eylem metodunun parametreleri olarak belirtilen .NET türlerine dönüştürmekten sorumludur.</span><span class="sxs-lookup"><span data-stu-id="a8471-168">Model binding is responsible for converting incoming HTTP data into the .NET types specified as parameters of the action method to be called.</span></span> <span data-ttu-id="a8471-169">Örneğin, eylem yöntemi bir parametre beklediğinde `int id` , model bağlama isteğin bir parçası olarak sağlanmış bir değerden bu parametreyi sağlamaya çalışacaktır.</span><span class="sxs-lookup"><span data-stu-id="a8471-169">For example, if the action method expects an `int id` parameter, model binding will attempt to provide this parameter from a value provided as part of the request.</span></span> <span data-ttu-id="a8471-170">Bunu yapmak için model bağlama, postalanan bir formdaki değerleri, yolun kendisindeki değerleri ve sorgu dizesi değerlerini arar.</span><span class="sxs-lookup"><span data-stu-id="a8471-170">To do so, model binding looks for values in a posted form, values in the route itself, and query string values.</span></span> <span data-ttu-id="a8471-171">Bir kimlik değerinin bulunduğu varsayıldığında, eylem yöntemine geçirilmeden önce tamsayıya dönüştürülecektir.</span><span class="sxs-lookup"><span data-stu-id="a8471-171">Assuming an id value is found, it will be converted to an integer before being passed into the action method.</span></span>

<span data-ttu-id="a8471-172">Modeli bağladıktan sonra ancak eylem yöntemini çağırmadan önce, model doğrulaması oluşur.</span><span class="sxs-lookup"><span data-stu-id="a8471-172">After binding the model but before calling the action method, model validation occurs.</span></span> <span data-ttu-id="a8471-173">Model doğrulama, model türü üzerinde isteğe bağlı öznitelikleri kullanır ve sağlanan model nesnesinin belirli veri gereksinimlerine uygun olduğundan emin olmanıza yardımcı olabilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-173">Model validation uses optional attributes on the model type, and can help ensure that the provided model object conforms to certain data requirements.</span></span> <span data-ttu-id="a8471-174">Belirli değerler gerekli olarak belirtilebilir veya belirli bir uzunluk veya sayısal aralığa, vb. sınırlı olabilir. Doğrulama öznitelikleri belirtilmişse ancak model gereksinimlerine uygun değilse, ModelState. IsValid özelliği false olur ve başarısız doğrulama kuralları kümesi, isteği yapan istemciye gönderilmek üzere kullanılabilir olacaktır.</span><span class="sxs-lookup"><span data-stu-id="a8471-174">Certain values may be specified as required, or limited to a certain length or numeric range, etc. If validation attributes are specified but the model does not conform to their requirements, the property ModelState.IsValid will be false, and the set of failing validation rules will be available to send to the client making the request.</span></span>

<span data-ttu-id="a8471-175">Model doğrulaması kullanıyorsanız, uygulamanızın geçersiz verilerle bozulmadığından emin olmak için herhangi bir durum değiştirme komutunu gerçekleştirmeden önce modelin geçerli olduğundan emin olun.</span><span class="sxs-lookup"><span data-stu-id="a8471-175">If you're using model validation, you should be sure to always check that the model is valid before performing any state-altering commands, to ensure your app is not corrupted by invalid data.</span></span> <span data-ttu-id="a8471-176">Her eylemde bu için kod ekleme gereksinimini ortadan kaldırmak için bir [filtre](/aspnet/core/mvc/controllers/filters) kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-176">You can use a [filter](/aspnet/core/mvc/controllers/filters) to avoid the need to add code for this in every action.</span></span> <span data-ttu-id="a8471-177">ASP.NET Core MVC filtreleri, istek gruplarını ele almanın bir yolunu sunar, böylece ortak ilkeler ve çapraz kesme sorunları hedeflenen bir temele göre uygulanabilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-177">ASP.NET Core MVC filters offer a way of intercepting groups of requests, so that common policies and cross-cutting concerns can be applied on a targeted basis.</span></span> <span data-ttu-id="a8471-178">Filtreler tek tek eylemlere, tüm denetleyicilere veya bir uygulama için genel olarak uygulanabilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-178">Filters can be applied to individual actions, whole controllers, or globally for an application.</span></span>

<span data-ttu-id="a8471-179">Web API 'Leri için ASP.NET Core MVC [_içerik anlaşmasını_](/aspnet/core/mvc/models/formatting)destekler ve isteklerin nasıl biçimlendirilmesi gerektiğini belirtmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="a8471-179">For web APIs, ASP.NET Core MVC supports [_content negotiation_](/aspnet/core/mvc/models/formatting), allowing requests to specify how responses should be formatted.</span></span> <span data-ttu-id="a8471-180">İstekte belirtilen üstbilgilere göre verileri döndüren eylemler, yanıtı XML, JSON veya desteklenen başka bir biçimde biçimlendirir.</span><span class="sxs-lookup"><span data-stu-id="a8471-180">Based on headers provided in the request, actions returning data will format the response in XML, JSON, or another supported format.</span></span> <span data-ttu-id="a8471-181">Bu özellik, farklı veri biçimi gereksinimlerine sahip birden çok istemci tarafından aynı API 'nin kullanılmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="a8471-181">This feature enables the same API to be used by multiple clients with different data format requirements.</span></span>

<span data-ttu-id="a8471-182">Web API projeleri, `[ApiController]` tek tek denetleyicilere, bir temel denetleyici sınıfına veya tüm derlemeye uygulanabilecek özniteliği kullanmayı göz önünde bulundurmalıdır.</span><span class="sxs-lookup"><span data-stu-id="a8471-182">Web API projects should consider using the `[ApiController]` attribute, which can be applied to individual controllers, to a base controller class, or to the entire assembly.</span></span> <span data-ttu-id="a8471-183">Bu öznitelik otomatik model doğrulama denetimi ekler ve geçersiz bir modele sahip herhangi bir eylem doğrulama hatalarının ayrıntılarına sahip bir BadRequest döndürür.</span><span class="sxs-lookup"><span data-stu-id="a8471-183">This attribute adds automatic model validation checking and any action with an invalid model will return a BadRequest with the details of the validation errors.</span></span> <span data-ttu-id="a8471-184">Özniteliği aynı zamanda geleneksel bir yol kullanmak yerine tüm eylemlerin bir öznitelik yoluna sahip olmasını gerektirir ve hatalara yanıt olarak daha ayrıntılı ProblemDetails bilgileri döndürür.</span><span class="sxs-lookup"><span data-stu-id="a8471-184">The attribute also requires all actions have an attribute route, rather than using a conventional route, and returns more detailed ProblemDetails information in response to errors.</span></span>

### <a name="keeping-controllers-under-control"></a><span data-ttu-id="a8471-185">Denetimleri denetim altında tutma</span><span class="sxs-lookup"><span data-stu-id="a8471-185">Keeping controllers under control</span></span>

<span data-ttu-id="a8471-186">Sayfa tabanlı uygulamalar için Razor Pages denetleyicileri çok büyük bir şekilde tutmaya yönelik harika bir iş elde edin.</span><span class="sxs-lookup"><span data-stu-id="a8471-186">For page-based applications, Razor Pages do a great job of keeping controllers from getting too large.</span></span> <span data-ttu-id="a8471-187">Her bir sayfaya, kendi dosya ve sınıfları yalnızca işleyicisine ayrılmış şekilde verilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-187">Each individual page is given its own files and classes dedicated just to its handler(s).</span></span> <span data-ttu-id="a8471-188">Razor Pages 'nin kullanıma sunulmasından önce, birçok görünüm merkezli uygulamanın birçok farklı eylem ve görünümden sorumlu büyük denetleyici sınıfları vardır.</span><span class="sxs-lookup"><span data-stu-id="a8471-188">Prior to the introduction of Razor Pages, many view-centric applications would have large controller classes responsible for many different actions and views.</span></span> <span data-ttu-id="a8471-189">Bu sınıflar doğal olarak çok sayıda sorumluluklara ve bağımlılıklara sahip olacak şekilde büyürken daha zor hale getirir.</span><span class="sxs-lookup"><span data-stu-id="a8471-189">These classes would naturally grow to have many responsibilities and dependencies, making them harder to maintain.</span></span> <span data-ttu-id="a8471-190">Görünüm tabanlı denetleyicilerinizi çok büyük büyüdüğünü fark ederseniz, Razor Pages kullanmak için yeniden düzenlemeyi veya Mediator gibi bir model tanıtmasını düşünün.</span><span class="sxs-lookup"><span data-stu-id="a8471-190">If you find your view-based controllers are growing too large, consider refactoring them to use Razor Pages, or introducing a pattern like mediator.</span></span>

<span data-ttu-id="a8471-191">Ortalama tasarım stili, aralarında iletişime izin verirken sınıflar arasındaki bağlantı sayısını azaltmak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="a8471-191">The mediator design pattern is used to reduce coupling between classes while allowing communication between them.</span></span> <span data-ttu-id="a8471-192">ASP.NET Core MVC uygulamalarında, bu model genellikle işlem yöntemlerinin çalışması için *işleyiciler* kullanılarak denetleyicileri daha küçük parçalara bölmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="a8471-192">In ASP.NET Core MVC applications, this pattern is frequently employed to break up controllers into smaller pieces by using *handlers* to do the work of action methods.</span></span> <span data-ttu-id="a8471-193">Popüler [mediaTR NuGet paketi](https://www.nuget.org/packages/MediatR/) genellikle bunu gerçekleştirmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="a8471-193">The popular [MediatR NuGet package](https://www.nuget.org/packages/MediatR/) is often used to accomplish this.</span></span> <span data-ttu-id="a8471-194">Genellikle, denetleyicilerin her biri belirli bağımlılıklar gerektirebilecek birçok farklı eylem yöntemi vardır.</span><span class="sxs-lookup"><span data-stu-id="a8471-194">Typically, controllers include many different action methods, each of which may require certain dependencies.</span></span> <span data-ttu-id="a8471-195">Herhangi bir eylem için gereken tüm bağımlılıkların kümesi denetleyicinin oluşturucusuna geçirilmelidir.</span><span class="sxs-lookup"><span data-stu-id="a8471-195">The set of all dependencies required by any action must be passed into the controller's constructor.</span></span> <span data-ttu-id="a8471-196">MediaTR kullanırken, bir denetleyicinin bir örneği olan tek bağımlılığı bir ortam örneğidir.</span><span class="sxs-lookup"><span data-stu-id="a8471-196">When using Mediatr, the only dependency a controller has is on an instance of the mediator.</span></span> <span data-ttu-id="a8471-197">Sonra her eylem, bir işleyici tarafından işlenen bir ileti göndermek için Mediator örneğini kullanır.</span><span class="sxs-lookup"><span data-stu-id="a8471-197">Each action then uses the mediator instance to send a message, which is processed by a handler.</span></span> <span data-ttu-id="a8471-198">İşleyici tek bir eyleme özeldir ve bu nedenle yalnızca bu eylem için gereken bağımlılıklara ihtiyaç duyuyor.</span><span class="sxs-lookup"><span data-stu-id="a8471-198">The handler is specific to a single action and thus only needs the dependencies required by that action.</span></span> <span data-ttu-id="a8471-199">MediatR kullanan bir denetleyiciye örnek burada gösterilmektedir:</span><span class="sxs-lookup"><span data-stu-id="a8471-199">An example of a controller using MediatR is shown here:</span></span>

```csharp
public class OrderController : Controller
{
    private readonly IMediator _mediator;

    public OrderController(IMediator mediator)
    {
        _mediator = mediator;
    }

    [HttpGet]
    public async Task<IActionResult> MyOrders()
    {
        var viewModel = await _mediator.Send(new GetMyOrders(User.Identity.Name));

        return View(viewModel);
    }

    // other actions implemented similarly
}
```

<span data-ttu-id="a8471-200">`MyOrders`Eylemde, `Send` bir iletiye yapılan çağrı `GetMyOrders` Bu sınıf tarafından işlenir:</span><span class="sxs-lookup"><span data-stu-id="a8471-200">In the `MyOrders` action, the call to `Send` a `GetMyOrders` message is handled by this class:</span></span>

```csharp
public class GetMyOrdersHandler : IRequestHandler<GetMyOrders, IEnumerable<OrderViewModel>>
{
    private readonly IOrderRepository _orderRepository;

    public GetMyOrdersHandler(IOrderRepository orderRepository)
    {
        _orderRepository = orderRepository;
    }

    public async Task<IEnumerable<OrderViewModel>> Handle(GetMyOrders request, CancellationToken cancellationToken)
    {
        var specification = new CustomerOrdersWithItemsSpecification(request.UserName);
        var orders = await _orderRepository.ListAsync(specification);

        return orders.Select(o => new OrderViewModel
        {
            OrderDate = o.OrderDate,
            OrderItems = o.OrderItems?.Select(oi => new OrderItemViewModel()
            {
                PictureUrl = oi.ItemOrdered.PictureUri,
                ProductId = oi.ItemOrdered.CatalogItemId,
                ProductName = oi.ItemOrdered.ProductName,
                UnitPrice = oi.UnitPrice,
                Units = oi.Units
            }).ToList(),
            OrderNumber = o.Id,
            ShippingAddress = o.ShipToAddress,
            Total = o.Total()
        });
    }
}
```

<span data-ttu-id="a8471-201">Bu yaklaşımın nihai sonucu, denetleyicilerin çok daha küçük olmasını ve öncelikle yönlendirme ve model bağlamasıyla odaklanmasını, ancak belirli bir uç nokta için gereken belirli görevlerden bağımsız işleyicilerin sorumlu olmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="a8471-201">The end result of this approach is for controllers to be much smaller and focused primarily on routing and model binding, while individual handlers are responsible for the specific tasks needed by a given endpoint.</span></span> <span data-ttu-id="a8471-202">Bu yaklaşım ayrıca, API Razor Pages denetleyicilerini, görüntüleme tabanlı denetleyicilere getirmelerini sağlayan [Apiendpoints NuGet paketi](https://www.nuget.org/packages/Ardalis.ApiEndpoints/)kullanılarak MediatR olmadan elde edilebilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-202">This approach can also be achieved without MediatR by using the [ApiEndpoints NuGet package](https://www.nuget.org/packages/Ardalis.ApiEndpoints/), which attempts to bring to API controllers the same benefits Razor Pages brings to view-based controllers.</span></span>

> ### <a name="references--mapping-requests-to-responses"></a><span data-ttu-id="a8471-203">Başvurular – Istekleri yanıtlara eşleme</span><span class="sxs-lookup"><span data-stu-id="a8471-203">References – Mapping Requests to Responses</span></span>
>
> - <span data-ttu-id="a8471-204">**Denetleyici eylemlerine yönlendirme**
 > <https://docs.microsoft.com/aspnet/core/mvc/controllers/routing></span><span class="sxs-lookup"><span data-stu-id="a8471-204">**Routing to Controller Actions**
<https://docs.microsoft.com/aspnet/core/mvc/controllers/routing></span></span>
> - <span data-ttu-id="a8471-205">**Model bağlama**
 > <https://docs.microsoft.com/aspnet/core/mvc/models/model-binding></span><span class="sxs-lookup"><span data-stu-id="a8471-205">**Model Binding**
<https://docs.microsoft.com/aspnet/core/mvc/models/model-binding></span></span>
> - <span data-ttu-id="a8471-206">**Model doğrulama**
 > <https://docs.microsoft.com/aspnet/core/mvc/models/validation></span><span class="sxs-lookup"><span data-stu-id="a8471-206">**Model Validation**
<https://docs.microsoft.com/aspnet/core/mvc/models/validation></span></span>
> - <span data-ttu-id="a8471-207">**Yorsa**
 > <https://docs.microsoft.com/aspnet/core/mvc/controllers/filters></span><span class="sxs-lookup"><span data-stu-id="a8471-207">**Filters**
<https://docs.microsoft.com/aspnet/core/mvc/controllers/filters></span></span>
> - <span data-ttu-id="a8471-208">**ApiController özniteliği**
 > <https://docs.microsoft.com/aspnet/core/web-api/></span><span class="sxs-lookup"><span data-stu-id="a8471-208">**ApiController Attribute**
<https://docs.microsoft.com/aspnet/core/web-api/></span></span>

## <a name="working-with-dependencies"></a><span data-ttu-id="a8471-209">Bağımlılıklarla çalışma</span><span class="sxs-lookup"><span data-stu-id="a8471-209">Working with dependencies</span></span>

<span data-ttu-id="a8471-210">ASP.NET Core, için yerleşik desteğe sahiptir ve dahili olarak [bağımlılık ekleme](/aspnet/core/fundamentals/dependency-injection)olarak bilinen bir tekniğin kullanımını sağlar.</span><span class="sxs-lookup"><span data-stu-id="a8471-210">ASP.NET Core has built-in support for and internally makes use of a technique known as [dependency injection](/aspnet/core/fundamentals/dependency-injection).</span></span> <span data-ttu-id="a8471-211">Bağımlılık ekleme, bir uygulamanın farklı parçaları arasında gevşek bir şekilde bağlantısı sağlayan bir tekniktir.</span><span class="sxs-lookup"><span data-stu-id="a8471-211">Dependency injection is a technique that enables loose coupling between different parts of an application.</span></span> <span data-ttu-id="a8471-212">GEVME bağlantısı, uygulamanın parçalarını yalıtmak daha kolay olduğundan, test veya değişiklik yapılmasına olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="a8471-212">Looser coupling is desirable because it makes it easier to isolate parts of the application, allowing for testing or replacement.</span></span> <span data-ttu-id="a8471-213">Ayrıca, uygulamanın bir bölümündeki değişikliğin uygulamada başka bir yerde beklenmedik bir etkiye sahip olacağını daha da zorlaştırır.</span><span class="sxs-lookup"><span data-stu-id="a8471-213">It also makes it less likely that a change in one part of the application will have an unexpected impact somewhere else in the application.</span></span> <span data-ttu-id="a8471-214">Bağımlılık ekleme, bağımlılık Inversion ilkesine dayanır ve genellikle açık/kapalı ilkesini elde etmek için anahtardır.</span><span class="sxs-lookup"><span data-stu-id="a8471-214">Dependency injection is based on the dependency inversion principle, and is often key to achieving the open/closed principle.</span></span> <span data-ttu-id="a8471-215">Uygulamanızın bağımlılıklarıyla nasıl çalıştığını değerlendirirken, [statik Cling](https://deviq.com/static-cling/) Code kokusu ' na göz atın ve aphorısm "[Yeni bir tutkalla" olduğunu](https://ardalis.com/new-is-glue)unutmayın.</span><span class="sxs-lookup"><span data-stu-id="a8471-215">When evaluating how your application works with its dependencies, beware of the [static cling](https://deviq.com/static-cling/) code smell, and remember the aphorism "[new is glue](https://ardalis.com/new-is-glue)."</span></span>

<span data-ttu-id="a8471-216">Sınıflarınızda statik yöntemlere çağrı yapıldığında veya altyapıda yan etkileri veya bağımlılıklar olan statik özelliklere erişmek için statik Cling oluşur.</span><span class="sxs-lookup"><span data-stu-id="a8471-216">Static cling occurs when your classes make calls to static methods, or access static properties, which have side effects or dependencies on infrastructure.</span></span> <span data-ttu-id="a8471-217">Örneğin, bir statik yöntemi çağıran bir metoda sahipseniz, bu, bir veritabanına yazıyorsa, yönteminiz veritabanına sıkı bir şekilde bağlanmış olur.</span><span class="sxs-lookup"><span data-stu-id="a8471-217">For example, if you have a method that calls a static method, which in turn writes to a database, your method is tightly coupled to the database.</span></span> <span data-ttu-id="a8471-218">Bu veritabanı çağrısını kesen her şey, yönteminizi bozacaktır.</span><span class="sxs-lookup"><span data-stu-id="a8471-218">Anything that breaks that database call will break your method.</span></span> <span data-ttu-id="a8471-219">Bu tür testler, statik çağrıları sahte bir şekilde ticari model oluşturma gerektirdiğinden veya yalnızca bir test veritabanıyla test edilemediğinden, bu tür yöntemlerin test edilmesi oldukça zordur.</span><span class="sxs-lookup"><span data-stu-id="a8471-219">Testing such methods is notoriously difficult, since such tests either require commercial mocking libraries to mock the static calls, or can only be tested with a test database in place.</span></span> <span data-ttu-id="a8471-220">Altyapı üzerinde hiçbir bağımlılığı olmayan statik çağrılar, özellikle tamamen durum bilgisiz olanlar, çağrı yapmak için uygundur ve bir ya da pakararlılığı üzerinde hiçbir etkisi yoktur (Bu kodun ötesinde, bu kod, statik çağrının kendisindedir).</span><span class="sxs-lookup"><span data-stu-id="a8471-220">Static calls that don't have any dependence on infrastructure, especially those that are completely stateless, are fine to call and have no impact on coupling or testability (beyond coupling code to the static call itself).</span></span>

<span data-ttu-id="a8471-221">Birçok geliştirici statik Cling ve küresel durum risklerini anlamakta, ancak doğrudan örnek oluşturma yoluyla kendi kodunu belirli uygulamalara sıkı bir şekilde ister.</span><span class="sxs-lookup"><span data-stu-id="a8471-221">Many developers understand the risks of static cling and global state, but will still tightly couple their code to specific implementations through direct instantiation.</span></span> <span data-ttu-id="a8471-222">"Yeni bir tutkalla", anahtar sözcüğünün kullanımı için genel bir Condemnation değil, bu kuponun bir anımsatıcı olması anlamına gelir `new` .</span><span class="sxs-lookup"><span data-stu-id="a8471-222">"New is glue" is meant to be a reminder of this coupling, and not a general condemnation of the use of the `new` keyword.</span></span> <span data-ttu-id="a8471-223">Statik yöntem çağrılarında olduğu gibi, dış bağımlılıkları olmayan türlerin yeni örnekleri genellikle uygulama ayrıntılarına sıkı bir şekilde kod içermez veya sınamayı daha zor hale getirir.</span><span class="sxs-lookup"><span data-stu-id="a8471-223">Just as with static method calls, new instances of types that have no external dependencies typically do not tightly couple code to implementation details or make testing more difficult.</span></span> <span data-ttu-id="a8471-224">Ancak, bir sınıfın her örneği oluşturulduğunda, bu belirli bir konumdaki belirli bir örneği sabit koda veya bu örneği bir bağımlılık olarak istemek için daha iyi bir tasarım olup olmadığını göz önünde bulundurmanız gereken kısa bir süre ayırın.</span><span class="sxs-lookup"><span data-stu-id="a8471-224">But each time a class is instantiated, take just a brief moment to consider whether it makes sense to hard-code that specific instance in that particular location, or if it would be a better design to request that instance as a dependency.</span></span>

### <a name="declare-your-dependencies"></a><span data-ttu-id="a8471-225">Bağımlılıklarınızı bildirin</span><span class="sxs-lookup"><span data-stu-id="a8471-225">Declare your dependencies</span></span>

<span data-ttu-id="a8471-226">ASP.NET Core, yöntem ve sınıfların bağımlılıklarını bildirmek ve bunları bağımsız değişken olarak istiyor.</span><span class="sxs-lookup"><span data-stu-id="a8471-226">ASP.NET Core is built around having methods and classes declare their dependencies, requesting them as arguments.</span></span> <span data-ttu-id="a8471-227">ASP.NET uygulamaları tipik olarak, bir başlangıç sınıfında ayarlanır ve bu, kendisini birçok noktaya bağımlılık ekleme işlemini destekleyecek şekilde yapılandırılmıştır.</span><span class="sxs-lookup"><span data-stu-id="a8471-227">ASP.NET applications are typically set up in a Startup class, which itself is configured to support dependency injection at several points.</span></span> <span data-ttu-id="a8471-228">Başlangıç sınıfınızın bir Oluşturucusu varsa, bu, Oluşturucu aracılığıyla bağımlılık isteğinde bulunabilir, örneğin:</span><span class="sxs-lookup"><span data-stu-id="a8471-228">If your Startup class has a constructor, it can request dependencies through the constructor, like so:</span></span>

```csharp
public class Startup
{
    public Startup(IHostingEnvironment env)
    {
        var builder = new ConfigurationBuilder()
            .SetBasePath(env.ContentRootPath)
            .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)
            .AddJsonFile($"appsettings.{env.EnvironmentName}.json", optional: true);
    }
}
```

<span data-ttu-id="a8471-229">Başlangıç sınıfı, bunun için açık tür gereksinimleri olmaması açısından ilginç değildir.</span><span class="sxs-lookup"><span data-stu-id="a8471-229">The Startup class is interesting in that there are no explicit type requirements for it.</span></span> <span data-ttu-id="a8471-230">Özel bir başlangıç temel sınıfından kalıtımla almaz ve belirli bir arabirimi uygulamaz.</span><span class="sxs-lookup"><span data-stu-id="a8471-230">It doesn't inherit from a special Startup base class, nor does it implement any particular interface.</span></span> <span data-ttu-id="a8471-231">Oluşturucuya bir Oluşturucu verebilir veya Not alabilir ve oluşturucuda istediğiniz sayıda parametre belirtebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-231">You can give it a constructor, or not, and you can specify as many parameters on the constructor as you want.</span></span> <span data-ttu-id="a8471-232">Uygulamanız için yapılandırdığınız Web ana bilgisayarı başlatıldığında, kullanmasını söylemekte olduğunuz başlangıç sınıfını çağırır ve başlangıç sınıfının gerektirdiği bağımlılıkları doldurmak için bağımlılık ekleme 'yi kullanır.</span><span class="sxs-lookup"><span data-stu-id="a8471-232">When the web host you've configured for your application starts, it will call the Startup class you've told it to use, and will use dependency injection to populate any dependencies the Startup class requires.</span></span> <span data-ttu-id="a8471-233">Kuşkusuz, ASP.NET Core tarafından kullanılan hizmetler kapsayıcısında yapılandırılmamış parametreler istemeniz halinde bir özel durum alırsınız, ancak kapsayıcının ilgili olduğu bağımlılıkları tercih ettiğiniz sürece istediğiniz herhangi bir şey isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-233">Of course, if you request parameters that aren't configured in the services container used by ASP.NET Core, you'll get an exception, but as long as you stick to dependencies the container knows about, you can request anything you want.</span></span>

<span data-ttu-id="a8471-234">Bağımlılık ekleme, başlangıç örneğini oluştururken ASP.NET Core uygulamalarınıza doğrudan baştan oluşturulmuştur.</span><span class="sxs-lookup"><span data-stu-id="a8471-234">Dependency injection is built into your ASP.NET Core apps right from the start, when you create the Startup instance.</span></span> <span data-ttu-id="a8471-235">Başlangıç sınıfı için bu yok durmaz.</span><span class="sxs-lookup"><span data-stu-id="a8471-235">It doesn't stop there for the Startup class.</span></span> <span data-ttu-id="a8471-236">Yapılandırma yönteminde de bağımlılıklar isteyebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="a8471-236">You can also request dependencies in the Configure method:</span></span>

```csharp
public void Configure(IApplicationBuilder app,
    IHostingEnvironment env,
    ILoggerFactory loggerFactory)
{

}
```

<span data-ttu-id="a8471-237">ConfigureServices yöntemi bu davranışın istisnadır; yalnızca ıvicecollection türünde tek bir parametre almalıdır.</span><span class="sxs-lookup"><span data-stu-id="a8471-237">The ConfigureServices method is the exception to this behavior; it must take just one parameter of type IServiceCollection.</span></span> <span data-ttu-id="a8471-238">Son olarak, hizmet kapsayıcısına nesne eklemekten sorumlu olduğu ve diğer tüm yapılandırılmış hizmetlere ıvicecollection parametresi aracılığıyla erişimi olduğundan, bağımlılık ekleme işlemini desteklemesi gerçekten gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="a8471-238">It doesn't really need to support dependency injection, since on the one hand it is responsible for adding objects to the services container, and on the other it has access to all currently configured services via the IServiceCollection parameter.</span></span> <span data-ttu-id="a8471-239">Bu nedenle, gerekli hizmeti bir parametre olarak isteyerek veya ConfigureServices içindeki ıvicecollection ile çalışarak, başlangıç sınıfının her bölümünde ASP.NET Core Hizmetleri koleksiyonunda tanımlanan bağımlılıklarla çalışabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-239">Thus, you can work with dependencies defined in the ASP.NET Core services collection in every part of the Startup class, either by requesting the needed service as a parameter or by working with the IServiceCollection in ConfigureServices.</span></span>

> [!NOTE]
> <span data-ttu-id="a8471-240">Başlangıç sınıfınız için bazı hizmetlerin kullanılabilir olduğundan emin olmanız gerekiyorsa, bunları CreateDefaultBuilder çağrısının içindeki bir ıwebhostbuilder ve ConfigureServices yöntemi ile yapılandırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-240">If you need to ensure certain services are available to your Startup class, you can configure them using an IWebHostBuilder and its ConfigureServices method inside the CreateDefaultBuilder call.</span></span>

<span data-ttu-id="a8471-241">Başlangıç sınıfı, ASP.NET Core uygulamanızın diğer bölümlerini denetleyicilerden ara yazılıma kendi hizmetlerinize yönelik olarak nasıl yapılandıracağınıza yönelik bir modeldir.</span><span class="sxs-lookup"><span data-stu-id="a8471-241">The Startup class is a model for how you should structure other parts of your ASP.NET Core application, from Controllers to Middleware to Filters to your own Services.</span></span> <span data-ttu-id="a8471-242">Her durumda, doğrudan oluşturmak yerine bağımlılıklarınızı isteyerek ve uygulamanızın tamamında bağımlılık ekleme özelliğinden yararlanarak [Açık bağımlılıklar ilkesini](https://deviq.com/explicit-dependencies-principle/)izlemelisiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-242">In each case, you should follow the [Explicit Dependencies Principle](https://deviq.com/explicit-dependencies-principle/), requesting your dependencies rather than directly creating them, and leveraging dependency injection throughout your application.</span></span> <span data-ttu-id="a8471-243">Uygulamaları, özellikle de altyapıyla çalışan veya yan etkileri olan uygulamaları, doğrudan hizmet ve nesneleri nasıl ve nasıl örneklendirileceğine dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="a8471-243">Be careful of where and how you directly instantiate implementations, especially services and objects that work with infrastructure or have side effects.</span></span> <span data-ttu-id="a8471-244">Uygulama çekirdekde tanımlanan soyutlamalar ile çalışmayı tercih edin ve belirli uygulama türlerine yönelik başvuruları kodlamaları için bağımsız değişken olarak geçirilmiş olarak geçin.</span><span class="sxs-lookup"><span data-stu-id="a8471-244">Prefer working with abstractions defined in your application core and passed in as arguments to hardcoding references to specific implementation types.</span></span>

## <a name="structuring-the-application"></a><span data-ttu-id="a8471-245">Uygulamayı yapılandırma</span><span class="sxs-lookup"><span data-stu-id="a8471-245">Structuring the application</span></span>

<span data-ttu-id="a8471-246">Tek parçalı uygulamalar genellikle tek bir giriş noktasına sahiptir.</span><span class="sxs-lookup"><span data-stu-id="a8471-246">Monolithic applications typically have a single entry point.</span></span> <span data-ttu-id="a8471-247">ASP.NET Core Web uygulaması söz konusu olduğunda, giriş noktası ASP.NET Core Web projesi olur.</span><span class="sxs-lookup"><span data-stu-id="a8471-247">In the case of an ASP.NET Core web application, the entry point will be the ASP.NET Core web project.</span></span> <span data-ttu-id="a8471-248">Ancak bu, çözümün yalnızca tek bir projeden oluşması anlamına gelmez.</span><span class="sxs-lookup"><span data-stu-id="a8471-248">However, that doesn't mean the solution should consist of just a single project.</span></span> <span data-ttu-id="a8471-249">Kaygıları ayırmayı izlemek için uygulamayı farklı katmanlara bölmek yararlı olur.</span><span class="sxs-lookup"><span data-stu-id="a8471-249">It's useful to break up the application into different layers in order to follow separation of concerns.</span></span> <span data-ttu-id="a8471-250">Katmanlara bölüntikten sonra, daha iyi kapsülleme elde etmenize yardımcı olacak şekilde klasörlerin ötesine geçme yararlı olur.</span><span class="sxs-lookup"><span data-stu-id="a8471-250">Once broken up into layers, it's helpful to go beyond folders to separate projects, which can help achieve better encapsulation.</span></span> <span data-ttu-id="a8471-251">ASP.NET Core bir uygulamayla bu hedeflere ulaşmak için en iyi yaklaşım, Bölüm 5 ' te ele alınan temiz mimarinin bir çeşitlemesi.</span><span class="sxs-lookup"><span data-stu-id="a8471-251">The best approach to achieve these goals with an ASP.NET Core application is a variation of the Clean Architecture discussed in chapter 5.</span></span> <span data-ttu-id="a8471-252">Bu yaklaşımda, uygulamanın çözümü UI, altyapı ve ApplicationCore için ayrı kitaplıklar oluşturur.</span><span class="sxs-lookup"><span data-stu-id="a8471-252">Following this approach, the application's solution will comprise separate libraries for the UI, Infrastructure, and ApplicationCore.</span></span>

<span data-ttu-id="a8471-253">Bu projelere ek olarak, ayrı test projeleri de dahildir (test, Bölüm 9 ' da ele alınmıştır).</span><span class="sxs-lookup"><span data-stu-id="a8471-253">In addition to these projects, separate test projects are included as well (Testing is discussed in Chapter 9).</span></span>

<span data-ttu-id="a8471-254">Uygulamanın nesne modeli ve arabirimleri ApplicationCore projesine yerleştirilmelidir.</span><span class="sxs-lookup"><span data-stu-id="a8471-254">The application's object model and interfaces should be placed in the ApplicationCore project.</span></span> <span data-ttu-id="a8471-255">Bu proje mümkün olduğunca az bağımlılıklara sahip olacak ve çözümdeki diğer projelere başvuracaktır.</span><span class="sxs-lookup"><span data-stu-id="a8471-255">This project will have as few dependencies as possible, and the other projects in the solution will reference it.</span></span> <span data-ttu-id="a8471-256">Kalıcı olması gereken iş varlıkları, altyapıya doğrudan bağlı olmayan hizmetler olduğundan, ApplicationCore projesinde tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="a8471-256">Business entities that need to be persisted are defined in the ApplicationCore project, as are services that do not directly depend on infrastructure.</span></span>

<span data-ttu-id="a8471-257">Kalıcılık gerçekleştirilme veya bildirimlerin bir kullanıcıya nasıl gönderilelebileceği gibi uygulama ayrıntıları altyapı projesinde tutulur.</span><span class="sxs-lookup"><span data-stu-id="a8471-257">Implementation details, such as how persistence is performed or how notifications might be sent to a user, are kept in the Infrastructure project.</span></span> <span data-ttu-id="a8471-258">Bu proje, Entity Framework Core gibi uygulamaya özgü paketlere başvuracaktır, ancak proje dışındaki bu uygulamalarla ilgili ayrıntıları göstermemelidir.</span><span class="sxs-lookup"><span data-stu-id="a8471-258">This project will reference implementation-specific packages such as Entity Framework Core, but should not expose details about these implementations outside of the project.</span></span> <span data-ttu-id="a8471-259">Altyapı Hizmetleri ve depoları, ApplicationCore projesinde tanımlanan arabirimleri uygulamalıdır ve ApplicationCore 'da tanımlanan varlıkları alma ve depolama konusunda Kalıcılık uygulamalarıdır.</span><span class="sxs-lookup"><span data-stu-id="a8471-259">Infrastructure services and repositories should implement interfaces that are defined in the ApplicationCore project, and its persistence implementations are responsible for retrieving and storing entities defined in ApplicationCore.</span></span>

<span data-ttu-id="a8471-260">ASP.NET Core UI projesi, herhangi bir kullanıcı arabirimi düzeyi kaygısından sorumludur, ancak iş mantığını veya altyapı ayrıntılarını içermemelidir.</span><span class="sxs-lookup"><span data-stu-id="a8471-260">The ASP.NET Core UI project is responsible for any UI level concerns, but should not include business logic or infrastructure details.</span></span> <span data-ttu-id="a8471-261">Aslında, ideal olarak, iki proje arasında hiçbir bağımlılığın yanlışlıkla tanıtılmamasını sağlamaya yardımcı olacak şekilde altyapı projesine bir bağımlılığı olmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="a8471-261">In fact, ideally it shouldn't even have a dependency on the Infrastructure project, which will help ensure no dependency between the two projects is introduced accidentally.</span></span> <span data-ttu-id="a8471-262">Bu, her bir projedeki modül sınıflarında DI kuralları tanımlamanızı sağlayan Autofac gibi bir üçüncü taraf DI kapsayıcısı kullanılarak elde edilebilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-262">This can be achieved using a third-party DI container like Autofac, which allows you to define DI rules in Module classes in each project.</span></span>

<span data-ttu-id="a8471-263">Uygulamanın uygulama ayrıntılarından ayrılmasıyla ilgili başka bir yaklaşım da uygulamanın mikro hizmetleri çağırması, belki de ayrı bir Docker kapsayıcısında dağıtılması.</span><span class="sxs-lookup"><span data-stu-id="a8471-263">Another approach to decoupling the application from implementation details is to have the application call microservices, perhaps deployed in individual Docker containers.</span></span> <span data-ttu-id="a8471-264">Bu, zorluklardan daha büyük ayrım sağlar ve iki proje arasında bir tan kullanmaktan farklı, ancak ek karmaşıklığa sahiptir.</span><span class="sxs-lookup"><span data-stu-id="a8471-264">This provides even greater separation of concerns and decoupling than leveraging DI between two projects, but has additional complexity.</span></span>

### <a name="feature-organization"></a><span data-ttu-id="a8471-265">Özellik organizasyonu</span><span class="sxs-lookup"><span data-stu-id="a8471-265">Feature organization</span></span>

<span data-ttu-id="a8471-266">Varsayılan olarak, ASP.NET Core uygulamalar, klasör yapısını denetleyicileri ve görünümleri ve sık sık görünüm modellerini içerecek şekilde düzenler.</span><span class="sxs-lookup"><span data-stu-id="a8471-266">By default, ASP.NET Core applications organize their folder structure to include Controllers and Views, and frequently ViewModels.</span></span> <span data-ttu-id="a8471-267">Bu sunucu tarafı yapıları desteklemeye yönelik istemci tarafı kodu genellikle Wwwroot klasöründe ayrı olarak depolanır.</span><span class="sxs-lookup"><span data-stu-id="a8471-267">Client-side code to support these server-side structures is typically stored separately in the wwwroot folder.</span></span> <span data-ttu-id="a8471-268">Ancak, belirli bir özellik üzerinde çalışmak bu klasörler arasında atlama gerektirdiğinden, büyük uygulamalar bu kuruluşla ilgili sorunlarla karşılaşabilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-268">However, large applications may encounter problems with this organization, since working on any given feature often requires jumping between these folders.</span></span> <span data-ttu-id="a8471-269">Bu, her bir klasördeki dosya ve alt klasörlerin sayısı arttıkça daha fazla ve çok daha zor bir işlem elde Çözüm Gezgini.</span><span class="sxs-lookup"><span data-stu-id="a8471-269">This gets more and more difficult as the number of files and subfolders in each folder grows, resulting in a great deal of scrolling through Solution Explorer.</span></span> <span data-ttu-id="a8471-270">Bu soruna yönelik bir çözüm, uygulama kodunu dosya türüne göre değil, _özelliğe_ göre düzenleyeceğiniz bir çözümdür.</span><span class="sxs-lookup"><span data-stu-id="a8471-270">One solution to this problem is to organize application code by _feature_ instead of by file type.</span></span> <span data-ttu-id="a8471-271">Bu kuruluş stiline genellikle özellik klasörleri veya [özellik dilimleri](https://docs.microsoft.com/archive/msdn-magazine/2016/september/asp-net-core-feature-slices-for-asp-net-core-mvc) adı verilir (Ayrıca bkz: [Dikey dilimler](https://deviq.com/vertical-slices/)).</span><span class="sxs-lookup"><span data-stu-id="a8471-271">This organizational style is typically referred to as feature folders or [feature slices](https://docs.microsoft.com/archive/msdn-magazine/2016/september/asp-net-core-feature-slices-for-asp-net-core-mvc) (see also: [Vertical Slices](https://deviq.com/vertical-slices/)).</span></span>

<span data-ttu-id="a8471-272">ASP.NET Core MVC bu amaca yönelik alanı destekler.</span><span class="sxs-lookup"><span data-stu-id="a8471-272">ASP.NET Core MVC supports Areas for this purpose.</span></span> <span data-ttu-id="a8471-273">Alanları kullanarak her bir alan klasöründeki ayrı denetleyici ve görünüm klasörü (Ayrıca ilişkili modeller) oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-273">Using areas, you can create separate sets of Controllers and Views folders (as well as any associated models) in each Area folder.</span></span> <span data-ttu-id="a8471-274">Şekil 7-1, alan kullanarak örnek bir klasör yapısını gösterir.</span><span class="sxs-lookup"><span data-stu-id="a8471-274">Figure 7-1 shows an example folder structure, using Areas.</span></span>

![Örnek alan organizasyonu](./media/image7-1.png)

<span data-ttu-id="a8471-276">**Şekil 7-1**.</span><span class="sxs-lookup"><span data-stu-id="a8471-276">**Figure 7-1**.</span></span> <span data-ttu-id="a8471-277">Örnek alan organizasyonu</span><span class="sxs-lookup"><span data-stu-id="a8471-277">Sample Area Organization</span></span>

<span data-ttu-id="a8471-278">Alanları kullanırken, denetleyicilerinizi ait oldukları alanın adıyla süslemek için öznitelikleri kullanmanız gerekir:</span><span class="sxs-lookup"><span data-stu-id="a8471-278">When using Areas, you must use attributes to decorate your controllers with the name of the area to which they belong:</span></span>

```csharp
[Area("Catalog")]
public class HomeController
{}
```

<span data-ttu-id="a8471-279">Ayrıca, rotalarınız için alan desteği eklemeniz gerekir:</span><span class="sxs-lookup"><span data-stu-id="a8471-279">You also need to add area support to your routes:</span></span>

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapControllerRoute(name: "areaRoute", pattern: "{area:exists}/{controller=Home}/{action=Index}/{id?}");
    endpoints.MapControllerRoute(name: "default", pattern: "{controller=Home}/{action=Index}/{id?}");
});
```

<span data-ttu-id="a8471-280">Alanlara yönelik yerleşik desteğe ek olarak, kendi klasör yapınızı ve özniteliklerin ve özel yolların yerine kurallarınızı de kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-280">In addition to the built-in support for Areas, you can also use your own folder structure, and conventions in place of attributes and custom routes.</span></span> <span data-ttu-id="a8471-281">Böylece görünümler, denetleyiciler, vb. için ayrı klasörler içermeyen Özellik klasörlerine sahip olabilirsiniz, böylece hiyerarşi düzlebilir ve her bir özellik için tüm ilgili dosyaları tek bir yerde görmeyi kolaylaştırın.</span><span class="sxs-lookup"><span data-stu-id="a8471-281">This would allow you to have feature folders that didn't include separate folders for Views, Controllers, etc., keeping the hierarchy flatter and making it easier to see all related files in a single place for each feature.</span></span>

<span data-ttu-id="a8471-282">ASP.NET Core davranışını denetlemek için yerleşik kural türlerini kullanır.</span><span class="sxs-lookup"><span data-stu-id="a8471-282">ASP.NET Core uses built-in convention types to control its behavior.</span></span> <span data-ttu-id="a8471-283">Bu kurallara göre değişiklik yapabilir veya değiştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-283">You can modify or replace these conventions.</span></span> <span data-ttu-id="a8471-284">Örneğin, belirli bir denetleyicinin özellik adını ad alanına göre otomatik olarak alacak bir kural oluşturabilirsiniz (genellikle denetleyicinin bulunduğu klasörle ilişkili olur):</span><span class="sxs-lookup"><span data-stu-id="a8471-284">For example, you can create a convention that will automatically get the feature name for a given controller based on its namespace (which typically correlates to the folder in which the controller is located):</span></span>

```csharp
public class FeatureConvention : IControllerModelConvention
{
    public void Apply(ControllerModel controller)
    {
        controller.Properties.Add("feature",
        GetFeatureName(controller.ControllerType));
    }

    private string GetFeatureName(TypeInfo controllerType)
    {
        string[] tokens = controllerType.FullName.Split('.');
        if (!tokens.Any(t => t == "Features")) return "";
        string featureName = tokens
        .SkipWhile(t => !t.Equals("features",
        StringComparison.CurrentCultureIgnoreCase))
        .Skip(1)
        .Take(1)
        .FirstOrDefault();
        return featureName;
    }
}
```

<span data-ttu-id="a8471-285">Bundan sonra, ConfigureServices 'daki uygulamanıza MVC desteği eklediğinizde bu kuralı bir seçenek olarak belirtirsiniz:</span><span class="sxs-lookup"><span data-stu-id="a8471-285">You then specify this convention as an option when you add support for MVC to your application in ConfigureServices:</span></span>

```csharp
services.AddMvc(o => o.Conventions.Add(new FeatureConvention()));
```

<span data-ttu-id="a8471-286">ASP.NET Core MVC, görünümleri bulmak için de bir kural kullanır.</span><span class="sxs-lookup"><span data-stu-id="a8471-286">ASP.NET Core MVC also uses a convention to locate views.</span></span> <span data-ttu-id="a8471-287">Görünümlerin Özellik klasörlerinizde bulunması için (yukarıdaki FeatureConvention tarafından sunulan özellik adı kullanılarak) özel bir kural ile geçersiz kılabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-287">You can override it with a custom convention so that views will be located in your feature folders (using the feature name provided by the FeatureConvention, above).</span></span> <span data-ttu-id="a8471-288">Bu yaklaşım hakkında daha fazla bilgi alabilir ve MSDN Magazine makalesinden çalışan bir örnek indirebilirsiniz [ASP.NET Core MVC Için özellik dilimleri](https://docs.microsoft.com/archive/msdn-magazine/2016/september/asp-net-core-feature-slices-for-asp-net-core-mvc).</span><span class="sxs-lookup"><span data-stu-id="a8471-288">You can learn more about this approach and download a working sample from the MSDN Magazine article, [Feature Slices for ASP.NET Core MVC](https://docs.microsoft.com/archive/msdn-magazine/2016/september/asp-net-core-feature-slices-for-asp-net-core-mvc).</span></span>

### <a name="apis-and-no-locblazor-applications"></a><span data-ttu-id="a8471-289">API 'Ler ve Blazor uygulamalar</span><span class="sxs-lookup"><span data-stu-id="a8471-289">APIs and Blazor applications</span></span>

<span data-ttu-id="a8471-290">Uygulamanız güvenli hale getirilmesi gereken bir dizi Web API 'si içeriyorsa, bu, görünüm veya Razor Pages uygulamanızdan ayrı bir proje olarak yapılandırılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="a8471-290">If your application includes a set of web APIs which must be secured, these should ideally be configured as a separate project from your View or Razor Pages application.</span></span> <span data-ttu-id="a8471-291">Sunucu tarafı Web uygulamanızdan API 'Lerin, özellikle ortak API 'lerin ayrılması birçok avantaj sağlar.</span><span class="sxs-lookup"><span data-stu-id="a8471-291">Separating APIs, especially public APIs, from your server-side web application has a number of benefits.</span></span> <span data-ttu-id="a8471-292">Bu uygulamalar genellikle benzersiz dağıtım ve yükleme özelliklerine sahip olur.</span><span class="sxs-lookup"><span data-stu-id="a8471-292">These applications often will have unique deployment and load characteristics.</span></span> <span data-ttu-id="a8471-293">Ayrıca, tanımlama bilgisi tabanlı kimlik doğrulaması ve API 'Lerin en büyük olasılıkla belirteç tabanlı kimlik doğrulaması kullanan API 'lerden yararlanarak standart form tabanlı uygulamalarla güvenlik için farklı mekanizmalar benimseme olasılığı yüksektir.</span><span class="sxs-lookup"><span data-stu-id="a8471-293">They're also very likely to adopt different mechanisms for security, with standard form-based applications leveraging cookie-based authentication and APIs most likely using token-based authentication.</span></span>

<span data-ttu-id="a8471-294">Ayrıca, Blazor sunucu veya kullanma gibi uygulamalar Blazor Blazor WebAssembly ayrı projeler olarak oluşturulmalıdır.</span><span class="sxs-lookup"><span data-stu-id="a8471-294">Additionally, Blazor applications, whether using Blazor Server or Blazor WebAssembly, should be built as separate projects.</span></span> <span data-ttu-id="a8471-295">Uygulamalarda farklı çalışma zamanı özellikleri ve güvenlik modelleri de vardır.</span><span class="sxs-lookup"><span data-stu-id="a8471-295">The applications have different runtime characteristics as well as security models.</span></span> <span data-ttu-id="a8471-296">Büyük olasılıkla sunucu tarafı Web uygulamasıyla (veya API projesiyle) ortak türleri paylaşmaları olasıdır ve bu türler ortak bir paylaşılan projede tanımlanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="a8471-296">They're likely to share common types with the server-side web application (or API project), and these types should be defined in a common shared project.</span></span>

<span data-ttu-id="a8471-297">Blazor WebAssembly EShopOnWeb 'e yönetici arabiriminin eklenmesi, birkaç yeni proje eklemeye gerek.</span><span class="sxs-lookup"><span data-stu-id="a8471-297">The addition of a Blazor WebAssembly admin interface to eShopOnWeb required adding several new projects.</span></span> <span data-ttu-id="a8471-298">Blazor WebAssembly Projenin kendisi, `BlazorAdmin` .</span><span class="sxs-lookup"><span data-stu-id="a8471-298">The Blazor WebAssembly project itself, `BlazorAdmin`.</span></span> <span data-ttu-id="a8471-299">Tarafından kullanılan `BlazorAdmin` ve belirteç tabanlı kimlik doğrulaması kullanmak için yapılandırılan yeni bir ortak API uç noktası kümesi, `PublicApi` projede tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="a8471-299">A new set of public API endpoints, used by `BlazorAdmin` and configured to use token-based authentication, is defined in the `PublicApi` project.</span></span> <span data-ttu-id="a8471-300">Ve bu projelerin her ikisi tarafından kullanılan bazı paylaşılan türler yeni bir `BlazorShared` projede tutulur.</span><span class="sxs-lookup"><span data-stu-id="a8471-300">And certain shared types used by both of these projects are kept in a new `BlazorShared` project.</span></span>

<span data-ttu-id="a8471-301">Bunlardan biri, `BlazorShared` `ApplicationCore` hem hem de gereken herhangi bir türü paylaşmak için kullanılabilen ortak bir proje olduğunda `PublicApi` , neden tek bir proje eklemeli, neden olabilir. `BlazorAdmin`</span><span class="sxs-lookup"><span data-stu-id="a8471-301">One might ask, why add a separate `BlazorShared` project when there is already a common `ApplicationCore` project that could be used to share any types required by both `PublicApi` and `BlazorAdmin`?</span></span> <span data-ttu-id="a8471-302">Yanıt, bu projenin tüm uygulamanın iş mantığını içermesi ve bu nedenle gerekenden çok daha büyük olması ve sunucuda güvenli tutulması gereken çok daha fazla olasılıktır.</span><span class="sxs-lookup"><span data-stu-id="a8471-302">The answer is that this project includes all of the application's business logic and is thus much larger than necessary and also much more likely to need to be kept secure on the server.</span></span> <span data-ttu-id="a8471-303">Tarafından başvurulan herhangi bir kitaplığın `BlazorAdmin` , uygulamayı yüklediklerinde kullanıcıların tarayıcılarına indirileceğini unutmayın Blazor .</span><span class="sxs-lookup"><span data-stu-id="a8471-303">Remember that any library referenced by `BlazorAdmin` will be downloaded to users' browsers when they load the Blazor application.</span></span>

<span data-ttu-id="a8471-304">Arka [uçlar-for-frontends (BFF) modelini](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends)kullanıp kullanmadığını bağlı olarak, uygulama tarafından tüketilen API 'ler Blazor WebAssembly ile %100 türlerini paylaşamaz Blazor .</span><span class="sxs-lookup"><span data-stu-id="a8471-304">Depending on whether one is using the [Backends-For-Frontends (BFF) pattern](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends), the APIs consumed by the Blazor WebAssembly app may not share their types 100% with Blazor.</span></span> <span data-ttu-id="a8471-305">Özellikle, birçok farklı istemci tarafından kullanılması amaçlanan ortak bir API, istemciye özgü paylaşılan bir projede paylaşmak yerine kendi istek ve sonuç türlerini tanımlayabilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-305">In particular, a public API that's meant to be consumed by many different clients may define its own request and result types, rather than sharing them in a client-specific shared project.</span></span> <span data-ttu-id="a8471-306">EShopOnWeb örneğinde, `PublicApi` Proje bir ortak API barındırılmakta olduğundan, tüm istek ve yanıt türleri projeden gelmemesi için varsayım yapılır `BlazorShared` .</span><span class="sxs-lookup"><span data-stu-id="a8471-306">In the eShopOnWeb sample, the assumption is being made that the `PublicApi` project is, in fact, hosting a public API, so not all of its request and response types come from the `BlazorShared` project.</span></span>

### <a name="cross-cutting-concerns"></a><span data-ttu-id="a8471-307">Geniş kapsamlı kritik konular</span><span class="sxs-lookup"><span data-stu-id="a8471-307">Cross-cutting concerns</span></span>

<span data-ttu-id="a8471-308">Uygulamalar büyüdükçe, çoğaltmayı ortadan kaldırmak ve tutarlılığı sürdürmek için çapraz kesme sorunlarını ortadan kaldırmak giderek daha da önemli hale gelir.</span><span class="sxs-lookup"><span data-stu-id="a8471-308">As applications grow, it becomes increasingly important to factor out cross-cutting concerns to eliminate duplication and maintain consistency.</span></span> <span data-ttu-id="a8471-309">ASP.NET Core uygulamalardaki çapraz kesme kaygılarının bazı örnekleri, çok sayıda diğerleri olsa da, kimlik doğrulama, model doğrulama kuralları, çıktı önbelleği ve hata işleme örnekleridir.</span><span class="sxs-lookup"><span data-stu-id="a8471-309">Some examples of cross-cutting concerns in ASP.NET Core applications are authentication, model validation rules, output caching, and error handling, though there are many others.</span></span> <span data-ttu-id="a8471-310">ASP.NET Core MVC [filtreleri](/aspnet/core/mvc/controllers/filters) , istek işleme ardışık düzeninde belirli adımlardan önce veya sonra kod çalıştırmanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="a8471-310">ASP.NET Core MVC [filters](/aspnet/core/mvc/controllers/filters) allow you to run code before or after certain steps in the request processing pipeline.</span></span> <span data-ttu-id="a8471-311">Örneğin bir filtre, model bağlamadan önce ve sonra, bir eylemden önce ve sonra ya da bir eylem sonucundan önce ve sonra çalışabilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-311">For instance, a filter can run before and after model binding, before and after an action, or before and after an action's result.</span></span> <span data-ttu-id="a8471-312">Ayrıca, ardışık düzenin geri kalanına erişimi denetlemek için bir yetkilendirme filtresi de kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-312">You can also use an authorization filter to control access to the rest of the pipeline.</span></span> <span data-ttu-id="a8471-313">Şekil 7-2, yapılandırılmışsa, istek yürütmenin filtreler aracılığıyla nasıl akacağını gösterir.</span><span class="sxs-lookup"><span data-stu-id="a8471-313">Figures 7-2 shows how request execution flows through filters, if configured.</span></span>

![İstek, Yetkilendirme filtreleri, kaynak filtreleri, model bağlama, eylem filtreleri, eylem yürütme ve eylem sonucu dönüştürme, özel durum filtreleri, sonuç filtreleri ve sonuç yürütmesi aracılığıyla işlenir.](./media/image7-2.png)

<span data-ttu-id="a8471-316">**Şekil 7-2**.</span><span class="sxs-lookup"><span data-stu-id="a8471-316">**Figure 7-2**.</span></span> <span data-ttu-id="a8471-317">Filtreler ve istek işlem hattı aracılığıyla yürütme isteği.</span><span class="sxs-lookup"><span data-stu-id="a8471-317">Request execution through filters and request pipeline.</span></span>

<span data-ttu-id="a8471-318">Filtreler genellikle öznitelik olarak uygulanır, bu sayede bunları denetleyicilere veya eylemlere (veya genel olarak) uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-318">Filters are usually implemented as attributes, so you can apply them to controllers or actions (or even globally).</span></span> <span data-ttu-id="a8471-319">Bu biçimde eklendiğinde, eylem düzeyinde belirtilen filtreler geçersiz kılınır veya denetleyici düzeyinde belirtilen filtrelerin üzerine inşa edildiğinde, kendilerine genel filtreleri geçersiz kılar.</span><span class="sxs-lookup"><span data-stu-id="a8471-319">When added in this fashion, filters specified at the action level override or build upon filters specified at the controller level, which themselves override global filters.</span></span> <span data-ttu-id="a8471-320">Örneğin, \[ yol \] özniteliği denetleyiciler ve Eylemler arasındaki yolları oluşturmak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-320">For example, the \[Route\] attribute can be used to build up routes between controllers and actions.</span></span> <span data-ttu-id="a8471-321">Benzer şekilde, yetkilendirme denetleyici düzeyinde yapılandırılabilir ve aşağıdaki örnekte gösterildiği gibi ayrı eylemler tarafından geçersiz kılınır:</span><span class="sxs-lookup"><span data-stu-id="a8471-321">Likewise, authorization can be configured at the controller level, and then overridden by individual actions, as the following sample demonstrates:</span></span>

```csharp
[Authorize]
public class AccountController : Controller

{
    [AllowAnonymous] // overrides the Authorize attribute
    public async Task<IActionResult> Login() {}
    public async Task<IActionResult> ForgotPassword() {}
}
```

<span data-ttu-id="a8471-322">İlk yöntem olan oturum açma, denetleyici düzeyinde ayarlanan yetkilendirme filtresini geçersiz kılmak için AllowAnonymous filtresini (özniteliği) kullanır.</span><span class="sxs-lookup"><span data-stu-id="a8471-322">The first method, Login, uses the AllowAnonymous filter (attribute) to override the Authorize filter set at the controller level.</span></span> <span data-ttu-id="a8471-323">ForgotPassword eylemi (ve AllowAnonymous özniteliği olmayan sınıfta bulunan başka bir eylem), kimliği doğrulanmış bir istek gerektirir.</span><span class="sxs-lookup"><span data-stu-id="a8471-323">The ForgotPassword action (and any other action in the class that doesn't have an AllowAnonymous attribute) will require an authenticated request.</span></span>

<span data-ttu-id="a8471-324">Filtreler, API 'Ler için ortak hata işleme ilkeleri biçimindeki yinelemeyi ortadan kaldırmak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-324">Filters can be used to eliminate duplication in the form of common error handling policies for APIs.</span></span> <span data-ttu-id="a8471-325">Örneğin, tipik bir API ilkesi, var olmayan anahtarlara başvuran isteklere NotFound yanıtı ve model doğrulaması başarısız olursa bir BadRequest yanıtı döndürmemelidir.</span><span class="sxs-lookup"><span data-stu-id="a8471-325">For example, a typical API policy is to return a NotFound response to requests referencing keys that do not exist, and a BadRequest response if model validation fails.</span></span> <span data-ttu-id="a8471-326">Aşağıdaki örnek, bu iki ilkeyi eylemde gösterir:</span><span class="sxs-lookup"><span data-stu-id="a8471-326">The following example demonstrates these two policies in action:</span></span>

```csharp
[HttpPut("{id}")]
public async Task<IActionResult> Put(int id, [FromBody]Author author)
{
    if ((await _authorRepository.ListAsync()).All(a => a.Id != id))
    {
        return NotFound(id);
    }
    if (!ModelState.IsValid)
    {
        return BadRequest(ModelState);
    }
    author.Id = id;
    await _authorRepository.UpdateAsync(author);
    return Ok();
}
```

<span data-ttu-id="a8471-327">Eylem yöntemlerinizi bunun gibi koşullu kodla karışık hale gelmesine izin vermez.</span><span class="sxs-lookup"><span data-stu-id="a8471-327">Don't allow your action methods to become cluttered with conditional code like this.</span></span> <span data-ttu-id="a8471-328">Bunun yerine, ilkeleri gereken şekilde uygulanabilecek filtrelere çekin.</span><span class="sxs-lookup"><span data-stu-id="a8471-328">Instead, pull the policies into filters that can be applied on an as-needed basis.</span></span> <span data-ttu-id="a8471-329">Bu örnekte, API 'ye bir komutun gönderilmesi her zaman oluşması gereken model doğrulama denetimi aşağıdaki öznitelikle değiştirilebilir:</span><span class="sxs-lookup"><span data-stu-id="a8471-329">In this example, the model validation check, which should occur anytime a command is sent to the API, can be replaced by the following attribute:</span></span>

```csharp
public class ValidateModelAttribute : ActionFilterAttribute
{
    public override void OnActionExecuting(ActionExecutingContext context)
    {
        if (!context.ModelState.IsValid)
        {
            context.Result = new BadRequestObjectResult(context.ModelState);
        }
    }
}
```

<span data-ttu-id="a8471-330">`ValidateModelAttribute` [Ardalış. ValidateModel](https://www.nuget.org/packages/Ardalis.ValidateModel) paketini dahil ederek projenize bir NuGet bağımlılığı olarak ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-330">You can add the `ValidateModelAttribute` to your project as a NuGet dependency by including the [Ardalis.ValidateModel](https://www.nuget.org/packages/Ardalis.ValidateModel) package.</span></span> <span data-ttu-id="a8471-331">API 'Ler için, `ApiController` Bu davranışı ayrı bir filtreye gerek olmadan zorlamak için özniteliğini kullanabilirsiniz `ValidateModel` .</span><span class="sxs-lookup"><span data-stu-id="a8471-331">For APIs, you can use the `ApiController` attribute to enforce this behavior without the need for a separate `ValidateModel` filter.</span></span>

<span data-ttu-id="a8471-332">Benzer şekilde, bir filtre, bir kaydın mevcut olup olmadığını denetlemek için kullanılabilir ve eylem yürütülmeden önce bir 404 döndürebilir, bu denetimleri eylemde gerçekleştirme gereksinimini ortadan kaldırır.</span><span class="sxs-lookup"><span data-stu-id="a8471-332">Likewise, a filter can be used to check if a record exists and return a 404 before the action is executed, eliminating the need to perform these checks in the action.</span></span> <span data-ttu-id="a8471-333">Ortak kuralları kullanıma aldıktan ve çözümünüzü altyapı kodu ve iş mantığını kullanıcı arabiriminden ayırmak üzere düzenledikten sonra, MVC eylem yöntemlerinizi son derece ölçülü olmalıdır:</span><span class="sxs-lookup"><span data-stu-id="a8471-333">Once you've pulled out common conventions and organized your solution to separate infrastructure code and business logic from your UI, your MVC action methods should be extremely thin:</span></span>

```csharp
[HttpPut("{id}")]
[ValidateAuthorExists]
public async Task<IActionResult> Put(int id, [FromBody]Author author)
{
    await _authorRepository.UpdateAsync(author);
    return Ok();
}
```

<span data-ttu-id="a8471-334">Filtre uygulama hakkında daha fazla bilgi edinmek ve MSDN Magazine makalesinden, [gerçek dünya ASP.NET Core MVC filtrelerinden](https://docs.microsoft.com/archive/msdn-magazine/2016/august/asp-net-core-real-world-asp-net-core-mvc-filters)çalışan bir örneği indirmek için daha fazla bilgi edinebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-334">You can read more about implementing filters and download a working sample from the MSDN Magazine article, [Real-World ASP.NET Core MVC Filters](https://docs.microsoft.com/archive/msdn-magazine/2016/august/asp-net-core-real-world-asp-net-core-mvc-filters).</span></span>

> ### <a name="references--structuring-applications"></a><span data-ttu-id="a8471-335">Başvurular – uygulamaları yapılandırma</span><span class="sxs-lookup"><span data-stu-id="a8471-335">References – Structuring applications</span></span>
>
> - <span data-ttu-id="a8471-336">**Alanlar**</span><span class="sxs-lookup"><span data-stu-id="a8471-336">**Areas**</span></span>  
>   <https://docs.microsoft.com/aspnet/core/mvc/controllers/areas>
> - <span data-ttu-id="a8471-337">**MSDN Magazine – ASP.NET Core MVC için özellik dilimleri**</span><span class="sxs-lookup"><span data-stu-id="a8471-337">**MSDN Magazine – Feature Slices for ASP.NET Core MVC**</span></span>  
>   <https://docs.microsoft.com/archive/msdn-magazine/2016/september/asp-net-core-feature-slices-for-asp-net-core-mvc>
> - <span data-ttu-id="a8471-338">**Filtreler**</span><span class="sxs-lookup"><span data-stu-id="a8471-338">**Filters**</span></span>  
>   <https://docs.microsoft.com/aspnet/core/mvc/controllers/filters>
> - <span data-ttu-id="a8471-339">**MSDN Magazine – gerçek dünya ASP.NET Core MVC filtreleri**</span><span class="sxs-lookup"><span data-stu-id="a8471-339">**MSDN Magazine – Real World ASP.NET Core MVC Filters**</span></span>  
>   <https://docs.microsoft.com/archive/msdn-magazine/2016/august/asp-net-core-real-world-asp-net-core-mvc-filters>

## <a name="security"></a><span data-ttu-id="a8471-340">Güvenlik</span><span class="sxs-lookup"><span data-stu-id="a8471-340">Security</span></span>

<span data-ttu-id="a8471-341">Web uygulamalarının güvenliğini sağlamak, çok sayıda konuyla büyük bir konudur.</span><span class="sxs-lookup"><span data-stu-id="a8471-341">Securing web applications is a large topic, with many considerations.</span></span> <span data-ttu-id="a8471-342">En temel düzeyinde güvenlik, belirli bir isteğin geldiği kişiyi öğrendiğinizden ve isteğin yalnızca gereken kaynaklara erişimi olduğundan emin olmanızı içerir.</span><span class="sxs-lookup"><span data-stu-id="a8471-342">At its most basic level, security involves ensuring you know who a given request is coming from, and then ensuring that the request only has access to resources it should.</span></span> <span data-ttu-id="a8471-343">Kimlik doğrulaması, isteğin bilinen bir varlıktan geldiği kabul edilmesinin gerekip gerekmediğini görmek için, güvenilir bir veri deposundaki bir istekle girilen kimlik bilgilerini karşılaştırma işlemidir.</span><span class="sxs-lookup"><span data-stu-id="a8471-343">Authentication is the process of comparing credentials provided with a request to those in a trusted data store, to see if the request should be treated as coming from a known entity.</span></span> <span data-ttu-id="a8471-344">Yetkilendirme, belirli kaynaklara erişimi kullanıcı kimliğine göre kısıtlama işlemidir.</span><span class="sxs-lookup"><span data-stu-id="a8471-344">Authorization is the process of restricting access to certain resources based on user identity.</span></span> <span data-ttu-id="a8471-345">Üçüncü bir güvenlik konusu, isteklerin, en azından [SSL 'nin uygulamanız tarafından kullanıldığından emin](/aspnet/core/security/enforcing-ssl)olmanız gereken üçüncü taraflar tarafından dinleyerek dinleme yaptığı isteklerden korunuyor.</span><span class="sxs-lookup"><span data-stu-id="a8471-345">A third security concern is protecting requests from eavesdropping by third parties, for which you should at least [ensure that SSL is used by your application](/aspnet/core/security/enforcing-ssl).</span></span>

### <a name="identity"></a><span data-ttu-id="a8471-346">Kimlik</span><span class="sxs-lookup"><span data-stu-id="a8471-346">Identity</span></span>

<span data-ttu-id="a8471-347">ASP.NET Core kimlik, uygulamanız için oturum açma işlevlerini desteklemek için kullanabileceğiniz bir üyelik sistemidir.</span><span class="sxs-lookup"><span data-stu-id="a8471-347">ASP.NET Core Identity is a membership system you can use to support login functionality for your application.</span></span> <span data-ttu-id="a8471-348">Bu, yerel kullanıcı hesaplarının yanı sıra Microsoft hesabı, Twitter, Facebook, Google ve daha fazlası gibi sağlayıcılardan dış oturum açma sağlayıcısı desteği için destek içerir.</span><span class="sxs-lookup"><span data-stu-id="a8471-348">It has support for local user accounts as well as external login provider support from providers like Microsoft Account, Twitter, Facebook, Google, and more.</span></span> <span data-ttu-id="a8471-349">ASP.NET Core kimliğe ek olarak, uygulamanız Windows kimlik doğrulamasını veya [kimlik sunucusu](https://github.com/IdentityServer/IdentityServer4)gibi bir üçüncü taraf kimlik sağlayıcısını kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-349">In addition to ASP.NET Core Identity, your application can use windows authentication, or a third-party identity provider like [Identity Server](https://github.com/IdentityServer/IdentityServer4).</span></span>

<span data-ttu-id="a8471-350">Bireysel kullanıcı hesapları seçeneği işaretliyse ASP.NET Core kimlik yeni proje şablonlarına dahil edilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-350">ASP.NET Core Identity is included in new project templates if the Individual User Accounts option is selected.</span></span> <span data-ttu-id="a8471-351">Bu şablon kayıt, oturum açma, dış oturum açma, unutulan parolalar ve ek işlevsellik için destek içerir.</span><span class="sxs-lookup"><span data-stu-id="a8471-351">This template includes support for registration, login, external logins, forgotten passwords, and additional functionality.</span></span>

![Kimliği önceden yapılandırılmış olan bireysel kullanıcı hesaplarını seçin](./media/image7-3.png)

<span data-ttu-id="a8471-353">**Şekil 7-3**.</span><span class="sxs-lookup"><span data-stu-id="a8471-353">**Figure 7-3**.</span></span> <span data-ttu-id="a8471-354">Kimliği önceden yapılandırılmış olan bireysel kullanıcı hesaplarını seçin.</span><span class="sxs-lookup"><span data-stu-id="a8471-354">Select Individual User Accounts to have Identity preconfigured.</span></span>

<span data-ttu-id="a8471-355">Kimlik desteği başlangıçta, hem ConfigureServices hem de yapılandırma ' da yapılandırılır:</span><span class="sxs-lookup"><span data-stu-id="a8471-355">Identity support is configured in Startup, both in ConfigureServices and Configure:</span></span>

```csharp
public void ConfigureServices(IServiceCollection services)
{
    // Add framework services.
    services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));
    services.AddIdentity<ApplicationUser, IdentityRole>()
        .AddEntityFrameworkStores<ApplicationDbContext>()
        .AddDefaultTokenProviders();
    services.AddMvc();
}

public void Configure(IApplicationBuilder app)
{
    app.UseStaticFiles();
    app.UseIdentity();
    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllerRoute(name: "default", pattern: "{controller=Home}/{action=Index}/{id?}");
    });
}
```

<span data-ttu-id="a8471-356">Useıdentity 'in configure yönteminde UseMvc 'den önce görünmesi önemlidir.</span><span class="sxs-lookup"><span data-stu-id="a8471-356">It's important that UseIdentity appear before UseMvc in the Configure method.</span></span> <span data-ttu-id="a8471-357">ConfigureServices 'da kimlik yapılandırılırken, AddDefaultTokenProviders için bir çağrı olduğunu fark edeceksiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-357">When configuring Identity in ConfigureServices, you'll notice a call to AddDefaultTokenProviders.</span></span> <span data-ttu-id="a8471-358">Bu, Web iletişimlerini güvenli hale getirmek için kullanılabilecek belirteçlerle hiçbir şey yapmaz, bunun yerine kullanıcıların kimliklerini onaylamasını sağlamak için SMS veya e-posta aracılığıyla kullanıcılara gönderilebilecek istekleri oluşturan sağlayıcılara başvurur.</span><span class="sxs-lookup"><span data-stu-id="a8471-358">This has nothing to do with tokens that may be used to secure web communications, but instead refers to providers that create prompts that can be sent to users via SMS or email in order for them to confirm their identity.</span></span>

<span data-ttu-id="a8471-359">[İki öğeli kimlik doğrulamayı yapılandırma](/aspnet/core/security/authentication/2fa) ve resmi ASP.NET Core belgelerinden [dış oturum açma sağlayıcılarını etkinleştirme](/aspnet/core/security/authentication/social/) hakkında daha fazla bilgi edinebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-359">You can learn more about [configuring two-factor authentication](/aspnet/core/security/authentication/2fa) and [enabling external login providers](/aspnet/core/security/authentication/social/) from the official ASP.NET Core docs.</span></span>

### <a name="authentication"></a><span data-ttu-id="a8471-360">Kimlik Doğrulaması</span><span class="sxs-lookup"><span data-stu-id="a8471-360">Authentication</span></span>

<span data-ttu-id="a8471-361">Kimlik doğrulama, sisteme kimlerin eriştiğini belirleme işlemidir.</span><span class="sxs-lookup"><span data-stu-id="a8471-361">Authentication is the process of determining who is accessing the system.</span></span> <span data-ttu-id="a8471-362">Önceki bölümde gösterilen ASP.NET Core kimliği ve yapılandırma yöntemleri kullanıyorsanız, uygulama içindeki bazı kimlik doğrulama varsayılanlarını otomatik olarak yapılandırır.</span><span class="sxs-lookup"><span data-stu-id="a8471-362">If you're using ASP.NET Core Identity and the configuration methods shown in the previous section, it will automatically configure some authentication defaults in the application.</span></span> <span data-ttu-id="a8471-363">Bununla birlikte, bu Varsayılanları el ile de yapılandırabilir veya AddEntity tarafından ayarlanmış olanları geçersiz kılabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-363">However, you can also configure these defaults manually, or override the ones set by AddIdentity.</span></span> <span data-ttu-id="a8471-364">Kimlik kullanıyorsanız, tanımlama bilgisi tabanlı kimlik doğrulamasını varsayılan *Düzen*olarak yapılandırın.</span><span class="sxs-lookup"><span data-stu-id="a8471-364">If you're using Identity, it configure cookie-based authentication as the default *scheme*.</span></span>

<span data-ttu-id="a8471-365">Web tabanlı kimlik doğrulamasında, genellikle bir sistem istemcisinin kimlik doğrulaması sırasında gerçekleştirilebilecek en fazla 5 eylem vardır.</span><span class="sxs-lookup"><span data-stu-id="a8471-365">In web-based authentication, there are typically up to 5 actions that may be performed in the course of authenticating a client of a system.</span></span> <span data-ttu-id="a8471-366">Bunlar:</span><span class="sxs-lookup"><span data-stu-id="a8471-366">These are:</span></span>

- <span data-ttu-id="a8471-367">Denetimini.</span><span class="sxs-lookup"><span data-stu-id="a8471-367">Authenticate.</span></span> <span data-ttu-id="a8471-368">Uygulama içinde kullanmak üzere bir kimlik oluşturmak için istemci tarafından sunulan bilgileri kullanın.</span><span class="sxs-lookup"><span data-stu-id="a8471-368">Use information provided by the client to create an identity for them to use within the application.</span></span>
- <span data-ttu-id="a8471-369">Sına.</span><span class="sxs-lookup"><span data-stu-id="a8471-369">Challenge.</span></span> <span data-ttu-id="a8471-370">Bu eylem, istemcinin kendilerini belirlemesini gerektirmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="a8471-370">This action is used to require the client to identify themselves.</span></span>
- <span data-ttu-id="a8471-371">Yasaklamaz.</span><span class="sxs-lookup"><span data-stu-id="a8471-371">Forbid.</span></span> <span data-ttu-id="a8471-372">İstemciye bir eylem gerçekleştirmekten yasaklanmış olduğunu bildirin.</span><span class="sxs-lookup"><span data-stu-id="a8471-372">Inform the client they are forbidden from performing an action.</span></span>
- <span data-ttu-id="a8471-373">Oturum açın.</span><span class="sxs-lookup"><span data-stu-id="a8471-373">Sign-in.</span></span> <span data-ttu-id="a8471-374">Mevcut istemciyi bir şekilde kalıcı hale getirin.</span><span class="sxs-lookup"><span data-stu-id="a8471-374">Persist the existing client in some way.</span></span>
- <span data-ttu-id="a8471-375">Oturum kapatma. İstemciyi kalıcılığı kaldırın.</span><span class="sxs-lookup"><span data-stu-id="a8471-375">Sign-out. Remove the client from persistence.</span></span>

<span data-ttu-id="a8471-376">Web uygulamalarında kimlik doğrulaması gerçekleştirmeye yönelik çeşitli yaygın teknikler vardır.</span><span class="sxs-lookup"><span data-stu-id="a8471-376">There are a number of common techniques for performing authentication in web applications.</span></span> <span data-ttu-id="a8471-377">Bunlar, şemalar olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="a8471-377">These are referred to as schemes.</span></span> <span data-ttu-id="a8471-378">Belirli bir düzen, Yukarıdaki seçeneklerin bazıları veya tümü için eylem tanımlar.</span><span class="sxs-lookup"><span data-stu-id="a8471-378">A given scheme will define actions for some or all of the above options.</span></span> <span data-ttu-id="a8471-379">Bazı şemalar yalnızca eylemlerin bir alt kümesini destekler ve desteklemediği işlemleri gerçekleştirmek için ayrı bir şema gerektirebilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-379">Some schemes only support a subset of actions, and may require a separate scheme to perform those it does not support.</span></span> <span data-ttu-id="a8471-380">Örneğin, OpenID-Connect (OıDC) şeması, oturum açma veya oturumu kapatma işlemini desteklemez, ancak yaygın olarak bu Kalıcılık için tanımlama bilgisi kimlik doğrulaması kullanmak üzere yapılandırılmıştır.</span><span class="sxs-lookup"><span data-stu-id="a8471-380">For example, the OpenId-Connect (OIDC) scheme doesn't support Sign-in or Sign-out, but is commonly configured to use Cookie authentication for this persistence.</span></span>

<span data-ttu-id="a8471-381">ASP.NET Core uygulamanızda, `DefaultAuthenticateScheme` yukarıda açıklanan eylemlerin her biri için isteğe bağlı özel düzenleri de yapılandırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-381">In your ASP.NET Core application, you can configure a `DefaultAuthenticateScheme` as well as optional specific schemes for each of the actions described above.</span></span> <span data-ttu-id="a8471-382">Örneğin,, `DefaultChallengeScheme` , `DefaultForbidScheme` vb. Çağırma [`AddIdentity<TUser,TRole>`](https://github.com/dotnet/aspnetcore/blob/release/3.1/src/Identity/Core/src/IdentityServiceCollectionExtensions.cs#L38-L102) , uygulamanın çeşitli yönlerini yapılandırır ve birçok gerekli hizmeti ekler.</span><span class="sxs-lookup"><span data-stu-id="a8471-382">For example, `DefaultChallengeScheme`, `DefaultForbidScheme`, etc. Calling [`AddIdentity<TUser,TRole>`](https://github.com/dotnet/aspnetcore/blob/release/3.1/src/Identity/Core/src/IdentityServiceCollectionExtensions.cs#L38-L102) configures a number of aspects of the application and adds many required services.</span></span> <span data-ttu-id="a8471-383">Ayrıca, kimlik doğrulama düzenini yapılandırmak için bu çağrıyı içerir:</span><span class="sxs-lookup"><span data-stu-id="a8471-383">It also includes this call to configure the authentication scheme:</span></span>

```csharp
services.AddAuthentication(options =>
{
    options.DefaultAuthenticateScheme = IdentityConstants.ApplicationScheme;
    options.DefaultChallengeScheme = IdentityConstants.ApplicationScheme;
    options.DefaultSignInScheme = IdentityConstants.ExternalScheme;
});
```

<span data-ttu-id="a8471-384">Bu düzenler, varsayılan olarak kimlik doğrulaması için oturum açma sayfalarında Kalıcılık ve yeniden yönlendirme için tanımlama bilgilerini kullanır.</span><span class="sxs-lookup"><span data-stu-id="a8471-384">These schemes use cookies for persistence and redirection to login pages for authentication by default.</span></span> <span data-ttu-id="a8471-385">Bu şemalar, Web tarayıcıları aracılığıyla kullanıcılarla etkileşen ancak API 'Ler için önerilmeyen Web uygulamaları için uygundur.</span><span class="sxs-lookup"><span data-stu-id="a8471-385">These schemes are appropriate for web applications that interact with users via web browsers, but not recommended for APIs.</span></span> <span data-ttu-id="a8471-386">Bunun yerine, API 'Ler genellikle JWT taşıyıcı belirteçleri gibi başka bir kimlik doğrulama biçimi kullanır.</span><span class="sxs-lookup"><span data-stu-id="a8471-386">Instead, APIs will typically use another form of authentication, such as JWT bearer tokens.</span></span>

<span data-ttu-id="a8471-387">Web API 'Leri, `HttpClient` .NET uygulamaları ve diğer çerçevelerde eşdeğer türler gibi kod tarafından kullanılır.</span><span class="sxs-lookup"><span data-stu-id="a8471-387">Web APIs are consumed by code, such as `HttpClient` in .NET applications and equivalent types in other frameworks.</span></span> <span data-ttu-id="a8471-388">Bu istemciler bir API çağrısından kullanılabilir bir yanıt bekler veya varsa, sorun oluştuğunda ne olduğunu belirten bir durum kodudur.</span><span class="sxs-lookup"><span data-stu-id="a8471-388">These clients expect a usable response from an API call, or a status code indicating what, if any, problem has occurred.</span></span> <span data-ttu-id="a8471-389">Bu istemciler bir tarayıcıdan etkileşim kurmazlar ve bir API 'nin döndürebileceği HTML 'yi işlemez veya bunlarla etkileşime girmezler.</span><span class="sxs-lookup"><span data-stu-id="a8471-389">These clients are not interacting through a browser and do not render or interact with any HTML that an API might return.</span></span> <span data-ttu-id="a8471-390">Bu nedenle, kimlik doğrulamasından geçirilmezse istemcilerinin oturum açma sayfalarına yönlendirilmesini sağlamak için API uç noktaları için uygun değildir.</span><span class="sxs-lookup"><span data-stu-id="a8471-390">Thus, it is not appropriate for API endpoints to redirect their clients to login pages if they are not authenticated.</span></span> <span data-ttu-id="a8471-391">Başka bir düzen daha uygundur.</span><span class="sxs-lookup"><span data-stu-id="a8471-391">Another scheme is more appropriate.</span></span>

<span data-ttu-id="a8471-392">API 'Lerin kimlik doğrulamasını yapılandırmak için, `PublicApi` eShopOnWeb Reference uygulamasındaki proje tarafından kullanılan aşağıdaki gibi kimlik doğrulamasını ayarlayabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="a8471-392">To configure authentication for APIs, you might set up authentication like the following, used by the `PublicApi` project in the eShopOnWeb reference application:</span></span>

```csharp
services.AddAuthentication(config =>
{
    config.DefaultScheme = JwtBearerDefaults.AuthenticationScheme;
})
    .AddJwtBearer(config =>
    {
        config.RequireHttpsMetadata = false;
        config.SaveToken = true;
        config.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuerSigningKey = true,
            IssuerSigningKey = new SymmetricSecurityKey(key),
            ValidateIssuer = false,
            ValidateAudience = false
        };
    });
```

<span data-ttu-id="a8471-393">Tek bir proje içinde birden çok farklı kimlik doğrulama düzeni yapılandırmak mümkün olsa da, tek bir varsayılan düzeni yapılandırmak çok basittir.</span><span class="sxs-lookup"><span data-stu-id="a8471-393">While it is possible to configure multiple different authentication schemes within a single project, it is much simpler to configure a single default scheme.</span></span> <span data-ttu-id="a8471-394">Bu nedenle, eShopOnWeb Reference uygulaması, API 'Lerini, `PublicApi` `Web` uygulamanın görünümlerini ve Razor Pages içeren ana projeden ayrı olarak kendi projesine ayırır.</span><span class="sxs-lookup"><span data-stu-id="a8471-394">For this reason, among others, the eShopOnWeb reference application separates its APIs into their own project, `PublicApi`, separate from the main `Web` project that includes the application's views and Razor Pages.</span></span>

#### <a name="authentication-in-no-locblazor-apps"></a><span data-ttu-id="a8471-395">Uygulamalarda kimlik doğrulaması Blazor</span><span class="sxs-lookup"><span data-stu-id="a8471-395">Authentication in Blazor apps</span></span>

<span data-ttu-id="a8471-396">Blazor Sunucu uygulamaları, diğer ASP.NET Core uygulamalarla aynı kimlik doğrulama özelliklerinden faydalanabilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-396">Blazor Server applications can leverage the same authentication features as any other ASP.NET Core application.</span></span> <span data-ttu-id="a8471-397">BlazorWebAssemblyuygulamalar, tarayıcıda çalıştırıldıklarından, yerleşik kimlik ve kimlik doğrulama sağlayıcılarını kullanamaz.</span><span class="sxs-lookup"><span data-stu-id="a8471-397">Blazor WebAssembly applications cannot use the built-in Identity and Authentication providers, however, since they run in the browser.</span></span> <span data-ttu-id="a8471-398">BlazorWebAssemblyuygulamalar Kullanıcı kimlik doğrulama durumunu yerel olarak saklayabilir ve kullanıcıların gerçekleştirebilecekleri eylemleri belirlemek için taleplere erişebilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-398">Blazor WebAssembly applications can store user authentication status locally and can access claims to determine what actions users should be able to perform.</span></span> <span data-ttu-id="a8471-399">Ancak, Blazor WebAssembly Kullanıcılar uygulamayı kolayca atlayıp API 'lerle doğrudan etkileşime girebileceği için tüm kimlik doğrulama ve yetkilendirme denetimleri, uygulamanın içinde uygulanan mantığa bakılmaksızın sunucuda gerçekleştirilmelidir.</span><span class="sxs-lookup"><span data-stu-id="a8471-399">However, all authentication and authorization checks should be performed on the server regardless of any logic implemented inside the Blazor WebAssembly app, since users can easily bypass the app and interact with the APIs directly.</span></span>

> ### <a name="references--authentication"></a><span data-ttu-id="a8471-400">Başvurular – kimlik doğrulaması</span><span class="sxs-lookup"><span data-stu-id="a8471-400">References – Authentication</span></span>
>
> - <span data-ttu-id="a8471-401">**Kimlik doğrulama eylemleri ve varsayılanlar**</span><span class="sxs-lookup"><span data-stu-id="a8471-401">**Authentication Actions and Defaults**</span></span>  
>   <https://stackoverflow.com/a/52493428>
> - <span data-ttu-id="a8471-402">**Maça kimlik doğrulaması ve yetkilendirme**
>   <https://docs.microsoft.com/aspnet/core/security/authentication/identity-api-authorization></span><span class="sxs-lookup"><span data-stu-id="a8471-402">**Authentication and Authorization for SPAs**
<https://docs.microsoft.com/aspnet/core/security/authentication/identity-api-authorization></span></span>
> - <span data-ttu-id="a8471-403">**ASP.NET Core Blazor kimlik doğrulaması ve yetkilendirme**
>   <https://docs.microsoft.com/aspnet/core/blazor/security/></span><span class="sxs-lookup"><span data-stu-id="a8471-403">**ASP.NET Core Blazor Authentication and Authorization**
<https://docs.microsoft.com/aspnet/core/blazor/security/></span></span>
> - <span data-ttu-id="a8471-404">**Güvenlik: ASP.NET Web Forms ve üzerinde kimlik doğrulaması ve yetkilendirme Blazor**
>   <https://docs.microsoft.com/dotnet/architecture/blazor-for-web-forms-developers/security-authentication-authorization></span><span class="sxs-lookup"><span data-stu-id="a8471-404">**Security: Authentication and Authorization in ASP.NET Web Forms and Blazor**
<https://docs.microsoft.com/dotnet/architecture/blazor-for-web-forms-developers/security-authentication-authorization></span></span>

### <a name="authorization"></a><span data-ttu-id="a8471-405">Yetkilendirme</span><span class="sxs-lookup"><span data-stu-id="a8471-405">Authorization</span></span>

<span data-ttu-id="a8471-406">En basit yetkilendirme biçimi anonim kullanıcılara erişimin kısıtlanmasını içerir.</span><span class="sxs-lookup"><span data-stu-id="a8471-406">The simplest form of authorization involves restricting access to anonymous users.</span></span> <span data-ttu-id="a8471-407">Bu, yalnızca \[ \] belirli denetleyicilere veya eylemlere Yetkilendir özniteliği uygulanarak elde edilebilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-407">This can be achieved by simply applying the \[Authorize\] attribute to certain controllers or actions.</span></span> <span data-ttu-id="a8471-408">Roller kullanılıyorsa, bu öznitelik, aşağıda gösterildiği gibi belirli rollere ait kullanıcılara erişimi kısıtlamak için daha fazla genişletilebilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-408">If roles are being used, the attribute can be further extended to restrict access to users who belong to certain roles, as shown:</span></span>

```csharp
[Authorize(Roles = "HRManager,Finance")]
public class SalaryController : Controller
{

}
```

<span data-ttu-id="a8471-409">Bu durumda, HRManager veya finans rollerinin (ya da her ikisi) birine ait olan kullanıcılar SalaryController erişimine sahip olur.</span><span class="sxs-lookup"><span data-stu-id="a8471-409">In this case, users belonging to either the HRManager or Finance roles (or both) would have access to the SalaryController.</span></span> <span data-ttu-id="a8471-410">Bir kullanıcının birden çok role (yalnızca birkaç tane değil) ait olmasını gerektirmek için, her seferinde gerekli bir rol belirterek özniteliği birden çok kez uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-410">To require that a user belong to multiple roles (not just one of several), you can apply the attribute multiple times, specifying a required role each time.</span></span>

<span data-ttu-id="a8471-411">Birçok farklı denetleyicilerde ve eylemlerdeki belirli rol kümelerini belirtme, istenmeyen bir tekrarya yol açabilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-411">Specifying certain sets of roles as strings in many different controllers and actions can lead to undesirable repetition.</span></span> <span data-ttu-id="a8471-412">En azından, bu dize sabit değerleri için sabitleri tanımlayın ve dizeyi belirtmeniz gereken her yerde sabitleri kullanın.</span><span class="sxs-lookup"><span data-stu-id="a8471-412">At a minimum, define constants for these string literals and use the constants anywhere you need to specify the string.</span></span> <span data-ttu-id="a8471-413">Yetkilendirme kurallarını kapsülleyen yetkilendirme ilkelerini de yapılandırabilir ve sonra Yetkilendir özniteliği uygulanırken ayrı roller yerine ilkeyi belirtebilirsiniz \[ \] :</span><span class="sxs-lookup"><span data-stu-id="a8471-413">You can also configure authorization policies, which encapsulate authorization rules, and then specify the policy instead of individual roles when applying the \[Authorize\] attribute:</span></span>

```csharp
[Authorize(Policy = "CanViewPrivateReport")]
public IActionResult ExecutiveSalaryReport()
{
    return View();
}
```

<span data-ttu-id="a8471-414">İlkeleri bu şekilde kullanarak, bu işlem için uygulanan belirli rol veya kurallardan sınırlandırılmakta olan eylemlerin türlerini ayırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-414">Using policies in this way, you can separate the kinds of actions being restricted from the specific roles or rules that apply to it.</span></span> <span data-ttu-id="a8471-415">Daha sonra, belirli kaynaklara erişmesi gereken yeni bir rol oluşturursanız, her yetkilendirme özniteliğinde her rol listesini güncelleştirmek yerine yalnızca bir ilkeyi güncelleştirebilirsiniz \[ \] .</span><span class="sxs-lookup"><span data-stu-id="a8471-415">Later, if you create a new role that needs to have access to certain resources, you can just update a policy, rather than updating every list of roles on every \[Authorize\] attribute.</span></span>

#### <a name="claims"></a><span data-ttu-id="a8471-416">Talepler</span><span class="sxs-lookup"><span data-stu-id="a8471-416">Claims</span></span>

<span data-ttu-id="a8471-417">Talepler, kimliği doğrulanmış bir kullanıcının özelliklerini temsil eden ad değer çiftleridir.</span><span class="sxs-lookup"><span data-stu-id="a8471-417">Claims are name value pairs that represent properties of an authenticated user.</span></span> <span data-ttu-id="a8471-418">Örneğin, kullanıcıların çalışan numarasını bir talep olarak saklayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-418">For example, you might store users' employee number as a claim.</span></span> <span data-ttu-id="a8471-419">Talepler, yetkilendirme ilkelerinin bir parçası olarak kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-419">Claims can then be used as part of authorization policies.</span></span> <span data-ttu-id="a8471-420">Bu örnekte gösterildiği gibi "EmployeeNumber" adlı bir talebin varlığını gerektiren "EmployeeOnly" adlı bir ilke oluşturabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="a8471-420">You could create a policy called "EmployeeOnly" that requires the existence of a claim called "EmployeeNumber", as shown in this example:</span></span>

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc();
    services.AddAuthorization(options =>
    {
        options.AddPolicy("EmployeeOnly", policy => policy.RequireClaim("EmployeeNumber"));
    });
}
```

<span data-ttu-id="a8471-421">Bu ilke daha sonra \[ \] yukarıda açıklandığı gibi herhangi bir denetleyiciyi ve/veya eylemi korumak için yetkilendir özniteliğiyle birlikte kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-421">This policy could then be used with the \[Authorize\] attribute to protect any controller and/or action, as described above.</span></span>

#### <a name="securing-web-apis"></a><span data-ttu-id="a8471-422">Web API 'Lerinin güvenliğini sağlama</span><span class="sxs-lookup"><span data-stu-id="a8471-422">Securing web APIs</span></span>

<span data-ttu-id="a8471-423">Çoğu Web API 'si, belirteç tabanlı bir kimlik doğrulama sistemi uygulamalıdır.</span><span class="sxs-lookup"><span data-stu-id="a8471-423">Most web APIs should implement a token-based authentication system.</span></span> <span data-ttu-id="a8471-424">Belirteç kimlik doğrulaması durum bilgisiz ve ölçeklenebilir olacak şekilde tasarlandı.</span><span class="sxs-lookup"><span data-stu-id="a8471-424">Token authentication is stateless and designed to be scalable.</span></span> <span data-ttu-id="a8471-425">Belirteç tabanlı bir kimlik doğrulama sisteminde, istemci ilk olarak kimlik doğrulama sağlayıcısıyla kimlik doğrulaması yapması gerekir.</span><span class="sxs-lookup"><span data-stu-id="a8471-425">In a token-based authentication system, the client must first authenticate with the authentication provider.</span></span> <span data-ttu-id="a8471-426">Başarılı olursa, istemciye yalnızca şifreli olarak anlamlı bir karakter dizesi olan bir belirteç verilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-426">If successful, the client is issued a token, which is simply a cryptographically meaningful string of characters.</span></span> <span data-ttu-id="a8471-427">Belirteçler için en yaygın biçim JSON Web Token veya JWT (genellikle "parça" olarak belirlenir).</span><span class="sxs-lookup"><span data-stu-id="a8471-427">The most common format for tokens is JSON Web Token, or JWT (often pronounced "jot").</span></span> <span data-ttu-id="a8471-428">İstemcinin bir API 'ye istek vermesi gerektiğinde, bu belirteci istek üzerine bir başlık olarak ekler.</span><span class="sxs-lookup"><span data-stu-id="a8471-428">When the client then needs to issue a request to an API, it adds this token as a header on the request.</span></span> <span data-ttu-id="a8471-429">Sunucu daha sonra isteği tamamlamadan önce istek üstbilgisinde bulunan belirteci doğrular.</span><span class="sxs-lookup"><span data-stu-id="a8471-429">The server then validates the token found in the request header before completing the request.</span></span> <span data-ttu-id="a8471-430">Şekil 7-4 bu işlemi gösterir.</span><span class="sxs-lookup"><span data-stu-id="a8471-430">Figure 7-4 demonstrates this process.</span></span>

![TokenAuth](./media/image7-4.png)

<span data-ttu-id="a8471-432">**Şekil 7-4.**</span><span class="sxs-lookup"><span data-stu-id="a8471-432">**Figure 7-4.**</span></span> <span data-ttu-id="a8471-433">Web API 'Leri için belirteç tabanlı kimlik doğrulaması.</span><span class="sxs-lookup"><span data-stu-id="a8471-433">Token-based authentication for Web APIs.</span></span>

<span data-ttu-id="a8471-434">Kendi kimlik doğrulama hizmetinizi oluşturabilir, Azure AD ve OAuth ile tümleştirilebilir veya [IdentityServer](https://github.com/IdentityServer)gibi açık kaynaklı bir aracı kullanarak bir hizmet uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-434">You can create your own authentication service, integrate with Azure AD and OAuth, or implement a service using an open-source tool like [IdentityServer](https://github.com/IdentityServer).</span></span>

<span data-ttu-id="a8471-435">JWT belirteçleri Kullanıcı hakkında, istemci veya sunucu üzerinde okunabilen talepler ekleyebilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-435">JWT tokens can embed claims about the user, which can be read on the client or server.</span></span> <span data-ttu-id="a8471-436">Bir JWT belirtecinin içeriğini görüntülemek için [JWT.io](https://jwt.io/) gibi bir araç kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-436">You can use a tool like [jwt.io](https://jwt.io/) to view the contents of a JWT token.</span></span> <span data-ttu-id="a8471-437">İçerikleri kolayca okunduğundan, gizli verileri JTW belirteçlerinde parolalar veya anahtarlar gibi depolamayın.</span><span class="sxs-lookup"><span data-stu-id="a8471-437">Do not store sensitive data like passwords or keys in JTW tokens, since their contents are easily read.</span></span>

<span data-ttu-id="a8471-438">SPA belirteçlerini SPA veya Blazor WebAssembly uygulamalarla kullanırken, belirteci istemcide bir yere depolamanız ve sonra her API çağrısına eklemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="a8471-438">When using JWT tokens with SPA or Blazor WebAssembly applications, you must store the token somewhere on the client and then add it to every API call.</span></span> <span data-ttu-id="a8471-439">Aşağıdaki kodun gösterdiği gibi, bu genellikle üst bilgi olarak yapılır:</span><span class="sxs-lookup"><span data-stu-id="a8471-439">This is typically done as a header, as the following code demonstrates:</span></span>

```csharp
// AuthService.cs in BlazorAdmin project of eShopOnWeb
private async Task SetAuthorizationHeader()
{
    var token = await GetToken();
    _httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", token);
}
```

<span data-ttu-id="a8471-440">Yukarıdaki yöntemi çağırdıktan sonra, ile yapılan isteklere `_httpClient` isteğin üst bilgilerine gömülü ve sunucu tarafı API 'sinin istek için kimlik doğrulaması yapmasına ve yetkilendirilemez.</span><span class="sxs-lookup"><span data-stu-id="a8471-440">After calling the above method, requests made with the `_httpClient` will have the token embedded in the request's headers, allowing the server-side API to authenticate and authorize the request.</span></span>

#### <a name="custom-security"></a><span data-ttu-id="a8471-441">Özel Güvenlik</span><span class="sxs-lookup"><span data-stu-id="a8471-441">Custom Security</span></span>

<span data-ttu-id="a8471-442">Özellikle şifreleme, Kullanıcı üyeliği veya belirteç oluşturma sisteminin "kendi kendine alınması" konusunda dikkatli olun.</span><span class="sxs-lookup"><span data-stu-id="a8471-442">Be especially careful about "rolling your own" implementation of cryptography, user membership, or token generation system.</span></span> <span data-ttu-id="a8471-443">Çok sayıda ticari ve açık kaynaklı alternatif vardır ve bu, bir özel uygulamadan daha iyi güvenliğe sahip olur.</span><span class="sxs-lookup"><span data-stu-id="a8471-443">There are many commercial and open-source alternatives available, which will almost certainly have better security than a custom implementation.</span></span>

> ### <a name="references--security"></a><span data-ttu-id="a8471-444">Başvurular – güvenlik</span><span class="sxs-lookup"><span data-stu-id="a8471-444">References – Security</span></span>
>
> - <span data-ttu-id="a8471-445">**Güvenlik belgelerine genel bakış**</span><span class="sxs-lookup"><span data-stu-id="a8471-445">**Security Docs Overview**</span></span>  
>   <https://docs.microsoft.com/aspnet/core/security/>
> - <span data-ttu-id="a8471-446">**ASP.NET Core uygulamasında SSL zorlama**</span><span class="sxs-lookup"><span data-stu-id="a8471-446">**Enforcing SSL in an ASP.NET Core App**</span></span>  
>   <https://docs.microsoft.com/aspnet/core/security/enforcing-ssl>
> - <span data-ttu-id="a8471-447">**Kimliğe giriş**</span><span class="sxs-lookup"><span data-stu-id="a8471-447">**Introduction to Identity**</span></span>  
>   <https://docs.microsoft.com/aspnet/core/security/authentication/identity>
> - <span data-ttu-id="a8471-448">**Yetkilendirmeye giriş**</span><span class="sxs-lookup"><span data-stu-id="a8471-448">**Introduction to Authorization**</span></span>  
>   <https://docs.microsoft.com/aspnet/core/security/authorization/introduction>
> - <span data-ttu-id="a8471-449">**Azure App Service’te API Apps için Kimlik Doğrulama ve Yetkilendirme**</span><span class="sxs-lookup"><span data-stu-id="a8471-449">**Authentication and Authorization for API Apps in Azure App Service**</span></span>  
>   <https://docs.microsoft.com/azure/app-service-api/app-service-api-authentication>
> - <span data-ttu-id="a8471-450">**Kimlik Sunucusu**</span><span class="sxs-lookup"><span data-stu-id="a8471-450">**Identity Server**</span></span>  
>   <https://github.com/IdentityServer>

## <a name="client-communication"></a><span data-ttu-id="a8471-451">İstemci iletişimi</span><span class="sxs-lookup"><span data-stu-id="a8471-451">Client communication</span></span>

<span data-ttu-id="a8471-452">Web API 'Leri aracılığıyla sayfalara hizmet vermeye ve veri isteklerine yanıt vermeye ek olarak, ASP.NET Core uygulamalar doğrudan bağlantılı istemcilerle iletişim kurabilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-452">In addition to serving pages and responding to requests for data via web APIs, ASP.NET Core apps can communicate directly with connected clients.</span></span> <span data-ttu-id="a8471-453">Bu giden iletişim, en yaygın WebSockets olmak üzere çeşitli taşıma teknolojileri kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-453">This outbound communication can use a variety of transport technologies, the most common being WebSockets.</span></span> <span data-ttu-id="a8471-454">ASP.NET Core SignalR, uygulamalarınıza gerçek zamanlı sunucudan istemciye iletişim işlevselliği eklemeyi basit hale getiren bir kitaplıktır.</span><span class="sxs-lookup"><span data-stu-id="a8471-454">ASP.NET Core SignalR is a library that makes it simple to add real-time server-to-client communication functionality to your applications.</span></span> <span data-ttu-id="a8471-455">SignalR, WebSockets dahil olmak üzere çeşitli taşıma teknolojilerini destekler ve geliştiriciden birçok uygulama ayrıntılarını soyutlar.</span><span class="sxs-lookup"><span data-stu-id="a8471-455">SignalR supports a variety of transport technologies, including WebSockets, and abstracts away many of the implementation details from the developer.</span></span>

<span data-ttu-id="a8471-456">WebSockets doğrudan veya diğer tekniklerin kullanılması halinde gerçek zamanlı istemci iletişimi, çeşitli uygulama senaryolarında yararlı olur.</span><span class="sxs-lookup"><span data-stu-id="a8471-456">Real-time client communication, whether using WebSockets directly or other techniques, are useful in a variety of application scenarios.</span></span> <span data-ttu-id="a8471-457">Bazı örnekler:</span><span class="sxs-lookup"><span data-stu-id="a8471-457">Some examples include:</span></span>

- <span data-ttu-id="a8471-458">Canlı sohbet odası uygulamaları</span><span class="sxs-lookup"><span data-stu-id="a8471-458">Live chat room applications</span></span>

- <span data-ttu-id="a8471-459">Uygulamaları izleme</span><span class="sxs-lookup"><span data-stu-id="a8471-459">Monitoring applications</span></span>

- <span data-ttu-id="a8471-460">İş ilerleme durumu güncelleştirmeleri</span><span class="sxs-lookup"><span data-stu-id="a8471-460">Job progress updates</span></span>

- <span data-ttu-id="a8471-461">Bildirimler</span><span class="sxs-lookup"><span data-stu-id="a8471-461">Notifications</span></span>

- <span data-ttu-id="a8471-462">Etkileşimli form uygulamaları</span><span class="sxs-lookup"><span data-stu-id="a8471-462">Interactive forms applications</span></span>

<span data-ttu-id="a8471-463">Uygulamalarınıza istemci iletişimi oluştururken genellikle iki bileşen vardır:</span><span class="sxs-lookup"><span data-stu-id="a8471-463">When building client communication into your applications, there are typically two components:</span></span>

- <span data-ttu-id="a8471-464">Sunucu tarafı bağlantı Yöneticisi (SignalR hub, WebSocketManager WebSocketHandler)</span><span class="sxs-lookup"><span data-stu-id="a8471-464">Server-side connection manager (SignalR Hub, WebSocketManager WebSocketHandler)</span></span>

- <span data-ttu-id="a8471-465">İstemci tarafı kitaplığı</span><span class="sxs-lookup"><span data-stu-id="a8471-465">Client-side library</span></span>

<span data-ttu-id="a8471-466">İstemciler tarayıcılarla sınırlı değildir: mobil uygulamalar, konsol uygulamaları ve diğer yerel uygulamalar, SignalR/WebSockets kullanarak da iletişim kurabilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-466">Clients aren't limited to browsers – mobile apps, console apps, and other native apps can also communicate using SignalR/WebSockets.</span></span> <span data-ttu-id="a8471-467">Aşağıdaki basit program, bir sohbet uygulamasına gönderilen tüm içeriği bir WebSocketManager örnek uygulamasının bir parçası olarak konsola bildirir:</span><span class="sxs-lookup"><span data-stu-id="a8471-467">The following simple program echoes all content sent to a chat application to the console, as part of a WebSocketManager sample application:</span></span>

```csharp
public class Program
{
    private static Connection _connection;
    public static void Main(string[] args)
    {
        StartConnectionAsync();
        _connection.On("receiveMessage", (arguments) =>
        {
            Console.WriteLine($"{arguments[0]} said: {arguments[1]}");
        });
        Console.ReadLine();
        StopConnectionAsync();
    }

    public static async Task StartConnectionAsync()
    {
        _connection = new Connection();
        await _connection.StartConnectionAsync("ws://localhost:65110/chat");
    }

    public static async Task StopConnectionAsync()
    {
        await _connection.StopConnectionAsync();
    }
}
```

<span data-ttu-id="a8471-468">Uygulamalarınızın istemci uygulamalarıyla doğrudan iletişim kurmasına dikkat edin ve gerçek zamanlı iletişimin uygulamanızın kullanıcı deneyimini iyileştirip geliştirmeyeceğini göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="a8471-468">Consider ways in which your applications communicate directly with client applications, and consider whether real-time communication would improve your app's user experience.</span></span>

> ### <a name="references--client-communication"></a><span data-ttu-id="a8471-469">Başvurular – Istemci Iletişimi</span><span class="sxs-lookup"><span data-stu-id="a8471-469">References – Client Communication</span></span>
>
> - <span data-ttu-id="a8471-470">**ASP.NET Core SignalR**</span><span class="sxs-lookup"><span data-stu-id="a8471-470">**ASP.NET Core SignalR**</span></span>  
>   <https://github.com/dotnet/aspnetcore/tree/master/src/SignalR>
> - <span data-ttu-id="a8471-471">**WebSocket Yöneticisi**</span><span class="sxs-lookup"><span data-stu-id="a8471-471">**WebSocket Manager**</span></span>  
>   <https://github.com/radu-matei/websocket-manager>

## <a name="domain-driven-design--should-you-apply-it"></a><span data-ttu-id="a8471-472">Etki alanı odaklı tasarım – uygulamanız gerekir mi?</span><span class="sxs-lookup"><span data-stu-id="a8471-472">Domain-driven design – Should you apply it?</span></span>

<span data-ttu-id="a8471-473">Etki alanı odaklı tasarım (DDD), _iş etki alanı_üzerinde odaklanan bir yazılım oluşturmaya yönelik çevik bir yaklaşımdır.</span><span class="sxs-lookup"><span data-stu-id="a8471-473">Domain-Driven Design (DDD) is an agile approach to building software that emphasizes focusing on the _business domain_.</span></span> <span data-ttu-id="a8471-474">Gerçek dünya sisteminin nasıl çalıştığı geliştiricilerle ilişkilendirilebilen iş etki alanı uzmanlarındaki iletişim ve etkileşime yönelik ağır bir vurgu koyar.</span><span class="sxs-lookup"><span data-stu-id="a8471-474">It places a heavy emphasis on communication and interaction with business domain expert(s) who can relate to the developers how the real-world system works.</span></span> <span data-ttu-id="a8471-475">Örneğin, hisse senedi ilgilenen bir sistem oluşturuyorsanız, etki alanı uzmanı deneyimli bir hisse senedi Aracısı olabilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-475">For example, if you're building a system that handles stock trades, your domain expert might be an experienced stock broker.</span></span> <span data-ttu-id="a8471-476">DDD, büyük ve karmaşık iş sorunlarına yönelik olarak tasarlanmıştır ve genellikle daha küçük, daha basit uygulamalar için uygun değildir. bu da, etki alanının anlaşılmasından ve modellenmesi için yatırım yapın.</span><span class="sxs-lookup"><span data-stu-id="a8471-476">DDD is designed to address large, complex business problems, and is often not appropriate for smaller, simpler applications, as the investment in understanding and modeling the domain is not worth it.</span></span>

<span data-ttu-id="a8471-477">Bir DDD yaklaşımına göre yazılım oluştururken ekibiniz (Teknik olmayan hissedarlar ve katkıda bulunanlar dahil), sorun alanı için bir _ubititous dili_ geliştirmelidir.</span><span class="sxs-lookup"><span data-stu-id="a8471-477">When building software following a DDD approach, your team (including non-technical stakeholders and contributors) should develop a _ubiquitous language_ for the problem space.</span></span> <span data-ttu-id="a8471-478">Diğer bir deyişle, modellenen gerçek dünya kavramı, yazılım eşdeğeri ve kavramı kalıcı hale getirmek için mevcut olabilecek tüm yapılar için aynı terminoloji kullanılmalıdır (örneğin, veritabanı tabloları).</span><span class="sxs-lookup"><span data-stu-id="a8471-478">That is, the same terminology should be used for the real-world concept being modeled, the software equivalent, and any structures that might exist to persist the concept (for example, database tables).</span></span> <span data-ttu-id="a8471-479">Bu nedenle, ubititous dilinde açıklanan kavramlar, _etki alanı modelinizin_temelini oluşturmalıdır.</span><span class="sxs-lookup"><span data-stu-id="a8471-479">Thus, the concepts described in the ubiquitous language should form the basis for your _domain model_.</span></span>

<span data-ttu-id="a8471-480">Etki alanı modeliniz, sistemin davranışını temsil eden birbirleriyle etkileşim kuran nesneler içerir.</span><span class="sxs-lookup"><span data-stu-id="a8471-480">Your domain model comprises objects that interact with one another to represent the behavior of the system.</span></span> <span data-ttu-id="a8471-481">Bu nesneler aşağıdaki kategorilere ayrılabilir:</span><span class="sxs-lookup"><span data-stu-id="a8471-481">These objects may fall into the following categories:</span></span>

- <span data-ttu-id="a8471-482">[Varlıklar](https://deviq.com/entity/), bir kimlik iş parçacığına sahip nesneleri temsil eder.</span><span class="sxs-lookup"><span data-stu-id="a8471-482">[Entities](https://deviq.com/entity/), which represent objects with a thread of identity.</span></span> <span data-ttu-id="a8471-483">Varlıklar genellikle daha sonra alınabilebilecekleri bir anahtarla kalıcı olarak depolanır.</span><span class="sxs-lookup"><span data-stu-id="a8471-483">Entities are typically stored in persistence with a key by which they can later be retrieved.</span></span>

- <span data-ttu-id="a8471-484">Birim olarak kalıcı olması gereken nesne gruplarını temsil eden [toplamalar](https://deviq.com/aggregate-pattern/).</span><span class="sxs-lookup"><span data-stu-id="a8471-484">[Aggregates](https://deviq.com/aggregate-pattern/), which represent groups of objects that should be persisted as a unit.</span></span>

- <span data-ttu-id="a8471-485">[Değer nesneleri](https://deviq.com/value-object/), özellik değerlerinin toplamının temel alınarak karşılaştırılabilen kavramları temsil eder.</span><span class="sxs-lookup"><span data-stu-id="a8471-485">[Value objects](https://deviq.com/value-object/), which represent concepts that can be compared on the basis of the sum of their property values.</span></span> <span data-ttu-id="a8471-486">Örneğin, bir başlangıç ve bitiş tarihinden oluşan Terterange.</span><span class="sxs-lookup"><span data-stu-id="a8471-486">For example, DateRange consisting of a start and end date.</span></span>

- <span data-ttu-id="a8471-487">Sistem içindeki diğer bölümleri ilgilendiren işlemleri temsil eden [etki alanı olayları](https://martinfowler.com/eaaDev/DomainEvent.html).</span><span class="sxs-lookup"><span data-stu-id="a8471-487">[Domain events](https://martinfowler.com/eaaDev/DomainEvent.html), which represent things happening within the system that are of interest to other parts of the system.</span></span>

<span data-ttu-id="a8471-488">DDD etki alanı modeli, model içerisindeki karmaşık davranışı kapsüllemelidir.</span><span class="sxs-lookup"><span data-stu-id="a8471-488">A DDD domain model should encapsulate complex behavior within the model.</span></span> <span data-ttu-id="a8471-489">Varlıklar, özellikle de yalnızca özellik koleksiyonları olmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="a8471-489">Entities, in particular, should not merely be collections of properties.</span></span> <span data-ttu-id="a8471-490">Etki alanı modelinde davranış olmadığında ve yalnızca sistemin durumunu temsil ettiğinde, bu, DDD 'da istenmeyen bir [anemik modeli](https://deviq.com/anemic-model/)olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-490">When the domain model lacks behavior and merely represents the state of the system, it is said to be an [anemic model](https://deviq.com/anemic-model/), which is undesirable in DDD.</span></span>

<span data-ttu-id="a8471-491">Bu model türlerine ek olarak, DDD genellikle çeşitli desenler kullanır:</span><span class="sxs-lookup"><span data-stu-id="a8471-491">In addition to these model types, DDD typically employs a variety of patterns:</span></span>

- <span data-ttu-id="a8471-492">[Depolama](https://deviq.com/repository-pattern/), kalıcılık ayrıntılarını soyutlayan.</span><span class="sxs-lookup"><span data-stu-id="a8471-492">[Repository](https://deviq.com/repository-pattern/), for abstracting persistence details.</span></span>

- <span data-ttu-id="a8471-493">Karmaşık nesne oluşturmayı kapsüllemek için [fabrika](https://en.wikipedia.org/wiki/Factory_method_pattern).</span><span class="sxs-lookup"><span data-stu-id="a8471-493">[Factory](https://en.wikipedia.org/wiki/Factory_method_pattern), for encapsulating complex object creation.</span></span>

- <span data-ttu-id="a8471-494">Karmaşık davranışı ve/veya altyapı uygulama ayrıntılarını kapsüllemek için [Hizmetler](http://gorodinski.com/blog/2012/04/14/services-in-domain-driven-design-ddd/).</span><span class="sxs-lookup"><span data-stu-id="a8471-494">[Services](http://gorodinski.com/blog/2012/04/14/services-in-domain-driven-design-ddd/), for encapsulating complex behavior and/or infrastructure implementation details.</span></span>

- <span data-ttu-id="a8471-495">[Komutu](https://en.wikipedia.org/wiki/Command_pattern), komut veren komutları ve komutun kendisini yürütmek için.</span><span class="sxs-lookup"><span data-stu-id="a8471-495">[Command](https://en.wikipedia.org/wiki/Command_pattern), for decoupling issuing commands and executing the command itself.</span></span>

- <span data-ttu-id="a8471-496">Sorgu ayrıntılarını kapsüllemek için [belirtimi](https://deviq.com/specification-pattern/).</span><span class="sxs-lookup"><span data-stu-id="a8471-496">[Specification](https://deviq.com/specification-pattern/), for encapsulating query details.</span></span>

<span data-ttu-id="a8471-497">DDD Ayrıca, daha önce ele alınan temiz mimarinin kullanımını önerir. böylece, birim testleri kullanılarak kolayca doğrulanabilen, gevşek bir kapsülleme, kapsülleme ve kod sağlar.</span><span class="sxs-lookup"><span data-stu-id="a8471-497">DDD also recommends the use of the Clean Architecture discussed previously, allowing for loose coupling, encapsulation, and code that can easily be verified using unit tests.</span></span>

### <a name="when-should-you-apply-ddd"></a><span data-ttu-id="a8471-498">DDD ne zaman uygulanır?</span><span class="sxs-lookup"><span data-stu-id="a8471-498">When should you apply DDD</span></span>

<span data-ttu-id="a8471-499">DDD, önemli iş (yalnızca teknik değil) karmaşıklığa sahip büyük uygulamalar için uygundur.</span><span class="sxs-lookup"><span data-stu-id="a8471-499">DDD is well suited to large applications with significant business (not just technical) complexity.</span></span> <span data-ttu-id="a8471-500">Uygulamanın etki alanı uzmanları hakkında bilgi sahibi olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="a8471-500">The application should require the knowledge of domain experts.</span></span> <span data-ttu-id="a8471-501">Veri depolarından çeşitli kayıtların geçerli durumunu depolamanın ve almanın ötesinde iş kurallarını ve etkileşimleri temsil eden etki alanı modelinin kendisinde önemli bir davranış olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="a8471-501">There should be significant behavior in the domain model itself, representing business rules and interactions beyond simply storing and retrieving the current state of various records from data stores.</span></span>

### <a name="when-shouldnt-you-apply-ddd"></a><span data-ttu-id="a8471-502">DDD ne zaman uygulamanız gerekir</span><span class="sxs-lookup"><span data-stu-id="a8471-502">When shouldn't you apply DDD</span></span>

<span data-ttu-id="a8471-503">DDD, modelleme, mimari ve iletişim için, aslında yalnızca CRUD (oluşturma/okuma/güncelleştirme/silme) olan daha küçük uygulamalar veya uygulamalar için gerekmeyebilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-503">DDD involves investments in modeling, architecture, and communication that may not be warranted for smaller applications or applications that are essentially just CRUD (create/read/update/delete).</span></span> <span data-ttu-id="a8471-504">Uygulamanızı DDD ' dan sonra yaklaşımınızı tercih ediyorsanız, ancak etki alanınızı hiçbir davranış olmadan bir anemik modeli olduğunu fark ederseniz, yaklaşımınızı yeniden düşünmek zorunda kalabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-504">If you choose to approach your application following DDD, but find that your domain has an anemic model with no behavior, you may need to rethink your approach.</span></span> <span data-ttu-id="a8471-505">Uygulamanız DDD gerektirebilir veya uygulamanızın, veritabanınız veya Kullanıcı arabiriminiz yerine etki alanı modelinde iş mantığını kapsüllemek üzere yeniden düzenlenmesi için yardıma ihtiyacınız olabilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-505">Either your application may not need DDD, or you may need assistance refactoring your application to encapsulate business logic in the domain model, rather than in your database or user interface.</span></span>

<span data-ttu-id="a8471-506">Karma yaklaşım yalnızca, uygulamanın işlem veya daha fazla karmaşık alanı için DDD, ancak uygulamanın daha basit CRUD veya salt okunurdur.</span><span class="sxs-lookup"><span data-stu-id="a8471-506">A hybrid approach would be to only use DDD for the transactional or more complex areas of the application, but not for simpler CRUD or read-only portions of the application.</span></span> <span data-ttu-id="a8471-507">Örneğin, bir raporu görüntüleyecek veya bir Pano için verileri görselleştirmeye yönelik verileri sorguladığınız takdirde bir toplamanın kısıtlamalarına gerek yoktur.</span><span class="sxs-lookup"><span data-stu-id="a8471-507">For instance, you don't need the constraints of an Aggregate if you're querying data to display a report or to visualize data for a dashboard.</span></span> <span data-ttu-id="a8471-508">Bu tür gereksinimlere yönelik ayrı, daha basit bir okuma modeline sahip olmak mükemmel bir şekilde kabul edilebilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-508">It's perfectly acceptable to have a separate, simpler read model for such requirements.</span></span>

> ### <a name="references--domain-driven-design"></a><span data-ttu-id="a8471-509">Başvurular – etki alanı odaklı tasarım</span><span class="sxs-lookup"><span data-stu-id="a8471-509">References – Domain-Driven Design</span></span>
>
> - <span data-ttu-id="a8471-510">**Düz Ingilizce (StackOverflow yanıtı)**</span><span class="sxs-lookup"><span data-stu-id="a8471-510">**DDD in Plain English (StackOverflow Answer)**</span></span>  
>   <https://stackoverflow.com/questions/1222392/can-someone-explain-domain-driven-design-ddd-in-plain-english-please/1222488#1222488>

## <a name="deployment"></a><span data-ttu-id="a8471-511">Dağıtım</span><span class="sxs-lookup"><span data-stu-id="a8471-511">Deployment</span></span>

<span data-ttu-id="a8471-512">ASP.NET Core uygulamanızın nerede barındırıldığından bağımsız olarak dağıtımı sürecinde birkaç adım vardır.</span><span class="sxs-lookup"><span data-stu-id="a8471-512">There are a few steps involved in the process of deploying your ASP.NET Core application, regardless of where it will be hosted.</span></span> <span data-ttu-id="a8471-513">İlk adım, CLI komutu kullanılarak yapılabilecek şekilde uygulamayı yayımlamaktır `dotnet publish` .</span><span class="sxs-lookup"><span data-stu-id="a8471-513">The first step is to publish the application, which can be done using the `dotnet publish` CLI command.</span></span> <span data-ttu-id="a8471-514">Bu işlem uygulamayı derler ve uygulamayı belirlenmiş bir klasöre çalıştırmak için gereken tüm dosyaları yerleştirir.</span><span class="sxs-lookup"><span data-stu-id="a8471-514">This will compile the application and place all of the files needed to run the application into a designated folder.</span></span> <span data-ttu-id="a8471-515">Visual Studio 'dan dağıtırken, bu adım sizin için otomatik olarak gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-515">When you deploy from Visual Studio, this step is performed for you automatically.</span></span> <span data-ttu-id="a8471-516">Yayımla klasörü, uygulama ve bağımlılıkları için. exe ve. dll dosyalarını içerir.</span><span class="sxs-lookup"><span data-stu-id="a8471-516">The publish folder contains .exe and .dll files for the application and its dependencies.</span></span> <span data-ttu-id="a8471-517">Bağımsız bir uygulama de .NET çalışma zamanının bir sürümünü içerir.</span><span class="sxs-lookup"><span data-stu-id="a8471-517">A self-contained application will also include a version of the .NET runtime.</span></span> <span data-ttu-id="a8471-518">ASP.NET Core uygulamalar yapılandırma dosyaları, statik istemci varlıkları ve MVC görünümlerini de içerecektir.</span><span class="sxs-lookup"><span data-stu-id="a8471-518">ASP.NET Core applications will also include configuration files, static client assets, and MVC views.</span></span>

<span data-ttu-id="a8471-519">ASP.NET Core uygulamalar, uygulama (veya sunucu) kilitlenirse sunucu önyüklendiğinde ve yeniden başlatıldığında başlatılmış olması gereken konsol uygulamalardır.</span><span class="sxs-lookup"><span data-stu-id="a8471-519">ASP.NET Core applications are console applications that must be started when the server boots and restarted if the application (or server) crashes.</span></span> <span data-ttu-id="a8471-520">İşlem Yöneticisi, bu işlemi otomatikleştirmek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-520">A process manager can be used to automate this process.</span></span> <span data-ttu-id="a8471-521">ASP.NET Core için en yaygın işlem yöneticileri, Linux ve IIS ya da Windows hizmetinde Windows hizmetinde NGINX ve Apache 'tir.</span><span class="sxs-lookup"><span data-stu-id="a8471-521">The most common process managers for ASP.NET Core are Nginx and Apache on Linux and IIS or Windows Service on Windows.</span></span>

<span data-ttu-id="a8471-522">ASP.NET Core uygulamalar, bir işlem yöneticisi 'ne ek olarak ters proxy sunucusu kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-522">In addition to a process manager, ASP.NET Core applications may use a reverse proxy server.</span></span> <span data-ttu-id="a8471-523">Ters proxy sunucusu, Internet 'ten gelen HTTP isteklerini alır ve bazı ön işleme sonrasında Kestrel 'e iletir.</span><span class="sxs-lookup"><span data-stu-id="a8471-523">A reverse proxy server receives HTTP requests from the Internet and forwards them to Kestrel after some preliminary handling.</span></span> <span data-ttu-id="a8471-524">Ters proxy sunucuları, uygulama için bir güvenlik katmanı sağlar.</span><span class="sxs-lookup"><span data-stu-id="a8471-524">Reverse proxy servers provide a layer of security for the application.</span></span> <span data-ttu-id="a8471-525">Kestrel aynı bağlantı noktasında birden fazla uygulamanın barındırılmasını desteklemez, bu nedenle konak üstbilgileri gibi teknikler aynı bağlantı noktasında ve IP adresinde birden çok uygulamanın barındırılmasına olanak tanımak için kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="a8471-525">Kestrel also doesn't support hosting multiple applications on the same port, so techniques like host headers cannot be used with it to enable hosting multiple applications on the same port and IP address.</span></span>

![Kestrel to Internet](./media/image7-5.png)

<span data-ttu-id="a8471-527">**Şekil 7-5**.</span><span class="sxs-lookup"><span data-stu-id="a8471-527">**Figure 7-5**.</span></span> <span data-ttu-id="a8471-528">Bir ters proxy sunucusu arkasında Kestrel içinde barındırılan ASP.NET</span><span class="sxs-lookup"><span data-stu-id="a8471-528">ASP.NET hosted in Kestrel behind a reverse proxy server</span></span>

<span data-ttu-id="a8471-529">Geriye doğru bir proxy 'nin, SSL/HTTPS kullanarak birden çok uygulamayı güvenli hale getirmek için yararlı olabilecek başka bir senaryo.</span><span class="sxs-lookup"><span data-stu-id="a8471-529">Another scenario in which a reverse proxy can be helpful is to secure multiple applications using SSL/HTTPS.</span></span> <span data-ttu-id="a8471-530">Bu durumda, yalnızca ters proxy 'nin SSL yapılandırması gerekir.</span><span class="sxs-lookup"><span data-stu-id="a8471-530">In this case, only the reverse proxy would need to have SSL configured.</span></span> <span data-ttu-id="a8471-531">Şekil 7-6 ' de gösterildiği gibi, ters proxy sunucusu ve Kestrel arasındaki iletişim HTTP üzerinden gerçekleşmeyebilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-531">Communication between the reverse proxy server and Kestrel could take place over HTTP, as shown in Figure 7-6.</span></span>

![ASP.NET, HTTPS ile güvenli bir ters proxy sunucusu arkasında barındırılan](./media/image7-6.png)

<span data-ttu-id="a8471-533">**Şekil 7-6**.</span><span class="sxs-lookup"><span data-stu-id="a8471-533">**Figure 7-6**.</span></span> <span data-ttu-id="a8471-534">ASP.NET, HTTPS ile güvenli bir ters proxy sunucusu arkasında barındırılan</span><span class="sxs-lookup"><span data-stu-id="a8471-534">ASP.NET hosted behind an HTTPS-secured reverse proxy server</span></span>

<span data-ttu-id="a8471-535">Giderek popüler bir yaklaşım, ASP.NET Core uygulamanızı bir Docker kapsayıcısında barındırırken, daha sonra yerel olarak barındırılabilir veya bulut tabanlı barındırma için Azure 'a dağıtılabilir.</span><span class="sxs-lookup"><span data-stu-id="a8471-535">An increasingly popular approach is to host your ASP.NET Core application in a Docker container, which then can be hosted locally or deployed to Azure for cloud-based hosting.</span></span> <span data-ttu-id="a8471-536">Docker kapsayıcısı, Kestrel üzerinde çalışan uygulama kodunuzu içerebilir ve yukarıda gösterildiği gibi bir ters proxy sunucusunun arkasında dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="a8471-536">The Docker container could contain your application code, running on Kestrel, and would be deployed behind a reverse proxy server, as shown above.</span></span>

<span data-ttu-id="a8471-537">Uygulamanızı Azure 'da barındırıyorsanız, çeşitli hizmetler sağlamak için adanmış bir Sanal Gereç olarak Microsoft Azure Application Gateway kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a8471-537">If you're hosting your application on Azure, you can use Microsoft Azure Application Gateway as a dedicated virtual appliance to provide several services.</span></span> <span data-ttu-id="a8471-538">Tek tek uygulamalar için ters proxy olarak davranmaya ek olarak, Application Gateway aşağıdaki özellikleri de sunabilir:</span><span class="sxs-lookup"><span data-stu-id="a8471-538">In addition to acting as a reverse proxy for individual applications, Application Gateway can also offer the following features:</span></span>

- <span data-ttu-id="a8471-539">HTTP yük dengelemesi</span><span class="sxs-lookup"><span data-stu-id="a8471-539">HTTP load balancing</span></span>

- <span data-ttu-id="a8471-540">SSL boşaltması (yalnızca Internet 'e SSL)</span><span class="sxs-lookup"><span data-stu-id="a8471-540">SSL offload (SSL only to Internet)</span></span>

- <span data-ttu-id="a8471-541">Uçtan uca SSL</span><span class="sxs-lookup"><span data-stu-id="a8471-541">End to End SSL</span></span>

- <span data-ttu-id="a8471-542">Çoklu site yönlendirme (tek bir Application Gateway en fazla 20 site birleştirme)</span><span class="sxs-lookup"><span data-stu-id="a8471-542">Multi-site routing (consolidate up to 20 sites on a single Application Gateway)</span></span>

- <span data-ttu-id="a8471-543">Web uygulaması güvenlik duvarı</span><span class="sxs-lookup"><span data-stu-id="a8471-543">Web application firewall</span></span>

- <span data-ttu-id="a8471-544">WebSocket desteği</span><span class="sxs-lookup"><span data-stu-id="a8471-544">Websocket support</span></span>

- <span data-ttu-id="a8471-545">Gelişmiş Tanılamalar</span><span class="sxs-lookup"><span data-stu-id="a8471-545">Advanced diagnostics</span></span>

<span data-ttu-id="a8471-546">_[Bölüm 10](development-process-for-azure.md)' da Azure dağıtım seçenekleri hakkında daha fazla bilgi edinin._</span><span class="sxs-lookup"><span data-stu-id="a8471-546">_Learn more about Azure deployment options in [Chapter 10](development-process-for-azure.md)._</span></span>

> ### <a name="references--deployment"></a><span data-ttu-id="a8471-547">Başvurular – dağıtım</span><span class="sxs-lookup"><span data-stu-id="a8471-547">References – Deployment</span></span>
>
> - <span data-ttu-id="a8471-548">**Barındırma ve dağıtıma genel bakış**</span><span class="sxs-lookup"><span data-stu-id="a8471-548">**Hosting and Deployment Overview**</span></span>  
>   <https://docs.microsoft.com/aspnet/core/publishing/>
> - <span data-ttu-id="a8471-549">**Ters ara sunucu ile Kestrel ne zaman kullanılır?**</span><span class="sxs-lookup"><span data-stu-id="a8471-549">**When to use Kestrel with a reverse proxy**</span></span>  
>   <https://docs.microsoft.com/aspnet/core/fundamentals/servers/kestrel#when-to-use-kestrel-with-a-reverse-proxy>
> - <span data-ttu-id="a8471-550">**Docker 'da uygulamaları ASP.NET Core barındırma**</span><span class="sxs-lookup"><span data-stu-id="a8471-550">**Host ASP.NET Core apps in Docker**</span></span>  
>   <https://docs.microsoft.com/aspnet/core/publishing/docker>
> - <span data-ttu-id="a8471-551">**Azure Application Gateway 'ye giriş**</span><span class="sxs-lookup"><span data-stu-id="a8471-551">**Introducing Azure Application Gateway**</span></span>  
>   <https://docs.microsoft.com/azure/application-gateway/application-gateway-introduction>

>[!div class="step-by-step"]
><span data-ttu-id="a8471-552">[Önceki](common-client-side-web-technologies.md) 
> [Sonraki](work-with-data-in-asp-net-core-apps.md)</span><span class="sxs-lookup"><span data-stu-id="a8471-552">[Previous](common-client-side-web-technologies.md)
[Next](work-with-data-in-asp-net-core-apps.md)</span></span>
