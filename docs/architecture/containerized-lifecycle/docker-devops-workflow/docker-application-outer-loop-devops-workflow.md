---
title: Bir Docker uygulaması için dış döngü DevOps iş akışındaki adımlar
description: DevOps iş akışının "dıştaki döngüsü" adımlarını öğrenin
ms.date: 08/06/2020
ms.openlocfilehash: 82a45c8669812580623811e18cc55f55f45cb6d3
ms.sourcegitcommit: e0803b8975d3eb12e735a5d07637020dd6dac5ef
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 09/01/2020
ms.locfileid: "89271913"
---
# <a name="steps-in-the-outer-loop-devops-workflow-for-a-docker-application"></a><span data-ttu-id="9bfb1-103">Bir Docker uygulaması için dış döngü DevOps iş akışındaki adımlar</span><span class="sxs-lookup"><span data-stu-id="9bfb1-103">Steps in the outer-loop DevOps workflow for a Docker application</span></span>

<span data-ttu-id="9bfb1-104">Şekil 5-1, DevOps dış döngüsü iş akışından oluşan adımların uçtan uca bir listesini sunar.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-104">Figure 5-1 presents an end-to-end depiction of the steps comprising the DevOps outer-loop workflow.</span></span> <span data-ttu-id="9bfb1-105">DevOps 'un "dıştaki döngüsünü" gösterir.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-105">It shows the "outer loop" of DevOps.</span></span> <span data-ttu-id="9bfb1-106">Kod depoya gönderildiğinde, bir CI işlem hattı başlatılır, sonra uygulamanın dağıtıldığı CD işlem hattı başlar.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-106">When code is pushed to the repo, a CI pipeline is started, then begins the CD pipeline, where the application gets deployed.</span></span> <span data-ttu-id="9bfb1-107">Dağıtılan uygulamalardan toplanan ölçümler, "iç döngü" gerçekleştiği geliştirme iş yüküne geri gönderilir, böylece geliştirme ekipleri Kullanıcı ve iş ihtiyaçlarına yanıt vermeye yönelik gerçek verilere sahip olur.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-107">Metrics collected from deployed applications are fed back into the development workload, where the "inner loop" occurs, so development teams have actual data to respond to user and business needs.</span></span>

![DevOps dış döngüsü iş akışının 6 adımını gösteren diyagram.](./media/docker-application-outer-loop-devops-workflow/overview-dev-ops-outter-loop-workflow.png)

<span data-ttu-id="9bfb1-109">**Şekil 5-1**.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-109">**Figure 5-1**.</span></span> <span data-ttu-id="9bfb1-110">Microsoft araçları ile Docker uygulamaları için DevOps dış döngüsü iş akışı</span><span class="sxs-lookup"><span data-stu-id="9bfb1-110">DevOps outer-loop workflow for Docker applications with Microsoft tools</span></span>

<span data-ttu-id="9bfb1-111">Şimdi bu adımların her birini daha ayrıntılı olarak inceleyelim.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-111">Now, let's examine each of these steps in greater detail.</span></span>

## <a name="step-1-inner-loop-development-workflow"></a><span data-ttu-id="9bfb1-112">1. Adım: Iç döngü geliştirme iş akışı</span><span class="sxs-lookup"><span data-stu-id="9bfb1-112">Step 1: Inner-loop development workflow</span></span>

<span data-ttu-id="9bfb1-113">Bu adım, Bölüm 4 ' te ayrıntılı olarak açıklanmıştır, ancak bir üst sınır, bir geliştiricinin CI ardışık düzen eylemlerini Başlatan kaynak denetimi yönetim sistemine (git gibi) kod iletmesinin ne kadar olduğunu burada bulabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-113">This step is explained in detail in Chapter 4, but, to recap, here is where the outer-loop begins, the moment at which a developer pushes code to the source control management system (like Git) initiating CI pipeline actions.</span></span>

## <a name="step-2-source-code-control-integration-and-management-with-azure-devops-services-and-git"></a><span data-ttu-id="9bfb1-114">2. Adım: Azure DevOps Services ve git ile kaynak kodu denetimi tümleştirmesi ve yönetimi</span><span class="sxs-lookup"><span data-stu-id="9bfb1-114">Step 2: Source-Code Control integration and management with Azure DevOps Services and Git</span></span>

<span data-ttu-id="9bfb1-115">Bu adımda, ekipteki farklı geliştiricilerden gelen tüm kodun birleştirilmiş bir sürümünü toplamak için bir sürüm denetimi sistemine sahip olmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-115">At this step, you need to have a version-control system to gather a consolidated version of all the code coming from the different developers in the team.</span></span>

<span data-ttu-id="9bfb1-116">Kaynak kodu denetimi (SCC) ve kaynak kodu yönetimi çoğu geliştirici için ikinci düzeyde görünse de, DevOps yaşam döngüsü içinde Docker uygulamaları oluştururken, uygulama ile Docker görüntülerini geliştirici makinesinden doğrudan genel Docker kayıt defterine (Azure Container Registry veya Docker Hub 'ı gibi) göndermemelidir.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-116">Even though source-code control (SCC) and source-code management might seem second-nature to most developers, when creating Docker applications in a DevOps life cycle, it's critical to emphasize that you must not submit the Docker images with the application directly to the global Docker Registry (like Azure Container Registry or Docker Hub) from the developer's machine.</span></span> <span data-ttu-id="9bfb1-117">Aynı şekilde, yayımlanacak ve üretim ortamlarına dağıtılacak Docker görüntülerinin yalnızca kaynak kodu deponuza (git gibi) bağlı olarak genel derleme veya CI işlem hattınızda tümleştirilebilen kaynak kodunda oluşturulması gerekir.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-117">On the contrary, the Docker images to be released and deployed to production environments must be created solely on the source code that's being integrated in your global build or CI pipeline based on your source-code repository (like Git).</span></span>

<span data-ttu-id="9bfb1-118">Geliştiriciler tarafından oluşturulan yerel görüntüler, yalnızca kendi makineleri içinde test edilirken kullanılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-118">The local images, generated by developers, should just be used by them when testing within their own machines.</span></span> <span data-ttu-id="9bfb1-119">Bu nedenle, DevOps ardışık düzeninin SCC kodundan etkinleştirilmesi çok önemlidir.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-119">That's why it's critical to have the DevOps pipeline activated from the SCC code.</span></span>

<span data-ttu-id="9bfb1-120">Azure DevOps Services ve Team Foundation Server git ve Team Foundation Sürüm Denetimi desteği.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-120">Azure DevOps Services and Team Foundation Server support Git and Team Foundation Version Control.</span></span> <span data-ttu-id="9bfb1-121">Bunlarla arasında seçim yapabilir ve uçtan uca bir Microsoft deneyimi için kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-121">You can choose between them and use it for an end-to-end Microsoft experience.</span></span> <span data-ttu-id="9bfb1-122">Ancak, kodunuzu dış depolarda (GitHub, şirket içi Git depoları veya alt sürüm gibi) yönetebilir ve yine de bu koda bağlanarak DevOps CI işlem hattınızı başlangıç noktası olarak alabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-122">However, you can also manage your code in external repositories (like GitHub, on-premises Git repositories, or Subversion) and still be able to connect to it and get the code as the starting point for your DevOps CI pipeline.</span></span>

## <a name="step-3-build-ci-integrate-and-test-with-azure-devops-services-and-docker"></a><span data-ttu-id="9bfb1-123">3. Adım: Azure DevOps Services ve Docker ile derleme, CI, tümleştirme ve test etme</span><span class="sxs-lookup"><span data-stu-id="9bfb1-123">Step 3: Build, CI, Integrate, and Test with Azure DevOps Services and Docker</span></span>

<span data-ttu-id="9bfb1-124">CI, modern yazılım testi ve teslimi için standart olarak ortaya çıktı.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-124">CI has emerged as a standard for modern software testing and delivery.</span></span> <span data-ttu-id="9bfb1-125">Docker çözümü, geliştirme ve operasyon takımları arasındaki kaygılara açık bir ayrım sağlar.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-125">The Docker solution maintains a clear separation of concerns between the development and operations teams.</span></span> <span data-ttu-id="9bfb1-126">Docker görüntülerinin imlebilirliği, geliştirildiği, CI üzerinden test edilen ve üretimde çalışan arasında tekrarlanabilir bir dağıtım sağlar.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-126">The immutability of Docker images ensures a repeatable deployment between what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="9bfb1-127">Geliştirici dizüstü bilgisayarları ve test altyapısı arasında dağıtılan Docker altyapısı, kapsayıcıları ortamlar arasında taşınabilir hale getirir.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-127">Docker Engine deployed across the developer laptops and test infrastructure makes the containers portable across environments.</span></span>

<span data-ttu-id="9bfb1-128">Bu noktada, doğru koda sahip bir sürüm denetimi sistemine sahip olduktan sonra, kodu seçmek ve genel derlemeyi ve testleri çalıştırmak için bir *Yapı hizmetine* ihtiyacınız vardır.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-128">At this point, after you have a version-control system with the correct code submitted, you need a *build service* to pick up the code and run the global build and tests.</span></span>

<span data-ttu-id="9bfb1-129">Bu adım için iç iş akışı (CI, yapı, test), kod deponuzdan (git, vb.), Yapı sunucunuza (Azure DevOps Services), Docker altyapısından ve bir Docker kayıt defteriyle oluşan bir CI işlem hattının oluşturulmasını yaklaşık olarak oluşturur.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-129">The internal workflow for this step (CI, build, test) is about the construction of a CI pipeline consisting of your code repository (Git, etc.), your build server (Azure DevOps Services), Docker Engine, and a Docker Registry.</span></span>

<span data-ttu-id="9bfb1-130">Uygulamalarınızı oluşturmak ve CI işlem hattınızı ayarlamak ve oluşturulan "yapıtları" bir sonraki adımda açıklanan "yapıt deposuna" yayımlamak için temel olarak Azure DevOps Services kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-130">You can use Azure DevOps Services as the foundation for building your applications and setting your CI pipeline, and for publishing the built "artifacts" to an "artifacts repository," which is explained in the next step.</span></span>

<span data-ttu-id="9bfb1-131">Dağıtım için Docker kullanırken, dağıtılacak "son yapıtlar", uygulama veya hizmetlerinizin içine gömülü olan Docker görüntüleridir.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-131">When using Docker for the deployment, the "final artifacts" to be deployed are Docker images with your application or services embedded within them.</span></span> <span data-ttu-id="9bfb1-132">Bu görüntüler, bir *Docker kayıt defterine* gönderilir veya yayımlanır (Azure Container Registry sahip olduklarınızı gibi özel bir depo veya resmi temel görüntülerde yaygın olarak kullanılan Docker Hub kayıt defteri gibi).</span><span class="sxs-lookup"><span data-stu-id="9bfb1-132">Those images are pushed or published to a *Docker Registry* (a private repository like the ones you can have in Azure Container Registry, or a public one like Docker Hub Registry, which is commonly used for official base images).</span></span>

<span data-ttu-id="9bfb1-133">Temel kavram aşağıda verilmiştir: CI işlem hattı git gibi bir SCC deposuna yapılan bir işleme tarafından açılır.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-133">Here is the basic concept: The CI pipeline will be kicked-off by a commit to an SCC repository like Git.</span></span> <span data-ttu-id="9bfb1-134">Bu işlem, Azure DevOps Services bir Docker kapsayıcısında derleme işi çalıştırmasına ve bu işin başarıyla tamamlanmasıyla, Şekil 5-2 ' de gösterildiği gibi Docker kayıt defterine bir Docker görüntüsü göndermesine neden olur.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-134">The commit will cause Azure DevOps Services to run a build job within a Docker container and, upon successful completion of that job, push a Docker image to the Docker Registry, as illustrated in Figure 5-2.</span></span> <span data-ttu-id="9bfb1-135">Dış döngünün ilk bölümü, kod, çalıştırma, hata ayıklama ve doğrulama, sonra derlemeyi derleme ve test CI adımına kadar olan adım 1 ile 3 arasındaki adımları içerir.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-135">The first part of the outer loop involves steps 1 to 3, from code, run, debug and validate, then the code repo up to the build and test CI step.</span></span>

![CI iş akışında yer alan üç adımı gösteren diyagram.](./media/docker-application-outer-loop-devops-workflow/continuous-integration-steps.png)

<span data-ttu-id="9bfb1-137">**Şekil 5-2**.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-137">**Figure 5-2**.</span></span> <span data-ttu-id="9bfb1-138">CI 'da yer alan adımlar</span><span class="sxs-lookup"><span data-stu-id="9bfb1-138">The steps involved in CI</span></span>

<span data-ttu-id="9bfb1-139">Docker ve Azure DevOps Services ile ilgili temel CI iş akışı adımları aşağıda verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="9bfb1-139">Here are the basic CI workflow steps with Docker and Azure DevOps Services:</span></span>

1. <span data-ttu-id="9bfb1-140">Geliştirici bir SCC deposuna (git/Azure DevOps Services, GitHub, vb.) bir işlemeye gönderim sağlar.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-140">The developer pushes a commit to an SCC repository (Git/Azure DevOps Services, GitHub, etc.).</span></span>

2. <span data-ttu-id="9bfb1-141">Azure DevOps Services veya git kullanıyorsanız, CI içinde yerleşik olarak bulunur, bu da Azure DevOps Services bir onay kutusu seçmenin basit olduğu anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-141">If you're using Azure DevOps Services or Git, CI is built in, which means that it's as simple as selecting a check box in Azure DevOps Services.</span></span> <span data-ttu-id="9bfb1-142">Bir dış SCC (GitHub gibi) kullanıyorsanız, `webhook` güncelleştirme Azure DevOps Services veya git/GitHub ' a gönderim yapılır.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-142">If you're using an external SCC (like GitHub), a `webhook` will notify Azure DevOps Services of the update or push to Git/GitHub.</span></span>

3. <span data-ttu-id="9bfb1-143">Azure DevOps Services, resmi açıklayan Dockerfile ve uygulama ve test kodu da dahil olmak üzere SCC deposunu çeker.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-143">Azure DevOps Services pulls the SCC repository, including the Dockerfile describing the image, as well as the application and test code.</span></span>

4. <span data-ttu-id="9bfb1-144">Azure DevOps Services bir Docker görüntüsü oluşturur ve bir yapı numarasıyla etiketleyebilir.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-144">Azure DevOps Services builds a Docker image and labels it with a build number.</span></span>

5. <span data-ttu-id="9bfb1-145">Azure DevOps Services sağlanan Docker Konağı içindeki Docker kapsayıcısını başlatır ve uygun testleri çalıştırır.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-145">Azure DevOps Services instantiates the Docker container within the provisioned Docker Host, and runs the appropriate tests.</span></span>

6. <span data-ttu-id="9bfb1-146">Testler başarılı olursa görüntü, "Blessed" ("/1.0.0" gibi) ve ardından Docker Kayıt defterinize (Docker Hub, Azure Container Registry, DTR vb.) itilmesi için ilk olarak anlamlı bir ada yol açmıştır.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-146">If the tests are successful, the image is first relabeled to a meaningful name so that you know it's a "blessed build" (like "/1.0.0" or any other label), and then pushed up to your Docker Registry (Docker Hub, Azure Container Registry, DTR, etc.)</span></span>

### <a name="implementing-the-ci-pipeline-with-azure-devops-services-and-the-docker-extension-for-azure-devops-services"></a><span data-ttu-id="9bfb1-147">Azure DevOps Services için Azure DevOps Services ve Docker uzantısıyla CI işlem hattını uygulama</span><span class="sxs-lookup"><span data-stu-id="9bfb1-147">Implementing the CI pipeline with Azure DevOps Services and the Docker extension for Azure DevOps Services</span></span>

<span data-ttu-id="9bfb1-148">Visual Studio Azure DevOps Services, Docker görüntülerini oluşturabileceğiniz, Docker görüntülerini kimliği doğrulanmış bir Docker kayıt defterine gönderebilen, Docker görüntülerini çalıştıran veya Docker CLı tarafından sunulan diğer işlemleri çalıştıran, CI/CD işlem hattınızda kullanabileceğiniz derleme & sürüm şablonları içerir.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-148">Visual Studio Azure DevOps Services contains Build & Release Templates that you can use in your CI/CD pipeline with which you can build Docker images, push Docker images to an authenticated Docker registry, run Docker images, or run other operations offered by the Docker CLI.</span></span> <span data-ttu-id="9bfb1-149">Ayrıca, Şekil 5-3 ' de gösterildiği gibi, çok Kapsayıcılı Docker uygulamaları oluşturmak, göndermek ve çalıştırmak için kullanabileceğiniz bir Docker Compose görevi ekler veya Docker Compose CLı tarafından sunulan diğer işlemleri çalıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-149">It also adds a Docker Compose task that you can use to build, push, and run multi-container Docker applications, or run other operations offered by the Docker Compose CLI, as shown in Figure 5-3.</span></span>

![Azure DevOps 'daki Docker CI işlem hattının ekran görüntüsü.](./media/docker-application-outer-loop-devops-workflow/docker-ci-pipeline-azure-devops.png)

<span data-ttu-id="9bfb1-151">**Şekil 5-3**.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-151">**Figure 5-3**.</span></span> <span data-ttu-id="9bfb1-152">Yapı & sürüm şablonları ve ilişkili görevler de dahil olmak üzere Azure DevOps Services Docker CI işlem hattı.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-152">The Docker CI pipeline in Azure DevOps Services including Build & Release Templates and associated tasks.</span></span>

<span data-ttu-id="9bfb1-153">Azure Service Fabric, Azure Kubernetes hizmeti ve benzer tekliflerde derleme/test ve dağıtım yapmak üzere CI/CD yapılarınızı oluşturmak için bu şablonları ve görevleri kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-153">You can use these templates and tasks to construct your CI/CD artifacts to Build / Test and Deploy in Azure Service Fabric, Azure Kubernetes Service, and similar offerings.</span></span>

<span data-ttu-id="9bfb1-154">Bu Visual Studio Team Services görevlerle, Azure 'da ve tercih ettiğiniz Docker kayıt defterinizde (Azure Container Registry, Docker Hub, özel Docker DTR veya başka bir Docker kayıt defteri) sağlanan bir derleme Linux-Docker Konağı/VM ile Docker CI işlem hattınızı çok tutarlı bir şekilde birleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-154">With these Visual Studio Team Services tasks, a build Linux-Docker Host/VM provisioned in Azure and your preferred Docker registry (Azure Container Registry, Docker Hub, private Docker DTR, or any other Docker registry) you can assemble your Docker CI pipeline in a very consistent way.</span></span>

<span data-ttu-id="9bfb1-155">***Gereklilik***</span><span class="sxs-lookup"><span data-stu-id="9bfb1-155">***Requirements:***</span></span>

- <span data-ttu-id="9bfb1-156">Azure DevOps Services veya şirket içi yüklemeler için, Team Foundation Server 2015 güncelleştirme 3 veya sonraki bir sürümü.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-156">Azure DevOps Services, or for on-premises installations, Team Foundation Server 2015 Update 3 or later.</span></span>

- <span data-ttu-id="9bfb1-157">Docker ikililerini içeren bir Azure DevOps Services Aracısı.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-157">An Azure DevOps Services agent that has the Docker binaries.</span></span>

  <span data-ttu-id="9bfb1-158">Bu aracılardan birini oluşturmanın kolay bir yolu, Azure DevOps Services Agent Docker görüntüsünü temel alan bir kapsayıcı çalıştırmak için Docker kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-158">An easy way to create one of these agents is to use Docker to run a container based on the Azure DevOps Services agent Docker image.</span></span>

> <span data-ttu-id="9bfb1-159">[! BILGI] Azure DevOps Services Docker CI işlem hattı oluşturma ve izlenecek yolları görüntüleme hakkında daha fazla bilgi edinmek Için şu siteleri ziyaret edin:</span><span class="sxs-lookup"><span data-stu-id="9bfb1-159">[!INFORMATION] To read more about assembling an Azure DevOps Services Docker CI pipeline and view the walkthroughs, visit these sites:</span></span>
>
> - <span data-ttu-id="9bfb1-160">Bir Visual Studio Team Services (Şimdi Azure DevOps Services) aracı bir Docker kapsayıcısı olarak çalıştırılıyor: </span><span class="sxs-lookup"><span data-stu-id="9bfb1-160">Running a Visual Studio Team Services (Now Azure DevOps Services) agent as a Docker container: </span></span>\
>   <https://hub.docker.com/_/microsoft-azure-pipelines-vsts-agent>
>
> - <span data-ttu-id="9bfb1-161">Azure DevOps Services .NET Core Linux Docker görüntüleri derleniyor: </span><span class="sxs-lookup"><span data-stu-id="9bfb1-161">Building .NET Core Linux Docker images with Azure DevOps Services: </span></span>\
>   <https://docs.microsoft.com/archive/blogs/stevelasker/building-net-core-linux-docker-images-with-visual-studio-team-services>
>
> - <span data-ttu-id="9bfb1-162">Docker desteğiyle Linux tabanlı bir Visual Studio Team Service derleme makinesi oluşturma: </span><span class="sxs-lookup"><span data-stu-id="9bfb1-162">Building a Linux-based Visual Studio Team Service build machine with Docker support: </span></span>\
>   <https://www.donovanbrown.com/post/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support>

### <a name="integrate-test-and-validate-multi-container-docker-applications"></a><span data-ttu-id="9bfb1-163">Çok Kapsayıcılı Docker uygulamalarını tümleştirin, test edin ve doğrulayın</span><span class="sxs-lookup"><span data-stu-id="9bfb1-163">Integrate, test, and validate multi-container Docker applications</span></span>

<span data-ttu-id="9bfb1-164">Genellikle, çoğu Docker uygulaması tek bir kapsayıcı yerine birden çok kapsayıcıdan oluşur.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-164">Typically, most Docker applications are composed of multiple containers rather than a single container.</span></span> <span data-ttu-id="9bfb1-165">İyi bir örnek, mikro hizmet başına bir kapsayıcıya sahip olduğunuz mikro hizmetlere dayalı bir uygulamadır.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-165">A good example is a microservices-oriented application for which you would have one container per microservice.</span></span> <span data-ttu-id="9bfb1-166">Ancak, mikro hizmetler yaklaşım desenlerinin kesinlikle takip etmeksizin bile, Docker uygulamanızın birden çok kapsayıcı veya hizmetten oluşması olasıdır.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-166">But, even without strictly following the microservices approach patterns, it's probable that your Docker application would be composed of multiple containers or services.</span></span>

<span data-ttu-id="9bfb1-167">Bu nedenle, CI işlem hattında uygulama kapsayıcıları oluşturulduktan sonra, bir tümleştirme Docker ana bilgisayarı içindeki kapsayıcılarından ve hatta kapsayıcılarınızın dağıtıldığı bir test kümesine bir bütün olarak uygulamayı dağıtmanız, tümleştirmeniz ve test etmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-167">Therefore, after building the application containers in the CI pipeline, you also need to deploy, integrate, and test the application as a whole with all of its containers within an integration Docker host or even into a test cluster to which your containers are distributed.</span></span>

<span data-ttu-id="9bfb1-168">Tek bir konak kullanıyorsanız, tek bir VM 'de Docker ortamını test etmek ve doğrulamak üzere ilgili kapsayıcıları derlemek ve dağıtmak için Docker-Compose gibi Docker komutlarını kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-168">If you're using a single host, you can use Docker commands such as docker-compose to build and deploy related containers to test and validate the Docker environment in a single VM.</span></span> <span data-ttu-id="9bfb1-169">Ancak, DC/OS, Kubernetes veya Docker Sısınma gibi bir Orchestrator kümesiyle çalışıyorsanız, seçili kümenize/zamanlayıcıya bağlı olarak Kapsayıcılarınızı farklı bir mekanizma veya Orchestrator aracılığıyla dağıtmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-169">But, if you're working with an orchestrator cluster like DC/OS, Kubernetes, or Docker Swarm, you need to deploy your containers through a different mechanism or orchestrator, depending on your selected cluster/scheduler.</span></span>

<span data-ttu-id="9bfb1-170">Aşağıda, Docker kapsayıcılarına karşı çalıştırabileceğiniz birkaç test türü verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="9bfb1-170">The following are several types of tests that you can run against Docker containers:</span></span>

- <span data-ttu-id="9bfb1-171">Docker kapsayıcıları için birim testleri</span><span class="sxs-lookup"><span data-stu-id="9bfb1-171">Unit tests for Docker containers</span></span>

- <span data-ttu-id="9bfb1-172">İlişkili uygulamaların veya mikro hizmetlerin gruplarını test etme</span><span class="sxs-lookup"><span data-stu-id="9bfb1-172">Testing groups of interrelated applications or microservices</span></span>

- <span data-ttu-id="9bfb1-173">Üretimde ve "Canary" sürümlerindeki test</span><span class="sxs-lookup"><span data-stu-id="9bfb1-173">Test in production and "canary" releases</span></span>

<span data-ttu-id="9bfb1-174">Önemli nokta, tümleştirme ve işlevsel testleri çalıştırırken, bu testleri kapsayıcılar dışından çalıştırmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-174">The important point is that when running integration and functional tests, you must run those tests from outside of the containers.</span></span> <span data-ttu-id="9bfb1-175">Kapsayıcılar, üretim ortamına dağıtabilediklerinizle aynı olması gereken statik görüntüleri temel aldığı için, dağıtmakta olduğunuz kapsayıcılarda testler dahil değildir veya çalıştırılmaz.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-175">Tests are not contained or run in the containers you're deploying, because the containers are based on static images that should be exactly like the ones you'll be deploying to production.</span></span>

<span data-ttu-id="9bfb1-176">Çeşitli kümeler (test kümesi, hazırlama kümesi ve üretim kümesi) gibi daha gelişmiş senaryolar test edilirken, görüntüleri bir kayıt defterine yayımlamada pratik bir seçenek, bu sayede çeşitli kümelerde test edilebilir.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-176">A practical option when testing more advanced scenarios, like including several clusters (test cluster, staging cluster, and production cluster) is to publish the images to a registry, so it can be tested in various clusters.</span></span>

### <a name="push-the-custom-application-docker-image-into-your-global-docker-registry"></a><span data-ttu-id="9bfb1-177">Özel uygulama Docker görüntüsünü küresel Docker Kayıt defterinize gönderme</span><span class="sxs-lookup"><span data-stu-id="9bfb1-177">Push the custom application Docker image into your global Docker Registry</span></span>

<span data-ttu-id="9bfb1-178">Docker görüntüleri test edildikten ve doğrulandıktan sonra, bunları Docker kayıt defterinizde etiketlemek ve yayımlamak isteyeceksiniz.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-178">After the Docker images have been tested and validated, you'll want to tag and publish them to your Docker registry.</span></span> <span data-ttu-id="9bfb1-179">Docker kayıt defteri, özel testinizi ("küçük resimler" olarak da bilinir), QA ve üretim ortamlarına dağıtmak üzere depoladığınız merkezi bir yerdir çünkü Docker uygulama yaşam döngüsünün önemli bir parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-179">The Docker registry is a critical piece in the Docker application life cycle because it's the central place where you store your custom test (also known as "blessed images") to be deployed into QA and production environments.</span></span>

<span data-ttu-id="9bfb1-180">(Git, vb.), SCC deponuzda (git, vb.) depolanan uygulama kodunun "Truth kaynağı", ikili uygulamanız veya bitlerin QA veya üretim ortamlarına dağıtılması için "gerçeği kaynağıdır".</span><span class="sxs-lookup"><span data-stu-id="9bfb1-180">Similar to how the application code stored in your SCC repository (Git, etc.) is your "source of truth," the Docker registry is your "source of truth" for your binary application or bits to be deployed to the QA or production environments.</span></span>

<span data-ttu-id="9bfb1-181">Genellikle, özel görüntüleriniz için Azure Container Registry veya Docker güvenilen kayıt defteri gibi bir şirket içi kayıt defterinde veya kısıtlı erişime sahip bir ortak bulut kayıt defterinde (Docker Hub gibi), bu son durumda, kodunuzun güvenliğine güvenmeniz gerekir, ancak bu son durumda, satıcının güvenliğine güvenebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-181">Typically, you might want to have your private repositories for your custom images either in a private repository in Azure Container Registry or in an on-premises registry like Docker Trusted Registry, or in a public-cloud registry with restricted access (like Docker Hub), although in this last case if your code is not open source, you must trust the vendor's security.</span></span> <span data-ttu-id="9bfb1-182">Her iki durumda da, kullandığınız yöntem benzerdir ve `docker push` şekil 5-4 ' de gösterildiği gibi komuta dayalıdır.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-182">Either way, the method you use is similar and is based on the `docker push` command, as shown in Figure 5-4.</span></span>

![Bir kapsayıcı kayıt defterine özel görüntülerin itilini gösteren diyagram.](./media/docker-application-outer-loop-devops-workflow/docker-push-custom-images.png)

<span data-ttu-id="9bfb1-184">**Şekil 5-4**.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-184">**Figure 5-4**.</span></span> <span data-ttu-id="9bfb1-185">Docker kayıt defterine özel görüntüler Yayımlama</span><span class="sxs-lookup"><span data-stu-id="9bfb1-185">Publishing custom images to Docker Registry</span></span>

<span data-ttu-id="9bfb1-186">Adım 3 ' te, tümleştirme ve test (CI) oluşturmak için, elde edilen Docker görüntülerini özel veya ortak bir kayıt defterine yayımlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-186">In step 3, for building integration and testing (CI) you might publish the resulting docker images to a private or public registry.</span></span> <span data-ttu-id="9bfb1-187">Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay kayıt defteri vb. gibi bulut satıcılarından çok sayıda Docker kayıt defteri teklifi vardır.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-187">There are multiple offerings of Docker registries from cloud vendors like Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay Registry, and so on.</span></span>

<span data-ttu-id="9bfb1-188">Docker görevlerini kullanarak, Şekil 5-5 ' de gösterildiği gibi, birden çok etiketli bir dosya tarafından tanımlanan bir dizi hizmet görüntüsünü, `docker-compose.yml` kimliği doğrulanmış bir Docker kayıt defterine (Azure Container Registry gibi) gönderebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-188">Using the Docker tasks, you can push a set of service images defined by a `docker-compose.yml` file, with multiple tags, to an authenticated Docker registry (like Azure Container Registry), as shown in Figure 5-5.</span></span>

![Görüntüleri bir kayıt defterine yayımlama adımını gösteren ekran görüntüsü.](./media/docker-application-outer-loop-devops-workflow/publish-custom-image-to-docker-registry.png)

<span data-ttu-id="9bfb1-190">**Şekil 5-5**.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-190">**Figure 5-5**.</span></span> <span data-ttu-id="9bfb1-191">Özel görüntüleri bir Docker kayıt defterine yayımlamak için Azure DevOps Services kullanma</span><span class="sxs-lookup"><span data-stu-id="9bfb1-191">Using Azure DevOps Services to publishing custom images to a Docker Registry</span></span>

> <span data-ttu-id="9bfb1-192">[! BILGI] Azure Container Registry hakkında daha fazla bilgi Için bkz <https://aka.ms/azurecontainerregistry> ..</span><span class="sxs-lookup"><span data-stu-id="9bfb1-192">[!INFORMATION] For more information about Azure Container Registry, see <https://aka.ms/azurecontainerregistry>.</span></span>

## <a name="step-4-cd-deploy"></a><span data-ttu-id="9bfb1-193">4. Adım: CD, dağıtma</span><span class="sxs-lookup"><span data-stu-id="9bfb1-193">Step 4: CD, Deploy</span></span>

<span data-ttu-id="9bfb1-194">Docker görüntülerinin imlebilirliği, geliştirildiği, CI üzerinden test edilen ve üretimde çalışan, tekrarlanabilir bir dağıtım sağlar.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-194">The immutability of Docker images ensures a repeatable deployment with what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="9bfb1-195">Docker kayıt defterinizde (özel veya ortak) uygulama Docker görüntülerini yayımladıktan sonra, Azure DevOps Services işlem hattı görevleri veya Release Management Azure DevOps Services kullanarak CD işlem hattınızdan (üretim, QA, hazırlama, vb.) sahip olabileceğiniz çeşitli ortamlara dağıtabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-195">After you have the application Docker images published in your Docker registry (either private or public), you can deploy them to the several environments that you might have (production, QA, staging, etc.) from your CD pipeline by using Azure DevOps Services pipeline tasks or Azure DevOps Services Release Management.</span></span>

<span data-ttu-id="9bfb1-196">Ancak, bu noktada dağıtmakta olduğunuz Docker uygulamasının türüne bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-196">However, at this point it depends on what kind of Docker application you're deploying.</span></span> <span data-ttu-id="9bfb1-197">Birkaç kapsayıcı veya hizmetten oluşan ve birkaç sunucuya ya da VM 'ye dağıtılan tek parçalı bir uygulama gibi basit bir uygulamayı (bir bileşim ve dağıtım noktasından) dağıtmak, daha karmaşık bir uygulamanın hiper ölçek özelliklerine sahip mikro hizmet odaklı bir uygulama gibi daha karmaşık bir uygulama dağıtmaktan farklıdır.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-197">Deploying a simple application (from a composition and deployment point of view) like a monolithic application comprising a few containers or services and deployed to a few servers or VMs is different from deploying a more complex application like a microservices-oriented application with hyperscale capabilities.</span></span> <span data-ttu-id="9bfb1-198">Bu iki senaryo aşağıdaki bölümlerde açıklanmıştır.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-198">These two scenarios are explained in the following sections.</span></span>

### <a name="deploying-composed-docker-applications-to-multiple-docker-environments"></a><span data-ttu-id="9bfb1-199">Oluşturulan Docker uygulamalarını birden çok Docker ortamına dağıtma</span><span class="sxs-lookup"><span data-stu-id="9bfb1-199">Deploying composed Docker applications to multiple Docker environments</span></span>

<span data-ttu-id="9bfb1-200">Daha az karmaşık senaryoya ilk göz atalım: tek bir ortamda veya birden çok ortamda basit Docker konaklarına (VM 'Ler veya sunucular) dağıtım (QA, hazırlama ve üretim).</span><span class="sxs-lookup"><span data-stu-id="9bfb1-200">Let's look first at the less-complex scenario: deploying to simple Docker hosts (VMs or servers) in a single environment or multiple environments (QA, staging, and production).</span></span> <span data-ttu-id="9bfb1-201">Bu senaryoda, dahili olarak CD işlem hattı, Şekil 5-6 ' de gösterildiği gibi, Docker uygulamalarını ilgili kapsayıcı veya hizmet kümesiyle birlikte dağıtmak için Docker-Compose ' u (Azure DevOps Services dağıtım görevleriniz) kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-201">In this scenario, internally your CD pipeline can use docker-compose (from your Azure DevOps Services deployment tasks) to deploy the Docker applications with its related set of containers or services, as illustrated in Figure 5-6.</span></span>

![CD dağıtımı adımını üç ortama dağıtmayı gösteren diyagram.](./media/docker-application-outer-loop-devops-workflow/deploy-app-containers-to-docker-host-environments.png)

<span data-ttu-id="9bfb1-203">**Şekil 5-6**.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-203">**Figure 5-6**.</span></span> <span data-ttu-id="9bfb1-204">Uygulama kapsayıcılarını basit Docker ana bilgisayar ortamları kayıt defterine dağıtma</span><span class="sxs-lookup"><span data-stu-id="9bfb1-204">Deploying application containers to simple Docker host environments registry</span></span>

<span data-ttu-id="9bfb1-205">Şekil 5-7 Görev Ekle iletişim kutusunda Docker Compose ' a tıklayarak yapı CI 'nizi Azure DevOps Services aracılığıyla QA/test ortamlarına nasıl bağlayabileceğinizi vurgular.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-205">Figure 5-7 highlights how you can connect your build CI to QA/test environments via Azure DevOps Services by clicking Docker Compose in the Add Task dialog box.</span></span> <span data-ttu-id="9bfb1-206">Ancak, hazırlama veya üretim ortamlarına dağıtım yaparken, genellikle birden çok ortamı (QA, hazırlama ve üretim gibi) işleyen Release Management özellikleri kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-206">However, when deploying to staging or production environments, you would usually use Release Management features handling multiple environments (like QA, staging, and production).</span></span> <span data-ttu-id="9bfb1-207">Tek Docker konaklarına dağıtıyorsanız, bu, Azure DevOps Services "Docker Compose" görevini kullanıyor (Bu komut, alt ' `docker-compose up` ın altındaki komutu çağırır).</span><span class="sxs-lookup"><span data-stu-id="9bfb1-207">If you're deploying to single Docker hosts, it is using the Azure DevOps Services "Docker Compose" task (which is invoking the `docker-compose up` command under the hood).</span></span> <span data-ttu-id="9bfb1-208">Azure Kubernetes Service 'e (AKS) dağıtım yapıyorsanız, aşağıdaki bölümde açıklandığı gibi Docker dağıtım görevini kullanır.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-208">If you're deploying to Azure Kubernetes Service (AKS), it uses the Docker Deployment task, as explained in the section that follows.</span></span>

![Docker Compose görevinin görev Ekle iletişim kutusunu gösteren ekran görüntüsü.](./media/docker-application-outer-loop-devops-workflow/add-tasks-docker-compose.png)

<span data-ttu-id="9bfb1-210">**Şekil 5-7**.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-210">**Figure 5-7**.</span></span> <span data-ttu-id="9bfb1-211">Bir Azure DevOps Services işlem hattına Docker Compose görevi ekleme</span><span class="sxs-lookup"><span data-stu-id="9bfb1-211">Adding a Docker Compose task in an Azure DevOps Services pipeline</span></span>

<span data-ttu-id="9bfb1-212">Azure DevOps Services ' de bir yayın oluşturduğunuzda, bir giriş yapıtları kümesi alır.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-212">When you create a release in Azure DevOps Services, it takes a set of input artifacts.</span></span> <span data-ttu-id="9bfb1-213">Bu yapıtlar, tüm ortamlarda yayının kullanım ömrü boyunca sabit olmak üzere tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-213">These artifacts are intended to be immutable for the lifetime of the release, across all environments.</span></span> <span data-ttu-id="9bfb1-214">Kapsayıcıları belirttiğinizde, giriş yapıtları dağıtılacak bir kayıt defterindeki görüntüleri belirler.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-214">When you introduce containers, the input artifacts identify images in a registry to deploy.</span></span> <span data-ttu-id="9bfb1-215">Bu görüntülerin nasıl tanımlandığına bağlı olarak, yayının süresi boyunca aynı kalmaları garanti edilmez, bu da bir dosyadan başvuru yaparken en belirgin durumdur `myimage:latest` `docker-compose` .</span><span class="sxs-lookup"><span data-stu-id="9bfb1-215">Depending on how these images are identified, they are not guaranteed to remain the same throughout the duration of the release, the most obvious case being when you reference `myimage:latest` from a `docker-compose` file.</span></span>

<span data-ttu-id="9bfb1-216">Azure DevOps Services şablonlar, aynı görüntü ikilisini benzersiz şekilde tanımlamak için garanti edilen belirli bir kayıt defteri görüntüsü olan yapı yapıtları oluşturma olanağı sağlar.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-216">The Azure DevOps Services templates give you the ability to generate build artifacts that contain specific registry image digests that are guaranteed to uniquely identify the same image binary.</span></span> <span data-ttu-id="9bfb1-217">Bunlar, gerçekten bir yayına giriş olarak kullanmak istediğiniz şeydir.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-217">These are what you really want to use as input to a release.</span></span>

### <a name="managing-releases-to-docker-environments-by-using-azure-devops-services-release-management"></a><span data-ttu-id="9bfb1-218">Azure DevOps Services kullanarak, Docker ortamlarında yayınları yönetme Release Management</span><span class="sxs-lookup"><span data-stu-id="9bfb1-218">Managing releases to Docker environments by using Azure DevOps Services Release Management</span></span>

<span data-ttu-id="9bfb1-219">Azure DevOps Services şablonları aracılığıyla yeni bir görüntü oluşturabilir, bunu bir Docker kayıt defterine yayımlayabilir, Linux veya Windows konakları üzerinde çalıştırabilir ve `docker-compose` tüm uygulama olarak birden çok kapsayıcı dağıtmak için gibi komutları kullanabilirsiniz. şekil 5-8 ' de gösterildiği gibi, birden çok ortam için tasarlanan Azure DevOps Services Release Management özellikleri aracılığıyla.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-219">Through the Azure DevOps Services templates, you can build a new image, publish it to a Docker registry, run it on Linux or Windows hosts, and use commands such as `docker-compose` to deploy multiple containers as an entire application, all through the Azure DevOps Services Release Management capabilities intended for multiple environments, as shown in Figure 5-8.</span></span>

![Docker Compose sürümlerinin yapılandırmasını gösteren ekran görüntüsü.](./media/docker-application-outer-loop-devops-workflow/configure-docker-compose-release.png)

<span data-ttu-id="9bfb1-221">**Şekil 5-8**.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-221">**Figure 5-8**.</span></span> <span data-ttu-id="9bfb1-222">Azure DevOps Services Azure DevOps Services Docker Compose görevlerini yapılandırma Release Management</span><span class="sxs-lookup"><span data-stu-id="9bfb1-222">Configuring Azure DevOps Services Docker Compose tasks from Azure DevOps Services Release Management</span></span>

<span data-ttu-id="9bfb1-223">Bununla birlikte, Şekil 5-6 ' de gösterilen ve Şekil 5-8 ' de uygulanan senaryonun basit bir tane olduğunu ve tek bir kapsayıcı veya görüntü başına tek bir kapsayıcı veya örnek olduğunu ve muhtemelen yalnızca geliştirme veya test senaryoları için kullanılması gerektiğini aklınızda bulundurun.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-223">However, keep in mind that the scenario shown in Figure 5-6 and implemented in Figure 5-8 is a simple one (it's deploying to single Docker hosts and VMs, and there will be a single container or instance per image) and probably should be used only for development or test scenarios.</span></span> <span data-ttu-id="9bfb1-224">Çoğu kurumsal üretim senaryosunda, yüksek kullanılabilirlik (HA) ve birden çok düğüm, sunucu ve VM genelinde yük dengelemesine ve "akıllı yük devretme", bir sunucu veya düğüm başarısız olursa, hizmetleri ve kapsayıcıları başka bir konak sunucusuna veya VM 'ye taşınır.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-224">In most enterprise production scenarios, you would want to have High Availability (HA) and easy-to-manage scalability by load balancing across multiple nodes, servers, and VMs, plus "intelligent failovers" so if a server or node fails, its services and containers will be moved to another host server or VM.</span></span> <span data-ttu-id="9bfb1-225">Bu durumda, kapsayıcı kümeleri, düzenleyiciler ve zamanlayıcılar gibi daha gelişmiş teknolojilerin olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-225">In that case, you need more advanced technologies such as container clusters, orchestrators, and schedulers.</span></span> <span data-ttu-id="9bfb1-226">Bu nedenle, bu kümelere dağıtmanın yolu, sonraki bölümde açıklanan gelişmiş senaryoları işlemeklerdir.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-226">Thus, the way to deploy to those clusters is by handling the advanced scenarios explained in the next section.</span></span>

### <a name="deploying-docker-applications-to-docker-clusters"></a><span data-ttu-id="9bfb1-227">Docker uygulamalarını Docker kümelerine dağıtma</span><span class="sxs-lookup"><span data-stu-id="9bfb1-227">Deploying Docker applications to Docker clusters</span></span>

<span data-ttu-id="9bfb1-228">Dağıtılmış uygulamaların doğası de dağıtılan işlem kaynaklarını gerektirir.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-228">The nature of distributed applications requires compute resources that are also distributed.</span></span> <span data-ttu-id="9bfb1-229">Üretim ölçeğinde yetenekler sağlamak için, havuza alınmış kaynaklara göre yüksek ölçeklenebilirlik ve yüksek kullanılabilirlik sağlayan kümeleme özelliklerine sahip olmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-229">To have production-scale capabilities, you need to have clustering capabilities that provide high scalability and high availability based on pooled resources.</span></span>

<span data-ttu-id="9bfb1-230">Bir CLı aracından veya Web kullanıcı arabiriminden bu kümelerdeki kapsayıcıları el ile dağıtabilirsiniz, ancak bu tür bir el ile çalışma türünü, genişleme veya izleme gibi yönetim amaçlarını veya bunları belirlemek için ayırmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-230">You could deploy containers manually to those clusters from a CLI tool or a web UI, but you should reserve that kind of manual work to spot deployment testing or management purposes like scaling-out or monitoring.</span></span>

<span data-ttu-id="9bfb1-231">Bir CD görünümü ve Azure DevOps Services özel olarak, Kapsayıcılı uygulamalarınızı, Şekil 5-9 ' de gösterildiği gibi kapsayıcı hizmetindeki dağıtılmış kümelere dağıtan Azure DevOps Services Release Management ortamlarınızdan özel olarak hazırlanmış dağıtım görevleri çalıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-231">From a CD point of view, and Azure DevOps Services specifically, you can run specially made deployment tasks from your Azure DevOps Services Release Management environments that will deploy your containerized applications to distributed clusters in Container Service, as illustrated in Figure 5-9.</span></span>

![Düzenleyicilerine CD dağıtım adımını dağıtmayı gösteren diyagram.](./media/docker-application-outer-loop-devops-workflow/cd-deploy-to-orchestrators.png)

<span data-ttu-id="9bfb1-233">**Şekil 5-9**.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-233">**Figure 5-9**.</span></span> <span data-ttu-id="9bfb1-234">Dağıtılmış uygulamaları kapsayıcı hizmetine dağıtma</span><span class="sxs-lookup"><span data-stu-id="9bfb1-234">Deploying distributed applications to Container Service</span></span>

<span data-ttu-id="9bfb1-235">Başlangıçta, belirli kümelere veya düzenleyicilerine dağıtım yaparken her bir Orchestrator için (yani, Kubernetes ve Service Fabric farklı dağıtım mekanizmalarına sahip), `docker-compose` tanım dosyasını temel alan daha basit ve kullanımı kolay bir araç yerine belirli dağıtım betikleri ve mekanizmaları kullanırsınız `docker-compose.yml` .</span><span class="sxs-lookup"><span data-stu-id="9bfb1-235">Initially, when deploying to certain clusters or orchestrators, you would traditionally use specific deployment scripts and mechanisms per each orchestrator (that is, Kubernetes and Service Fabric have different deployment mechanisms) instead of the simpler and easy-to-use `docker-compose` tool based on the `docker-compose.yml` definition file.</span></span> <span data-ttu-id="9bfb1-236">Ancak, Şekil 5-10 ' de gösterilen Azure DevOps Services Docker Deploy görevi sayesinde, `docker-compose.yml` araç, sizin için "Çeviri" işlemini sizin için ( `docker-compose.yml` dosyanızda Orchestrator tarafından gerek duyulan biçimde) gerçekleştirdiğinden yalnızca tanıdık dosyanızı kullanarak da desteklenen düzenleyicilerine dağıtım yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-236">However, thanks to the Azure DevOps Services Docker Deploy task, shown in Figure 5-10, now you can also deploy to the supported orchestrators by just using your familiar `docker-compose.yml` file because the tool performs that "translation" for you (from your `docker-compose.yml` file to the format needed by the orchestrator).</span></span>

![Kubernetes 'e dağıtımı görevi gösteren ekran görüntüsü.](./media/docker-application-outer-loop-devops-workflow/add-deploy-to-kubernetes-task.png)

<span data-ttu-id="9bfb1-238">**Şekil 5-10**.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-238">**Figure 5-10**.</span></span> <span data-ttu-id="9bfb1-239">Ortamınıza Kubernetes görevine dağıtım ekleme</span><span class="sxs-lookup"><span data-stu-id="9bfb1-239">Adding the Deploy to Kubernetes task to your Environment</span></span>

<span data-ttu-id="9bfb1-240">Şekil 5-11 ' da, Kubernetes ile yapılandırma için kullanılabilir olan bölümleri nasıl düzenleyebileceğinizi gösterir.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-240">Figure 5-11 demonstrates how you can edit the Deploy to Kubernetes task with the sections available for configuration.</span></span> <span data-ttu-id="9bfb1-241">Bu, kümedeki kapsayıcılar olarak dağıtılacak, kullanıma yönelik özel Docker görüntülerini alacak olan görevdir.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-241">This is the task that will retrieve your ready-to-use custom Docker images to be deployed as containers in the cluster.</span></span>

![Kubernetes görev yapılandırmasına dağıtımı gösteren ekran görüntüsü.](./media/docker-application-outer-loop-devops-workflow/edit-deploy-to-kubernetes-task.png)

<span data-ttu-id="9bfb1-243">**Şekil 5-11**.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-243">**Figure 5-11**.</span></span> <span data-ttu-id="9bfb1-244">Docker dağıtım görev tanımı, ACS DC/OS 'ye dağıtılıyor</span><span class="sxs-lookup"><span data-stu-id="9bfb1-244">Docker Deploy task definition deploying to ACS DC/OS</span></span>

> <span data-ttu-id="9bfb1-245">[! BILGI] Azure DevOps Services ve Docker ile CD işlem hattı hakkında daha fazla bılgı edinmek Için şu adresi ziyaret edin <https://azure.microsoft.com/services/devops/pipelines></span><span class="sxs-lookup"><span data-stu-id="9bfb1-245">[!INFORMATION] To read more about the CD pipeline with Azure DevOps Services and Docker, visit <https://azure.microsoft.com/services/devops/pipelines></span></span>

## <a name="step-5-run-and-manage"></a><span data-ttu-id="9bfb1-246">5. Adım: çalıştırma ve yönetme</span><span class="sxs-lookup"><span data-stu-id="9bfb1-246">Step 5: Run and manage</span></span>

<span data-ttu-id="9bfb1-247">Kurumsal üretim düzeyinde uygulama çalıştırmak ve yönetmek için ve tek başına ve bu düzeyde (BT işlemleri) çalışan işlem ve kişilerin türü ve bu alanın büyük kapsamı nedeniyle, bir sonraki bölümün tamamı bunu açıklayan şekilde hazırlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-247">Because running and managing applications at enterprise-production level is a major subject in and of itself, and due to the type of operations and people working at that level (IT operations) as well as the large scope of this area, the entire next chapter is devoted to explaining it.</span></span>

## <a name="step-6-monitor-and-diagnose"></a><span data-ttu-id="9bfb1-248">6. Adım: Izleme ve tanılama</span><span class="sxs-lookup"><span data-stu-id="9bfb1-248">Step 6: Monitor and diagnose</span></span>

<span data-ttu-id="9bfb1-249">Bu konu ayrıca, üretim sistemlerinde gerçekleştirdiği görevlerin bir parçası olarak sonraki bölümde ele alınmıştır. Bununla birlikte, uygulamanın sürekli geliştirilmesi için bu adımda elde edilen öngörülerin geliştirme ekibine geri akışı gerektiğini vurgulamak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-249">This topic also is covered in the next chapter as part of the tasks that IT performs in production systems; however, is important to highlight that the insights obtained in this step must feed back to the development team so that the application is constantly improved.</span></span> <span data-ttu-id="9bfb1-250">Bu görünüm noktasından de DevOps 'un bir parçası olsa da, görevler ve işlemler yaygın olarak gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-250">From that point of view, it's also part of DevOps, although the tasks and operations are commonly performed by IT.</span></span>

<span data-ttu-id="9bfb1-251">Yalnızca izleme ve tanılama, DevOps bölgesi kapsamında %100 olduğunda, geliştirme ekibi tarafından test veya beta ortamlarına karşı gerçekleştirilen izleme işlemleri ve analizlerdir.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-251">Only when monitoring and diagnostics are 100% within the realm of DevOps are the monitoring processes and analytics performed by the development team against testing or beta environments.</span></span> <span data-ttu-id="9bfb1-252">Bu işlem, yük testi gerçekleştirerek veya Beta Test edicilerin yeni sürümleri çalıştığı Beta ya da QA ortamlarını izleyerek yapılır.</span><span class="sxs-lookup"><span data-stu-id="9bfb1-252">This is done either by performing load testing or by monitoring beta or QA environments, where beta testers are trying the new versions.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="9bfb1-253">[Önceki](index.md) 
> [Sonraki](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span><span class="sxs-lookup"><span data-stu-id="9bfb1-253">[Previous](index.md)
[Next](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span></span>
