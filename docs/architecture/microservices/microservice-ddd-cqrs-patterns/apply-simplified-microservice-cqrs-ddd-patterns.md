---
title: Bir mikro hizmete CQRS ve DDD desenlerini uygulama
description: Kapsayıcılı .NET uygulamaları için .NET mikro hizmetleri mimarisi | CQRS ve DDD desenleri arasındaki genel ilişkiyi anlayın.
ms.date: 10/08/2018
ms.openlocfilehash: 36bffce37176aed6c7d9daea7f2995952b58e895
ms.sourcegitcommit: f20dd18dbcf2275513281f5d9ad7ece6a62644b4
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 07/30/2019
ms.locfileid: "70296003"
---
# <a name="apply-simplified-cqrs-and-ddd-patterns-in-a-microservice"></a><span data-ttu-id="87245-103">Mikro hizmette Basitleştirilmiş CQRS ve DDD desenleri uygulama</span><span class="sxs-lookup"><span data-stu-id="87245-103">Apply simplified CQRS and DDD patterns in a microservice</span></span>

<span data-ttu-id="87245-104">CQRS, verileri okuma ve yazma modellerini ayıran mimari bir modeldir.</span><span class="sxs-lookup"><span data-stu-id="87245-104">CQRS is an architectural pattern that separates the models for reading and writing data.</span></span> <span data-ttu-id="87245-105">İlgili terim [komut sorgu ayrımı (CQS)](https://martinfowler.com/bliki/CommandQuerySeparation.html) başlangıçta, kitap *nesne yönelimli yazılım oluşturma*bölümünde bertrve Meyer tarafından tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="87245-105">The related term [Command Query Separation (CQS)](https://martinfowler.com/bliki/CommandQuerySeparation.html) was originally defined by Bertrand Meyer in his book *Object Oriented Software Construction*.</span></span> <span data-ttu-id="87245-106">Temel düşünce, bir sistemin işlemlerini iki keskin ayrı kategoriye bölememektir:</span><span class="sxs-lookup"><span data-stu-id="87245-106">The basic idea is that you can divide a system’s operations into two sharply separated categories:</span></span>

- <span data-ttu-id="87245-107">Lardır.</span><span class="sxs-lookup"><span data-stu-id="87245-107">Queries.</span></span> <span data-ttu-id="87245-108">Bu bir sonuç döndürür ve sistemin durumunu değiştirmez ve yan etkileri ücretsizdir.</span><span class="sxs-lookup"><span data-stu-id="87245-108">These return a result and do not change the state of the system, and they are free of side effects.</span></span>

- <span data-ttu-id="87245-109">Komut.</span><span class="sxs-lookup"><span data-stu-id="87245-109">Commands.</span></span> <span data-ttu-id="87245-110">Bu, bir sistemin durumunu değiştirir.</span><span class="sxs-lookup"><span data-stu-id="87245-110">These change the state of a system.</span></span>

<span data-ttu-id="87245-111">CQS basit bir kavramdır; aynı nesne içindeki Yöntemler ya da komutlar.</span><span class="sxs-lookup"><span data-stu-id="87245-111">CQS is a simple concept—it is about methods within the same object being either queries or commands.</span></span> <span data-ttu-id="87245-112">Her yöntem durum döndürür veya durumu değiştirmez, ancak ikisini birden etmez.</span><span class="sxs-lookup"><span data-stu-id="87245-112">Each method either returns state or mutates state, but not both.</span></span> <span data-ttu-id="87245-113">Tek bir depo deseninin bir nesnesi de CQS ile uyumlu olabilir.</span><span class="sxs-lookup"><span data-stu-id="87245-113">Even a single repository pattern object can comply with CQS.</span></span> <span data-ttu-id="87245-114">CQS 'ler, CQRS için temel bir ilke olarak düşünülebilir.</span><span class="sxs-lookup"><span data-stu-id="87245-114">CQS can be considered a foundational principle for CQRS.</span></span>

<span data-ttu-id="87245-115">[Komut ve sorgu sorumluluklarının ayrılığı (CQRS)](https://martinfowler.com/bliki/CQRS.html) , Greg başak tarafından sunulmuştur ve UDI Dahan ve diğerleri tarafından güçlü bir şekilde yükseltildi.</span><span class="sxs-lookup"><span data-stu-id="87245-115">[Command and Query Responsibility Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html) was introduced by Greg Young and strongly promoted by Udi Dahan and others.</span></span> <span data-ttu-id="87245-116">Daha ayrıntılı olsa da, CQS ilkesini temel alır.</span><span class="sxs-lookup"><span data-stu-id="87245-116">It is based on the CQS principle, although it is more detailed.</span></span> <span data-ttu-id="87245-117">Komutların ve olayların yanı sıra zaman uyumsuz iletilerde isteğe bağlı olarak bir model olarak düşünülebilir.</span><span class="sxs-lookup"><span data-stu-id="87245-117">It can be considered a pattern based on commands and events plus optionally on asynchronous messages.</span></span> <span data-ttu-id="87245-118">Birçok durumda, CQRS, yazma (güncelleştirme) için farklı bir fiziksel veritabanı okuma (sorgular) gibi daha gelişmiş senaryolar ile ilgilidir.</span><span class="sxs-lookup"><span data-stu-id="87245-118">In many cases, CQRS is related to more advanced scenarios, like having a different physical database for reads (queries) than for writes (updates).</span></span> <span data-ttu-id="87245-119">Üstelik, daha gelişmiş bir CQRS sistemi, güncelleştirmeler veritabanınız için [olay kaynağını (es)](https://martinfowler.com/eaaDev/EventSourcing.html) uygulayabilir, bu nedenle olayları yalnızca geçerli durum verilerini depolamak yerine etki alanı modelinde depolarsınız.</span><span class="sxs-lookup"><span data-stu-id="87245-119">Moreover, a more evolved CQRS system might implement [Event-Sourcing (ES)](https://martinfowler.com/eaaDev/EventSourcing.html) for your updates database, so you would only store events in the domain model instead of storing the current-state data.</span></span> <span data-ttu-id="87245-120">Ancak, bu kılavuzda kullanılan yaklaşım değildir; yalnızca komutlardan oluşan sorguları ayıran en basit CQRS yaklaşımını kullanıyoruz.</span><span class="sxs-lookup"><span data-stu-id="87245-120">However, this is not the approach used in this guide; we are using the simplest CQRS approach, which consists of just separating the queries from the commands.</span></span>

<span data-ttu-id="87245-121">CQRS 'nin ayrım yönü, sorgu işlemlerini bir katmanda ve komutları başka bir katmanda gruplandırarak elde edilir.</span><span class="sxs-lookup"><span data-stu-id="87245-121">The separation aspect of CQRS is achieved by grouping query operations in one layer and commands in another layer.</span></span> <span data-ttu-id="87245-122">Her katmanın kendi veri modeli vardır (model, farklı bir veritabanı olmak üzere değil) ve kendi desen ve teknolojilerin birleşimi kullanılarak oluşturulmuştur.</span><span class="sxs-lookup"><span data-stu-id="87245-122">Each layer has its own data model (note that we say model, not necessarily a different database) and is built using its own combination of patterns and technologies.</span></span> <span data-ttu-id="87245-123">Daha da önemlisi, bu kılavuz için kullanılan örnekte olduğu gibi iki katman aynı katmanda veya mikro hizmette olabilir (sıralama mikro hizmeti).</span><span class="sxs-lookup"><span data-stu-id="87245-123">More importantly, the two layers can be within the same tier or microservice, as in the example (ordering microservice) used for this guide.</span></span> <span data-ttu-id="87245-124">Ya da farklı mikro hizmetlere veya süreçlere uygulanabilmeniz için, bunların bir diğeri etkilenmeden ayrı olarak iyileştirilebilir ve ölçeklenmesini sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="87245-124">Or they could be implemented on different microservices or processes so they can be optimized and scaled out separately without affecting one another.</span></span>

<span data-ttu-id="87245-125">CQRS, diğer bağlamlarda bir okuma/yazma işlemi için iki nesneye sahip olduğu anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="87245-125">CQRS means having two objects for a read/write operation where in other contexts there is one.</span></span> <span data-ttu-id="87245-126">Daha gelişmiş CQRS belgeleriyle ilgili bilgi edinmek için, daha fazla sayıda okuma veritabanına sahip olma nedenleri vardır.</span><span class="sxs-lookup"><span data-stu-id="87245-126">There are reasons to have a denormalized reads database, which you can learn about in more advanced CQRS literature.</span></span> <span data-ttu-id="87245-127">Ancak bu yaklaşımı burada kullandığımızda, hedefin toplamalar gibi DDD desenlerinden gelen sorguları sınırlamak yerine sorgularda daha fazla esneklik elde eteceğiz.</span><span class="sxs-lookup"><span data-stu-id="87245-127">But we are not using that approach here, where the goal is to have more flexibility in the queries instead of limiting the queries with constraints from DDD patterns like aggregates.</span></span>

<span data-ttu-id="87245-128">Bu tür bir hizmet örneği, eShopOnContainers başvuru uygulamasından sipariş eden mikro hizmettir.</span><span class="sxs-lookup"><span data-stu-id="87245-128">An example of this kind of service is the ordering microservice from the eShopOnContainers reference application.</span></span> <span data-ttu-id="87245-129">Bu hizmet, Basitleştirilmiş bir CQRS yaklaşımını temel alan bir mikro hizmet uygular.</span><span class="sxs-lookup"><span data-stu-id="87245-129">This service implements a microservice based on a simplified CQRS approach.</span></span> <span data-ttu-id="87245-130">Tek bir veri kaynağını veya veritabanını kullanır, ancak Şekil 7-2 ' de gösterildiği gibi, işlem etki alanı için iki mantıksal model ve ggg desenleri.</span><span class="sxs-lookup"><span data-stu-id="87245-130">It uses a single data source or database, but two logical models plus DDD patterns for the transactional domain, as shown in Figure 7-2.</span></span>

![Mantıksal sıralama mikro hizmeti, aynı Docker konağında olabilen veya bulunmayan sıralama veritabanını içerir.](./media/image2.png)

<span data-ttu-id="87245-133">**Şekil 7-2**.</span><span class="sxs-lookup"><span data-stu-id="87245-133">**Figure 7-2**.</span></span> <span data-ttu-id="87245-134">Basitleştirilmiş CQRS ve DDD tabanlı mikro hizmet</span><span class="sxs-lookup"><span data-stu-id="87245-134">Simplified CQRS- and DDD-based microservice</span></span>

<span data-ttu-id="87245-135">Uygulama katmanı Web API 'SI olabilir.</span><span class="sxs-lookup"><span data-stu-id="87245-135">The application layer can be the Web API itself.</span></span> <span data-ttu-id="87245-136">Buradaki önemli tasarım, mikro hizmetin sorguları ve Viewmodellerini (istemci uygulamalar için özel olarak oluşturulan veri modelleri), CQRS deseninin altındaki komutlardan, etki alanı modelinden ve işlemlerden ayırmıştır.</span><span class="sxs-lookup"><span data-stu-id="87245-136">The important design aspect here is that the microservice has split the queries and ViewModels (data models especially created for the client applications) from the commands, domain model, and transactions following the CQRS pattern.</span></span> <span data-ttu-id="87245-137">Bu yaklaşım, sonraki bölümlerde açıklandığı gibi, yalnızca işlemler ve güncelleştirmeler için anlamlı olan DDD desenlerinden gelen kısıtlamaların ve kısıtlamalardan bağımsız olarak sorguları korur.</span><span class="sxs-lookup"><span data-stu-id="87245-137">This approach keeps the queries independent from restrictions and constraints coming from DDD patterns that only make sense for transactions and updates, as explained in later sections.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="87245-138">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="87245-138">Additional resources</span></span>

- <span data-ttu-id="87245-139">**Greg başak. Olay kaynağını alınmış bir sistemde** sürüm oluşturma (çevrimiçi e-kitabı okumak için ücretsiz) </span><span class="sxs-lookup"><span data-stu-id="87245-139">**Greg Young. Versioning in an Event Sourced System** (Free to read online e-book) </span></span>\
   <https://leanpub.com/esversioning/read>

>[!div class="step-by-step"]
><span data-ttu-id="87245-140">[Önceki](index.md)İleri
>[](eshoponcontainers-cqrs-ddd-microservice.md)</span><span class="sxs-lookup"><span data-stu-id="87245-140">[Previous](index.md)
[Next](eshoponcontainers-cqrs-ddd-microservice.md)</span></span>
