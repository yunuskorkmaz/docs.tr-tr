---
title: Performans konuları (Entity Framework)
ms.date: 03/30/2017
ms.assetid: 61913f3b-4f42-4d9b-810f-2a13c2388a4a
ms.openlocfilehash: 4836125205f3d4cbbe852c92f2a88aca331ded70
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 08/22/2019
ms.locfileid: "69962245"
---
# <a name="performance-considerations-entity-framework"></a><span data-ttu-id="ede7a-102">Performans konuları (Entity Framework)</span><span class="sxs-lookup"><span data-stu-id="ede7a-102">Performance Considerations (Entity Framework)</span></span>
<span data-ttu-id="ede7a-103">Bu konu, ADO.NET Entity Framework performans özelliklerini açıklar ve Entity Framework uygulamaların performansını artırmaya yardımcı olmak için bazı hususlar sağlar.</span><span class="sxs-lookup"><span data-stu-id="ede7a-103">This topic describes performance characteristics of the ADO.NET Entity Framework and provides some considerations to help improve the performance of Entity Framework applications.</span></span>  
  
## <a name="stages-of-query-execution"></a><span data-ttu-id="ede7a-104">Sorgu yürütme aşamaları</span><span class="sxs-lookup"><span data-stu-id="ede7a-104">Stages of Query Execution</span></span>  
 <span data-ttu-id="ede7a-105">Entity Framework sorguların performansını daha iyi anlamak için, bir sorgu kavramsal bir modelde yürütüldüğünde oluşan işlemleri anlamak ve verileri nesne olarak döndürmek yararlı olur.</span><span class="sxs-lookup"><span data-stu-id="ede7a-105">In order to better understand the performance of queries in the Entity Framework, it is helpful to understand the operations that occur when a query executes against a conceptual model and returns data as objects.</span></span> <span data-ttu-id="ede7a-106">Aşağıdaki tabloda bu işlem dizisi açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="ede7a-106">The following table describes this series of operations.</span></span>  
  
|<span data-ttu-id="ede7a-107">Çalışma</span><span class="sxs-lookup"><span data-stu-id="ede7a-107">Operation</span></span>|<span data-ttu-id="ede7a-108">Göreli maliyet</span><span class="sxs-lookup"><span data-stu-id="ede7a-108">Relative Cost</span></span>|<span data-ttu-id="ede7a-109">Sıklık</span><span class="sxs-lookup"><span data-stu-id="ede7a-109">Frequency</span></span>|<span data-ttu-id="ede7a-110">Açıklamalar</span><span class="sxs-lookup"><span data-stu-id="ede7a-110">Comments</span></span>|  
|---------------|-------------------|---------------|--------------|  
|<span data-ttu-id="ede7a-111">Meta veriler yükleniyor</span><span class="sxs-lookup"><span data-stu-id="ede7a-111">Loading metadata</span></span>|<span data-ttu-id="ede7a-112">Düzey</span><span class="sxs-lookup"><span data-stu-id="ede7a-112">Moderate</span></span>|<span data-ttu-id="ede7a-113">Her uygulama etki alanında bir kez.</span><span class="sxs-lookup"><span data-stu-id="ede7a-113">Once in each application domain.</span></span>|<span data-ttu-id="ede7a-114">Entity Framework tarafından kullanılan model ve eşleme meta verileri bir ' a <xref:System.Data.Metadata.Edm.MetadataWorkspace>yüklenir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-114">Model and mapping metadata used by the Entity Framework is loaded into a <xref:System.Data.Metadata.Edm.MetadataWorkspace>.</span></span> <span data-ttu-id="ede7a-115">Bu meta veriler genel olarak önbelleğe alınır ve aynı uygulama etki alanındaki <xref:System.Data.Objects.ObjectContext> diğer örnekleri için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-115">This metadata is cached globally and is available to other instances of <xref:System.Data.Objects.ObjectContext> in the same application domain.</span></span>|  
|<span data-ttu-id="ede7a-116">Veritabanı bağlantısı açılıyor</span><span class="sxs-lookup"><span data-stu-id="ede7a-116">Opening the database connection</span></span>|<span data-ttu-id="ede7a-117">Orta<sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="ede7a-117">Moderate<sup>1</sup></span></span>|<span data-ttu-id="ede7a-118">Gerektiğinde.</span><span class="sxs-lookup"><span data-stu-id="ede7a-118">As needed.</span></span>|<span data-ttu-id="ede7a-119">Veritabanına açık bir bağlantı değerli bir kaynak [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] kullandığından, veritabanı bağlantısını yalnızca gerektiğinde açar ve kapatır.</span><span class="sxs-lookup"><span data-stu-id="ede7a-119">Because an open connection to the database consumes a valuable resource, the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] opens and closes the database connection only as needed.</span></span> <span data-ttu-id="ede7a-120">Ayrıca bağlantıyı açık bir şekilde açabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ede7a-120">You can also explicitly open the connection.</span></span> <span data-ttu-id="ede7a-121">Daha fazla bilgi için bkz. [bağlantıları ve Işlemleri yönetme](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="ede7a-121">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>|  
|<span data-ttu-id="ede7a-122">Görünümler üretiliyor</span><span class="sxs-lookup"><span data-stu-id="ede7a-122">Generating views</span></span>|<span data-ttu-id="ede7a-123">Yüksek</span><span class="sxs-lookup"><span data-stu-id="ede7a-123">High</span></span>|<span data-ttu-id="ede7a-124">Her uygulama etki alanında bir kez.</span><span class="sxs-lookup"><span data-stu-id="ede7a-124">Once in each application domain.</span></span> <span data-ttu-id="ede7a-125">(Önceden oluşturulmuş olabilir.)</span><span class="sxs-lookup"><span data-stu-id="ede7a-125">(Can be pre-generated.)</span></span>|<span data-ttu-id="ede7a-126">Entity Framework, kavramsal bir modelde sorgu yürütebilmesi veya veri kaynağına değişiklikleri kaydedebilmek için, veritabanına erişmek üzere bir yerel sorgu görünümleri kümesi oluşturması gerekir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-126">Before the Entity Framework can execute a query against a conceptual model or save changes to the data source, it must generate a set of local query views to access the database.</span></span> <span data-ttu-id="ede7a-127">Bu görünümlerin oluşturulması için yüksek maliyetli olduğundan, görünümleri önceden oluşturabilir ve tasarım zamanında projeye ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ede7a-127">Because of the high cost of generating these views, you can pre-generate the views and add them to the project at design-time.</span></span> <span data-ttu-id="ede7a-128">Daha fazla bilgi için [nasıl yapılır: Sorgu performansını](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100))artırmak Için görünümleri önceden oluşturun.</span><span class="sxs-lookup"><span data-stu-id="ede7a-128">For more information, see [How to: Pre-Generate Views to Improve Query Performance](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span></span>|  
|<span data-ttu-id="ede7a-129">Sorgu hazırlanıyor</span><span class="sxs-lookup"><span data-stu-id="ede7a-129">Preparing the query</span></span>|<span data-ttu-id="ede7a-130">Orta<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="ede7a-130">Moderate<sup>2</sup></span></span>|<span data-ttu-id="ede7a-131">Her benzersiz sorgu için bir kez.</span><span class="sxs-lookup"><span data-stu-id="ede7a-131">Once for each unique query.</span></span>|<span data-ttu-id="ede7a-132">Sorgu komutunu oluşturma, model ve eşleme meta verilerini temel alan bir komut ağacı oluşturma ve döndürülen verilerin şeklini tanımlama maliyetlerini içerir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-132">Includes the costs to compose the query command, generate a command tree based on model and mapping metadata, and define the shape of the returned data.</span></span> <span data-ttu-id="ede7a-133">Artık hem Entity SQL sorgu komutları hem de LINQ sorguları önbelleğe alındığından, aynı sorgunun sonraki yürütmeleri daha az zaman alır.</span><span class="sxs-lookup"><span data-stu-id="ede7a-133">Because now both Entity SQL query commands and LINQ queries are cached, later executions of the same query take less time.</span></span> <span data-ttu-id="ede7a-134">Daha sonraki yürütmeler ve derlenmiş sorgularda bu maliyeti azaltmak için derlenen LINQ sorgularını kullanmaya devam edebilirsiniz ve derlenen sorgular otomatik olarak önbelleğe alınan LINQ sorgularından daha verimli olabilir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-134">You can still use compiled LINQ queries to reduce this cost in later executions and compiled queries can be more efficient than LINQ queries that are automatically cached.</span></span> <span data-ttu-id="ede7a-135">Daha fazla bilgi için bkz. [derlenmiş sorgular (LINQ to Entities)](../../../../../docs/framework/data/adonet/ef/language-reference/compiled-queries-linq-to-entities.md).</span><span class="sxs-lookup"><span data-stu-id="ede7a-135">For more information, see [Compiled Queries  (LINQ to Entities)](../../../../../docs/framework/data/adonet/ef/language-reference/compiled-queries-linq-to-entities.md).</span></span> <span data-ttu-id="ede7a-136">LINQ sorgu yürütmesi hakkında genel bilgi için bkz. [LINQ to Entities](../../../../../docs/framework/data/adonet/ef/language-reference/linq-to-entities.md).</span><span class="sxs-lookup"><span data-stu-id="ede7a-136">For general information about LINQ query execution, see [LINQ to Entities](../../../../../docs/framework/data/adonet/ef/language-reference/linq-to-entities.md).</span></span> <span data-ttu-id="ede7a-137">**Not:**  Bu işleci, `Enumerable.Contains` bellek içi koleksiyonlara uygulayan LINQ to Entities sorguları otomatik olarak önbelleğe alınmaz.</span><span class="sxs-lookup"><span data-stu-id="ede7a-137">**Note:**  LINQ to Entities queries that apply the `Enumerable.Contains` operator to in-memory collections are not automatically cached.</span></span> <span data-ttu-id="ede7a-138">Ayrıca, derlenen LINQ sorgularında bellek içi koleksiyonlara parametreleştirmeye izin verilmez.</span><span class="sxs-lookup"><span data-stu-id="ede7a-138">Also parameterizing in-memory collections in compiled LINQ queries is not allowed.</span></span>|  
|<span data-ttu-id="ede7a-139">Sorgu Yürütülüyor</span><span class="sxs-lookup"><span data-stu-id="ede7a-139">Executing the query</span></span>|<span data-ttu-id="ede7a-140">Düşük<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="ede7a-140">Low<sup>2</sup></span></span>|<span data-ttu-id="ede7a-141">Her sorgu için bir kez.</span><span class="sxs-lookup"><span data-stu-id="ede7a-141">Once for each query.</span></span>|<span data-ttu-id="ede7a-142">ADO.NET veri sağlayıcısı kullanılarak, komutu veri kaynağında yürütme maliyeti.</span><span class="sxs-lookup"><span data-stu-id="ede7a-142">The cost of executing the command against the data source by using the ADO.NET data provider.</span></span> <span data-ttu-id="ede7a-143">Çoğu veri kaynağı sorgu planlarını aştığından, aynı sorgunun daha sonraki yürütmeleri daha da az zaman alabilir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-143">Because most data sources cache query plans, later executions of the same query may take even less time.</span></span>|  
|<span data-ttu-id="ede7a-144">Türleri yükleme ve doğrulama</span><span class="sxs-lookup"><span data-stu-id="ede7a-144">Loading and validating types</span></span>|<span data-ttu-id="ede7a-145">Düşük<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="ede7a-145">Low<sup>3</sup></span></span>|<span data-ttu-id="ede7a-146">Her <xref:System.Data.Objects.ObjectContext> örnek için bir kez.</span><span class="sxs-lookup"><span data-stu-id="ede7a-146">Once for each <xref:System.Data.Objects.ObjectContext> instance.</span></span>|<span data-ttu-id="ede7a-147">Türler, kavramsal modelin tanımladığı türlere göre yüklenir ve onaylanır.</span><span class="sxs-lookup"><span data-stu-id="ede7a-147">Types are loaded and validated against the types that the conceptual model defines.</span></span>|  
|<span data-ttu-id="ede7a-148">İzleme</span><span class="sxs-lookup"><span data-stu-id="ede7a-148">Tracking</span></span>|<span data-ttu-id="ede7a-149">Düşük<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="ede7a-149">Low<sup>3</sup></span></span>|<span data-ttu-id="ede7a-150">Bir sorgunun döndürdüğü her nesne için bir kez.</span><span class="sxs-lookup"><span data-stu-id="ede7a-150">Once for each object that a query returns.</span></span> <span data-ttu-id="ede7a-151"><sup>4</sup></span><span class="sxs-lookup"><span data-stu-id="ede7a-151"><sup>4</sup></span></span>|<span data-ttu-id="ede7a-152">Bir sorgu <xref:System.Data.Objects.MergeOption.NoTracking> Merge seçeneğini kullanıyorsa, bu aşama performansı etkilemez.</span><span class="sxs-lookup"><span data-stu-id="ede7a-152">If a query uses the <xref:System.Data.Objects.MergeOption.NoTracking> merge option, this stage does not affect performance.</span></span><br /><br /> <span data-ttu-id="ede7a-153">Sorgu <xref:System.Data.Objects.MergeOption.AppendOnly>, <xref:System.Data.Objects.MergeOption.PreserveChanges>, veya <xref:System.Data.Objects.MergeOption.OverwriteChanges> Merge seçeneğinikullanıyorsasorgusonuçlarıiçindeizlenir.<xref:System.Data.Objects.ObjectStateManager></span><span class="sxs-lookup"><span data-stu-id="ede7a-153">If the query uses the <xref:System.Data.Objects.MergeOption.AppendOnly>, <xref:System.Data.Objects.MergeOption.PreserveChanges>, or <xref:System.Data.Objects.MergeOption.OverwriteChanges> merge option, query results are tracked in the <xref:System.Data.Objects.ObjectStateManager>.</span></span> <span data-ttu-id="ede7a-154">Sorgu tarafından döndürülen ve <xref:System.Data.Objects.ObjectStateEntry> içinde <xref:System.Data.Objects.ObjectStateManager>oluşturmak için kullanılan her izlenen nesne için oluşturulur. <xref:System.Data.EntityKey></span><span class="sxs-lookup"><span data-stu-id="ede7a-154">An <xref:System.Data.EntityKey> is generated for each tracked object that the query returns and is used to create an <xref:System.Data.Objects.ObjectStateEntry> in the <xref:System.Data.Objects.ObjectStateManager>.</span></span> <span data-ttu-id="ede7a-155">İçin var olan <xref:System.Data.Objects.ObjectStateEntry> bir nesnesi bulunursa ,varolannesnedöndürülür.<xref:System.Data.EntityKey></span><span class="sxs-lookup"><span data-stu-id="ede7a-155">If an existing <xref:System.Data.Objects.ObjectStateEntry> can be found for the <xref:System.Data.EntityKey>, the existing object is returned.</span></span> <span data-ttu-id="ede7a-156"><xref:System.Data.Objects.MergeOption.PreserveChanges>, Veya<xref:System.Data.Objects.MergeOption.OverwriteChanges> seçeneği kullanılırsa, nesne döndürülmeden önce güncelleştirilir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-156">If the <xref:System.Data.Objects.MergeOption.PreserveChanges>, or <xref:System.Data.Objects.MergeOption.OverwriteChanges> option is used, the object is updated before it is returned.</span></span><br /><br /> <span data-ttu-id="ede7a-157">Daha fazla bilgi için bkz. [kimlik çözümleme, durum yönetimi ve değişiklik izleme](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="ede7a-157">For more information, see [Identity Resolution, State Management, and Change Tracking](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span></span>|  
|<span data-ttu-id="ede7a-158">Nesneleri görselleştirme</span><span class="sxs-lookup"><span data-stu-id="ede7a-158">Materializing the objects</span></span>|<span data-ttu-id="ede7a-159">Orta<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="ede7a-159">Moderate<sup>3</sup></span></span>|<span data-ttu-id="ede7a-160">Bir sorgunun döndürdüğü her nesne için bir kez.</span><span class="sxs-lookup"><span data-stu-id="ede7a-160">Once for each object that a query returns.</span></span> <span data-ttu-id="ede7a-161"><sup>4</sup></span><span class="sxs-lookup"><span data-stu-id="ede7a-161"><sup>4</sup></span></span>|<span data-ttu-id="ede7a-162">Döndürülen <xref:System.Data.Common.DbDataReader> nesneyi okuma ve nesne oluşturma ve <xref:System.Data.Common.DbDataRecord> sınıfın her örneğindeki değerleri temel alan özellik değerlerini ayarlama işlemi.</span><span class="sxs-lookup"><span data-stu-id="ede7a-162">The process of reading the returned <xref:System.Data.Common.DbDataReader> object and creating objects and setting property values that are based on the values in each instance of the <xref:System.Data.Common.DbDataRecord> class.</span></span> <span data-ttu-id="ede7a-163">Nesnesi içinde <xref:System.Data.Objects.ObjectContext> zaten varsa ve sorgu <xref:System.Data.Objects.MergeOption.AppendOnly> veya <xref:System.Data.Objects.MergeOption.PreserveChanges> birleştirme seçeneklerini kullanıyorsa, bu aşama performansı etkilemez.</span><span class="sxs-lookup"><span data-stu-id="ede7a-163">If the object already exists in the <xref:System.Data.Objects.ObjectContext> and the query uses the <xref:System.Data.Objects.MergeOption.AppendOnly> or <xref:System.Data.Objects.MergeOption.PreserveChanges> merge options, this stage does not affect performance.</span></span> <span data-ttu-id="ede7a-164">Daha fazla bilgi için bkz. [kimlik çözümleme, durum yönetimi ve değişiklik izleme](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="ede7a-164">For more information, see [Identity Resolution, State Management, and Change Tracking](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span></span>|  
  
 <span data-ttu-id="ede7a-165"><sup>1</sup> bir veri kaynağı sağlayıcısı bağlantı havuzunu uygularsa, bir bağlantı açma maliyeti havuza dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="ede7a-165"><sup>1</sup> When a data source provider implements connection pooling, the cost of opening a connection is distributed across the pool.</span></span> <span data-ttu-id="ede7a-166">SQL Server için .NET sağlayıcısı bağlantı kuyruğunu destekler.</span><span class="sxs-lookup"><span data-stu-id="ede7a-166">The .NET Provider for SQL Server supports connection pooling.</span></span>  
  
 <span data-ttu-id="ede7a-167">artan sorgu karmaşıklığı sayesinde <sup>2</sup> maliyet artar.</span><span class="sxs-lookup"><span data-stu-id="ede7a-167"><sup>2</sup> Cost increases with increased query complexity.</span></span>  
  
 <span data-ttu-id="ede7a-168"><sup>3</sup> toplam maliyet, sorgu tarafından döndürülen nesne sayısıyla orantılı olarak artar.</span><span class="sxs-lookup"><span data-stu-id="ede7a-168"><sup>3</sup> Total cost increases proportional to the number of objects returned by the query.</span></span>  
  
 <span data-ttu-id="ede7a-169"><sup>4</sup> EntityClient sorguları bir <xref:System.Data.EntityClient.EntityDataReader> nesne yerine döndürdüğü için bu ek yük, EntityClient sorguları için gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-169"><sup>4</sup> This overhead is not required for EntityClient queries because EntityClient queries return an <xref:System.Data.EntityClient.EntityDataReader> instead of objects.</span></span> <span data-ttu-id="ede7a-170">Daha fazla bilgi için bkz. [Entity Framework Için EntityClient sağlayıcısı](../../../../../docs/framework/data/adonet/ef/entityclient-provider-for-the-entity-framework.md).</span><span class="sxs-lookup"><span data-stu-id="ede7a-170">For more information, see [EntityClient Provider for the Entity Framework](../../../../../docs/framework/data/adonet/ef/entityclient-provider-for-the-entity-framework.md).</span></span>  
  
## <a name="additional-considerations"></a><span data-ttu-id="ede7a-171">Ek konular</span><span class="sxs-lookup"><span data-stu-id="ede7a-171">Additional Considerations</span></span>  
 <span data-ttu-id="ede7a-172">Aşağıda Entity Framework uygulamaların performansını etkileyebilecek diğer noktalar verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-172">The following are other considerations that may affect the performance of Entity Framework applications.</span></span>  
  
### <a name="query-execution"></a><span data-ttu-id="ede7a-173">Sorgu Yürütme</span><span class="sxs-lookup"><span data-stu-id="ede7a-173">Query Execution</span></span>  
 <span data-ttu-id="ede7a-174">Sorgular kaynak kullanımı yoğun olabileceğinden, kodunuzun hangi noktada ve bir sorgunun yürütülebileceğini göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="ede7a-174">Because queries can be resource intensive, consider at what point in your code and on what computer a query is executed.</span></span>  
  
#### <a name="deferred-versus-immediate-execution"></a><span data-ttu-id="ede7a-175">Ertelenmiş ve anında yürütme</span><span class="sxs-lookup"><span data-stu-id="ede7a-175">Deferred versus immediate execution</span></span>  
 <span data-ttu-id="ede7a-176">Bir <xref:System.Data.Objects.ObjectQuery%601> veya LINQ sorgusu oluşturduğunuzda sorgu hemen yürütülemeyebilir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-176">When you create an <xref:System.Data.Objects.ObjectQuery%601> or LINQ query, the query may not be executed immediately.</span></span> <span data-ttu-id="ede7a-177">Sorgu yürütme `foreach` , (C#) veya `For Each` (Visual Basic) numaralandırması sırasında veya bir <xref:System.Collections.Generic.List%601> koleksiyonu dolduracak şekilde atandığında, sonuçlar gerekene kadar ertelenir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-177">Query execution is deferred until the results are needed, such as during a `foreach` (C#) or `For Each` (Visual Basic) enumeration or when it is assigned to fill a <xref:System.Collections.Generic.List%601> collection.</span></span> <span data-ttu-id="ede7a-178">Ya <xref:System.Data.Objects.ObjectQuery%601.Execute%2A> da gibi <xref:System.Data.Objects.ObjectQuery%601> tekbir<xref:System.Linq.Enumerable.Any%2A>sorgu döndüren LINQ yöntemini çağırdığınızda sorgu yürütme hemen başlar. <xref:System.Linq.Enumerable.First%2A></span><span class="sxs-lookup"><span data-stu-id="ede7a-178">Query execution begins immediately when you call the <xref:System.Data.Objects.ObjectQuery%601.Execute%2A> method on an <xref:System.Data.Objects.ObjectQuery%601> or when you call a LINQ method that returns a singleton query, such as <xref:System.Linq.Enumerable.First%2A> or <xref:System.Linq.Enumerable.Any%2A>.</span></span> <span data-ttu-id="ede7a-179">Daha fazla bilgi için bkz. [nesne sorguları](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896241(v=vs.100)) ve [sorgu yürütme (LINQ to Entities)](../../../../../docs/framework/data/adonet/ef/language-reference/query-execution.md).</span><span class="sxs-lookup"><span data-stu-id="ede7a-179">For more information, see [Object Queries](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896241(v=vs.100)) and [Query Execution (LINQ to Entities)](../../../../../docs/framework/data/adonet/ef/language-reference/query-execution.md).</span></span>  
  
#### <a name="client-side-execution-of-linq-queries"></a><span data-ttu-id="ede7a-180">LINQ sorgularının istemci tarafı yürütmesi</span><span class="sxs-lookup"><span data-stu-id="ede7a-180">Client-side execution of LINQ queries</span></span>  
 <span data-ttu-id="ede7a-181">Bir LINQ sorgusunun yürütülmesi, veri kaynağını barındıran bilgisayarda gerçekleşse de, bir LINQ sorgusunun bazı kısımları istemci bilgisayarda değerlendirilemeyebilir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-181">Although the execution of a LINQ query occurs on the computer that hosts the data source, some parts of a LINQ query may be evaluated on the client computer.</span></span> <span data-ttu-id="ede7a-182">Daha fazla bilgi için, [sorgu yürütme (LINQ to Entities)](../../../../../docs/framework/data/adonet/ef/language-reference/query-execution.md)konusunun mağaza yürütme bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="ede7a-182">For more information, see the Store Execution section of [Query Execution (LINQ to Entities)](../../../../../docs/framework/data/adonet/ef/language-reference/query-execution.md).</span></span>  
  
### <a name="query-and-mapping-complexity"></a><span data-ttu-id="ede7a-183">Sorgu ve eşleme karmaşıklığı</span><span class="sxs-lookup"><span data-stu-id="ede7a-183">Query and Mapping Complexity</span></span>  
 <span data-ttu-id="ede7a-184">Tek tek sorguların ve varlık modelindeki eşlemenin karmaşıklığı, sorgu performansı üzerinde önemli bir etkiye sahip olacaktır.</span><span class="sxs-lookup"><span data-stu-id="ede7a-184">The complexity of individual queries and of the mapping in the entity model will have a significant effect on query performance.</span></span>  
  
#### <a name="mapping-complexity"></a><span data-ttu-id="ede7a-185">Eşleme karmaşıklığı</span><span class="sxs-lookup"><span data-stu-id="ede7a-185">Mapping complexity</span></span>  
 <span data-ttu-id="ede7a-186">Kavramsal modeldeki ve depolama modelindeki tablolardaki varlıklar arasında basit bir bire bir eşleştirmenin daha karmaşık olduğu modeller, bire bir eşlemeye sahip modellerden daha karmaşık komutlar oluşturur.</span><span class="sxs-lookup"><span data-stu-id="ede7a-186">Models that are more complex than a simple one-to-one mapping between entities in the conceptual model and tables in the storage model generate more complex commands than models that have a one-to-one mapping.</span></span>  
  
#### <a name="query-complexity"></a><span data-ttu-id="ede7a-187">Sorgu karmaşıklığı</span><span class="sxs-lookup"><span data-stu-id="ede7a-187">Query complexity</span></span>  
 <span data-ttu-id="ede7a-188">Veri kaynağına karşı yürütülen veya büyük miktarda veri döndüren komutlarda çok sayıda birleşim gerektiren sorgular aşağıdaki yollarla performansı etkileyebilir:</span><span class="sxs-lookup"><span data-stu-id="ede7a-188">Queries that require a large number of joins in the commands that are executed against the data source or that return a large amount of data may affect performance in the following ways:</span></span>  
  
- <span data-ttu-id="ede7a-189">Basit görünen kavramsal bir modele yönelik sorgular, veri kaynağında daha karmaşık sorguların yürütülmesine neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-189">Queries against a conceptual model that seem simple may result in the execution of more complex queries against the data source.</span></span> <span data-ttu-id="ede7a-190">Bu durum, Entity Framework bir sorguyu kavramsal bir modelde veri kaynağına karşı eşdeğer bir sorguya çevirdiğinde ortaya çıkabilir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-190">This can occur because the Entity Framework translates a query against a conceptual model into an equivalent query against the data source.</span></span> <span data-ttu-id="ede7a-191">Kavramsal modelde ayarlanan tek bir varlık veri kaynağında birden fazla tabloya eşleniyorsa veya varlıklar arasındaki ilişki bir birleştirme tablosuna eşlendiğinde, veri kaynağı sorgusuna karşı yürütülen sorgu komutu bir veya daha fazla birleşim gerektirebilir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-191">When a single entity set in the conceptual model maps to more than one table in the data source, or when a relationship between entities is mapped to a join table, the query command executed against the data source query may require one or more joins.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="ede7a-192">Belirli bir sorgu için veri <xref:System.Data.Objects.ObjectQuery%601> kaynağına <xref:System.Data.EntityClient.EntityCommand> karşı yürütülen komutları görüntülemek için veya sınıflarının yönteminikullanın.<xref:System.Data.Objects.ObjectQuery.ToTraceString%2A></span><span class="sxs-lookup"><span data-stu-id="ede7a-192">Use the <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> method of the <xref:System.Data.Objects.ObjectQuery%601> or <xref:System.Data.EntityClient.EntityCommand> classes to view the commands that are executed against the data source for a given query.</span></span> <span data-ttu-id="ede7a-193">Daha fazla bilgi için [nasıl yapılır: Mağaza komutlarını](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100))görüntüleyin.</span><span class="sxs-lookup"><span data-stu-id="ede7a-193">For more information, see [How to: View the Store Commands](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span></span>  
  
- <span data-ttu-id="ede7a-194">İç içe Entity SQL sorguları sunucuda birleşimler oluşturabilir ve çok sayıda satır döndürebilir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-194">Nested Entity SQL queries may create joins on the server and can return a large number of rows.</span></span>  
  
     <span data-ttu-id="ede7a-195">Aşağıda, bir izdüşüm yan tümcesindeki iç içe sorgu örneği verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="ede7a-195">The following is an example of a nested query in a projection clause:</span></span>  
  
    ```  
    SELECT c, (SELECT c, (SELECT c FROM AdventureWorksModel.Vendor AS c  ) As Inner2   
        FROM AdventureWorksModel.JobCandidate AS c  ) As Inner1   
        FROM AdventureWorksModel.EmployeeDepartmentHistory AS c  
    ```  
  
     <span data-ttu-id="ede7a-196">Bunlara ek olarak, bu tür sorgular sorgu işlem hattının iç içe sorgularda nesneleri çoğaltmasıyla tek bir sorgu oluşturmasına neden olur.</span><span class="sxs-lookup"><span data-stu-id="ede7a-196">In addition, such queries cause the query pipeline to generate a single query with duplication of objects across nested queries.</span></span> <span data-ttu-id="ede7a-197">Bu nedenle, tek bir sütun birden çok kez yinelenebilir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-197">Because of this, a single column may be duplicated multiple times.</span></span> <span data-ttu-id="ede7a-198">SQL Server dahil bazı veritabanlarında, bu, TempDB tablosunun çok büyük büyümesine neden olabilir ve bu da sunucu performansını düşürebilir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-198">On some databases, including SQL Server, this can cause the TempDB table to grow very large, which can decrease server performance.</span></span> <span data-ttu-id="ede7a-199">İç içe sorguları yürüttüğünüzde dikkatli olunmalıdır.</span><span class="sxs-lookup"><span data-stu-id="ede7a-199">Care should be taken when you execute nested queries.</span></span>  
  
- <span data-ttu-id="ede7a-200">İstemci, kaynakları sonuç kümesinin boyutuyla orantılı bir şekilde kullanan işlemler yapıyorsa, büyük miktarda veri döndüren sorgular performansın düşmesine neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-200">Any queries that return a large amount of data can cause decreased performance if the client is performing operations that consume resources in a way that is proportional to the size of the result set.</span></span> <span data-ttu-id="ede7a-201">Bu gibi durumlarda, sorgu tarafından döndürülen veri miktarını sınırlandırmaya dikkat etmelisiniz.</span><span class="sxs-lookup"><span data-stu-id="ede7a-201">In such cases, you should consider limiting the amount of data returned by the query.</span></span> <span data-ttu-id="ede7a-202">Daha fazla bilgi için [nasıl yapılır: Sorgu sonuçları](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100))aracılığıyla sayfa.</span><span class="sxs-lookup"><span data-stu-id="ede7a-202">For more information, see [How to: Page Through Query Results](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span></span>  
  
 <span data-ttu-id="ede7a-203">Entity Framework tarafından otomatik olarak oluşturulan komutlar, bir veritabanı geliştiricisi tarafından açıkça yazılmış benzer komutlardan daha karmaşık olabilir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-203">Any commands automatically generated by the Entity Framework may be more complex than similar commands written explicitly by a database developer.</span></span> <span data-ttu-id="ede7a-204">Veri kaynağınıza karşı yürütülen komutlar üzerinde açık denetime ihtiyacınız varsa, tablo değerli bir işlev veya saklı yordam için bir eşleme tanımlamayı düşünün.</span><span class="sxs-lookup"><span data-stu-id="ede7a-204">If you need explicit control over the commands executed against your data source, consider defining a mapping to a table-valued function or stored procedure.</span></span>  
  
#### <a name="relationships"></a><span data-ttu-id="ede7a-205">İlişkiler</span><span class="sxs-lookup"><span data-stu-id="ede7a-205">Relationships</span></span>  
 <span data-ttu-id="ede7a-206">En iyi sorgu performansı için, varlıklar arasındaki ilişkiyi varlık modelinde ilişkiler olarak ve veri kaynağında mantıksal ilişkiler olarak tanımlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-206">For optimal query performance, you must define relationships between entities both as associations in the entity model and as logical relationships in the data source.</span></span>  
  
### <a name="query-paths"></a><span data-ttu-id="ede7a-207">Sorgu yolları</span><span class="sxs-lookup"><span data-stu-id="ede7a-207">Query Paths</span></span>  
 <span data-ttu-id="ede7a-208">Varsayılan olarak, bir <xref:System.Data.Objects.ObjectQuery%601>, çalıştırdığınızda ilgili nesneler döndürülmez (ancak, ilişkileri temsil eden nesneler).</span><span class="sxs-lookup"><span data-stu-id="ede7a-208">By default, when you execute an <xref:System.Data.Objects.ObjectQuery%601>, related objects are not returned (although objects that represent the relationships themselves are).</span></span> <span data-ttu-id="ede7a-209">İlgili nesneleri üç şekilde yükleyebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="ede7a-209">You can load related objects in one of three ways:</span></span>  
  
1. <span data-ttu-id="ede7a-210">Yürütülmeden önce <xref:System.Data.Objects.ObjectQuery%601> sorgu yolunu ayarlayın.</span><span class="sxs-lookup"><span data-stu-id="ede7a-210">Set the query path before the <xref:System.Data.Objects.ObjectQuery%601> is executed.</span></span>  
  
2. <span data-ttu-id="ede7a-211">Nesnenin sunduğu gezinti özelliğinde yöntemiçağırın.`Load`</span><span class="sxs-lookup"><span data-stu-id="ede7a-211">Call the `Load` method on the navigation property that the object exposes.</span></span>  
  
3. <span data-ttu-id="ede7a-212"><xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> Seçeneğini<xref:System.Data.Objects.ObjectContext> olarak ayarlayın`true`.</span><span class="sxs-lookup"><span data-stu-id="ede7a-212">Set the <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> option on the <xref:System.Data.Objects.ObjectContext> to `true`.</span></span> <span data-ttu-id="ede7a-213">[Varlık veri modeli Tasarımcısı](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc716685(v=vs.100))ile nesne katmanı kodu oluşturduğunuzda bu otomatik olarak yapılır.</span><span class="sxs-lookup"><span data-stu-id="ede7a-213">Note that this is done automatically when you generate object-layer code with the [Entity Data Model Designer](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc716685(v=vs.100)).</span></span> <span data-ttu-id="ede7a-214">Daha fazla bilgi için bkz. [oluşturulan koda genel bakış](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc982041(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="ede7a-214">For more information see [Generated Code Overview](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc982041(v=vs.100)).</span></span>  
  
 <span data-ttu-id="ede7a-215">Hangi seçeneği kullanacağınızı göz önünde bulundurdığınızda, veritabanının istek sayısı ile tek bir sorguda döndürülen veri miktarı arasında bir zorunluluğunu getirir olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="ede7a-215">When you consider which option to use, be aware that there is a tradeoff between the number of requests against the database and the amount of data returned in a single query.</span></span> <span data-ttu-id="ede7a-216">Daha fazla bilgi için bkz. [Ilgili nesneleri yükleme](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="ede7a-216">For more information, see [Loading Related Objects](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span></span>  
  
#### <a name="using-query-paths"></a><span data-ttu-id="ede7a-217">Sorgu yollarını kullanma</span><span class="sxs-lookup"><span data-stu-id="ede7a-217">Using query paths</span></span>  
 <span data-ttu-id="ede7a-218">Sorgu yolları, bir sorgunun döndürdüğü nesnelerin grafiğini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="ede7a-218">Query paths define the graph of objects that a query returns.</span></span> <span data-ttu-id="ede7a-219">Bir sorgu yolu tanımladığınızda, yolun tanımladığı tüm nesneleri döndürmek için yalnızca veritabanına yönelik tek bir istek gereklidir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-219">When you define a query path, only a single request against the database is required to return all objects that the path defines.</span></span> <span data-ttu-id="ede7a-220">Sorgu yollarının kullanılması, karmaşık komutların basit nesne sorgularının veri kaynağında yürütülmesine neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-220">Using query paths can result in complex commands being executed against the data source from seemingly simple object queries.</span></span> <span data-ttu-id="ede7a-221">Bu durum, ilişkili nesneleri tek bir sorguda döndürmek için bir veya daha fazla birleşim gerektiğinden oluşur.</span><span class="sxs-lookup"><span data-stu-id="ede7a-221">This occurs because one or more joins are required to return related objects in a single query.</span></span> <span data-ttu-id="ede7a-222">Bu karmaşıklık, devralma içeren bir varlık veya çoktan çoğa ilişkiler içeren bir yol gibi karmaşık bir varlık modeline karşı sorgularda daha büyüktür.</span><span class="sxs-lookup"><span data-stu-id="ede7a-222">This complexity is greater in queries against a complex entity model, such as an entity with inheritance or a path that includes many-to-many relationships.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="ede7a-223"><xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> Bir<xref:System.Data.Objects.ObjectQuery%601>tarafından oluşturulacak komutu görmek için yöntemini kullanın.</span><span class="sxs-lookup"><span data-stu-id="ede7a-223">Use the <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> method to see the command that will be generated by an <xref:System.Data.Objects.ObjectQuery%601>.</span></span> <span data-ttu-id="ede7a-224">Daha fazla bilgi için [nasıl yapılır: Mağaza komutlarını](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100))görüntüleyin.</span><span class="sxs-lookup"><span data-stu-id="ede7a-224">For more information, see [How to: View the Store Commands](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span></span>  
  
 <span data-ttu-id="ede7a-225">Bir sorgu yolu çok fazla ilgili nesne içerdiğinde veya nesneler çok fazla satır verisi içerdiğinde, veri kaynağı sorguyu tamamlayamayabilir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-225">When a query path includes too many related objects or the objects contain too much row data, the data source might be unable to complete the query.</span></span> <span data-ttu-id="ede7a-226">Bu, sorgu, veri kaynağının yeteneklerini aşan ara geçici depolama gerektiriyorsa oluşur.</span><span class="sxs-lookup"><span data-stu-id="ede7a-226">This occurs if the query requires intermediate temporary storage that exceeds the capabilities of the data source.</span></span> <span data-ttu-id="ede7a-227">Bu gerçekleştiğinde, ilgili nesneleri açıkça yükleyerek veri kaynağı sorgusunun karmaşıklığını azaltabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ede7a-227">When this occurs, you can reduce the complexity of the data source query by explicitly loading related objects.</span></span>  
  
#### <a name="explicitly-loading-related-objects"></a><span data-ttu-id="ede7a-228">İlgili nesneleri açıkça yükleme</span><span class="sxs-lookup"><span data-stu-id="ede7a-228">Explicitly loading related objects</span></span>  
 <span data-ttu-id="ede7a-229">Bir `Load` <xref:System.Data.Objects.DataClasses.EntityCollection%601> veya döndürenbirgezintiözelliğindeyönteminiçağırarakilgilinesneleriaçıkçayükleyebilirsiniz.<xref:System.Data.Objects.DataClasses.EntityReference%601></span><span class="sxs-lookup"><span data-stu-id="ede7a-229">You can explicitly load related objects by calling the `Load` method on a navigation property that returns an <xref:System.Data.Objects.DataClasses.EntityCollection%601> or <xref:System.Data.Objects.DataClasses.EntityReference%601>.</span></span> <span data-ttu-id="ede7a-230">Açıkça yükleme nesneleri, her `Load` çağrıldığında veritabanına gidiş dönüş gerektirir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-230">Explicitly loading objects requires a round-trip to the database every time `Load` is called.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="ede7a-231">' i ( `Load` `foreach` VisualBasic)kullandığınızdaolduğugibi,döndürülennesnelerkoleksiyonuaracılığıyladöngüyaparkençağrıyaparsanız,verikaynağınaözgüsağlayıcıtekbiriçinbirdençok`For Each` etkin sonuç kümesini desteklemelidir bağlanma.</span><span class="sxs-lookup"><span data-stu-id="ede7a-231">if you call `Load` while looping through a collection of returned objects, such as when you use the `foreach` statement (`For Each` in Visual Basic), the data source-specific provider must support multiple active results sets on a single connection.</span></span> <span data-ttu-id="ede7a-232">SQL Server veritabanı için sağlayıcı bağlantı dizesinde bir değeri `MultipleActiveResultSets = true` belirtmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-232">For a SQL Server database, you must specify a value of `MultipleActiveResultSets = true` in the provider connection string.</span></span>  
  
 <span data-ttu-id="ede7a-233">Ayrıca, varlıklarda bir <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> <xref:System.Data.Objects.DataClasses.EntityCollection%601> veya <xref:System.Data.Objects.DataClasses.EntityReference%601> daha fazla özellik olmadığında yöntemini kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ede7a-233">You can also use the <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> method when there is no <xref:System.Data.Objects.DataClasses.EntityCollection%601> or <xref:System.Data.Objects.DataClasses.EntityReference%601> properties on entities.</span></span> <span data-ttu-id="ede7a-234">Bu, POCO varlıklarını kullanırken faydalıdır.</span><span class="sxs-lookup"><span data-stu-id="ede7a-234">This is useful when you are using POCO entities.</span></span>  
  
 <span data-ttu-id="ede7a-235">İlişkili nesneleri açıkça yükleme, birleştirme sayısını azaltsa ve gereksiz veri miktarını azalttı, `Load` ancak çok sayıda nesne açıkça yüklenirken maliyetli hale gelebilen veritabanına yinelenen bağlantılar gerektirir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-235">Although explicitly loading related objects will reduce the number of joins and reduced the amount of redundant data, `Load` requires repeated connections to the database, which can become costly when explicitly loading a large number of objects.</span></span>  
  
### <a name="saving-changes"></a><span data-ttu-id="ede7a-236">Değişiklikler kaydediliyor</span><span class="sxs-lookup"><span data-stu-id="ede7a-236">Saving Changes</span></span>  
 <span data-ttu-id="ede7a-237"><xref:System.Data.Objects.ObjectContext.SaveChanges%2A> Yöntemini bir<xref:System.Data.Objects.ObjectContext>üzerinde çağırdığınızda, bağlamdaki her eklenen, güncellenen veya silinen nesne için ayrı bir oluşturma, güncelleştirme veya silme komutu oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="ede7a-237">When you call the <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> method on an <xref:System.Data.Objects.ObjectContext>, a separate create, update, or delete command is generated for every added, updated, or deleted object in the context.</span></span> <span data-ttu-id="ede7a-238">Bu komutlar veri kaynağında tek bir işlemde yürütülür.</span><span class="sxs-lookup"><span data-stu-id="ede7a-238">These commands are executed on the data source in a single transaction.</span></span> <span data-ttu-id="ede7a-239">Sorgularda olduğu gibi, oluşturma, güncelleştirme ve silme işlemlerinin performansı kavramsal modeldeki eşlemenin karmaşıklığına bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="ede7a-239">As with queries, the performance of create, update, and delete operations depends on the complexity of the mapping in the conceptual model.</span></span>  
  
### <a name="distributed-transactions"></a><span data-ttu-id="ede7a-240">Dağıtılmış İşlemler</span><span class="sxs-lookup"><span data-stu-id="ede7a-240">Distributed Transactions</span></span>  
 <span data-ttu-id="ede7a-241">Dağıtılmış işlem Düzenleyicisi (DTC) tarafından yönetilen kaynakları gerektiren açık bir işlemdeki işlemler, DTC gerektirmeyen benzer bir işlemden çok daha pahalı olacaktır.</span><span class="sxs-lookup"><span data-stu-id="ede7a-241">Operations in an explicit transaction that require resources that are managed by the distributed transaction coordinator (DTC) will be much more expensive than a similar operation that does not require the DTC.</span></span> <span data-ttu-id="ede7a-242">DTC 'ye yükseltme aşağıdaki durumlarda meydana gelir:</span><span class="sxs-lookup"><span data-stu-id="ede7a-242">Promotion to the DTC will occur in the following situations:</span></span>  
  
- <span data-ttu-id="ede7a-243">SQL Server 2000 veritabanına veya açık işlemleri her zaman DTC 'ye yükseltebileceğiniz diğer veri kaynaklarına karşı bir işlem içeren açık bir işlem.</span><span class="sxs-lookup"><span data-stu-id="ede7a-243">An explicit transaction with an operation against a SQL Server 2000 database or other data source that always promote explicit transactions to the DTC.</span></span>  
  
- <span data-ttu-id="ede7a-244">Bağlantı tarafından [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]yönetilene SQL Server 2005 ' a karşı bir işlem içeren açık bir işlem.</span><span class="sxs-lookup"><span data-stu-id="ede7a-244">An explicit transaction with an operation against SQL Server 2005 when the connection is managed by the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)].</span></span> <span data-ttu-id="ede7a-245">Bu durum SQL Server 2005, bir bağlantı her kapatıldığında ve tek bir işlem içinde yeniden açıldığı zaman bir DTC 'ye ( [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]varsayılan davranış olan) karşı, bu oluşur.</span><span class="sxs-lookup"><span data-stu-id="ede7a-245">This occurs because SQL Server 2005 promotes to a DTC whenever a connection is closed and reopened within a single transaction, which is the default behavior of the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)].</span></span> <span data-ttu-id="ede7a-246">SQL Server 2008 kullanılırken bu DTC yükseltmesi gerçekleşmez.</span><span class="sxs-lookup"><span data-stu-id="ede7a-246">This DTC promotion does not occur when using SQL Server 2008.</span></span> <span data-ttu-id="ede7a-247">SQL Server 2005 kullanırken bu yükseltmeyi önlemek için, işlem içindeki bağlantıyı açıkça açıp kapatmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-247">To avoid this promotion when using SQL Server 2005, you must explicitly open and close the connection within the transaction.</span></span> <span data-ttu-id="ede7a-248">Daha fazla bilgi için bkz. [bağlantıları ve Işlemleri yönetme](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="ede7a-248">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
 <span data-ttu-id="ede7a-249">Bir <xref:System.Transactions> işlem içinde bir veya daha fazla işlem yürütüldüğünde açık bir işlem kullanılır.</span><span class="sxs-lookup"><span data-stu-id="ede7a-249">An explicit transaction is used when one or more operations are executed inside a <xref:System.Transactions> transaction.</span></span> <span data-ttu-id="ede7a-250">Daha fazla bilgi için bkz. [bağlantıları ve Işlemleri yönetme](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="ede7a-250">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
## <a name="strategies-for-improving-performance"></a><span data-ttu-id="ede7a-251">Performansı geliştirme stratejileri</span><span class="sxs-lookup"><span data-stu-id="ede7a-251">Strategies for Improving Performance</span></span>  
 <span data-ttu-id="ede7a-252">Aşağıdaki stratejileri kullanarak Entity Framework sorguların genel performansını geliştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ede7a-252">You can improve the overall performance of queries in the Entity Framework by using the following strategies.</span></span>  
  
#### <a name="pre-generate-views"></a><span data-ttu-id="ede7a-253">Görünümleri önceden oluştur</span><span class="sxs-lookup"><span data-stu-id="ede7a-253">Pre-generate views</span></span>  
 <span data-ttu-id="ede7a-254">Bir uygulama bir sorguyu ilk kez yürüttüğünde, bir varlık modelini temel alan görünümler oluşturmak önemli bir maliyettir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-254">Generating views based on an entity model is a significant cost the first time that an application executes a query.</span></span> <span data-ttu-id="ede7a-255">Tasarım sırasında projeye eklenebilen bir Visual Basic veya C# kod dosyası olarak görünümleri önceden oluşturmak Için EdmGen. exe yardımcı programını kullanın.</span><span class="sxs-lookup"><span data-stu-id="ede7a-255">Use the EdmGen.exe utility to pre-generate views as a Visual Basic or C# code file that can be added to the project during design.</span></span> <span data-ttu-id="ede7a-256">Önceden derlenmiş görünümler oluşturmak için metin şablonu dönüştürme araç takımını da kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ede7a-256">You could also use the Text Template Transformation Toolkit to generate pre-compiled views.</span></span> <span data-ttu-id="ede7a-257">Önceden oluşturulan görünümler, belirtilen varlık modelinin geçerli sürümüyle tutarlı olduklarından emin olmak için çalışma zamanında onaylanır.</span><span class="sxs-lookup"><span data-stu-id="ede7a-257">Pre-generated views are validated at runtime to ensure that they are consistent with the current version of the specified entity model.</span></span> <span data-ttu-id="ede7a-258">Daha fazla bilgi için [nasıl yapılır: Sorgu performansını](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100))artırmak Için görünümleri önceden oluşturun.</span><span class="sxs-lookup"><span data-stu-id="ede7a-258">For more information, see [How to: Pre-Generate Views to Improve Query Performance](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span></span>
  
 <span data-ttu-id="ede7a-259">Çok büyük modellerle çalışırken aşağıdaki düşünce geçerlidir:</span><span class="sxs-lookup"><span data-stu-id="ede7a-259">When working with very large models, the following consideration applies:</span></span>  
  
 <span data-ttu-id="ede7a-260">.NET meta veri biçimi, belirli bir ikilide bulunan Kullanıcı dizesi karakterlerinin sayısını 16.777.215 (0xFFFFFF) olarak sınırlar.</span><span class="sxs-lookup"><span data-stu-id="ede7a-260">The .NET metadata format limits the number of user string characters in a given binary to 16,777,215 (0xFFFFFF).</span></span> <span data-ttu-id="ede7a-261">Çok büyük bir model için görünümler oluşturuyorsanız ve görünüm dosyası bu boyut sınırına ulaşırsa, "daha fazla kullanıcı dizesi oluşturmak için mantıksal alan kalmadı." ifadesini görürsünüz.</span><span class="sxs-lookup"><span data-stu-id="ede7a-261">If you are generating views for a very large model and the view file reaches this size limit, you will get the "No logical space left to create more user strings."</span></span> <span data-ttu-id="ede7a-262">derleme hatası.</span><span class="sxs-lookup"><span data-stu-id="ede7a-262">compile error.</span></span> <span data-ttu-id="ede7a-263">Bu boyut sınırlaması tüm yönetilen ikililer için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-263">This size limitation applies to all managed binaries.</span></span> <span data-ttu-id="ede7a-264">Daha fazla bilgi için, büyük ve karmaşık modellerle çalışırken hatanın nasıl önleneceğini gösteren [bloga](https://go.microsoft.com/fwlink/?LinkId=201476) bakın.</span><span class="sxs-lookup"><span data-stu-id="ede7a-264">For more information see the [blog](https://go.microsoft.com/fwlink/?LinkId=201476) that demonstrates how to avoid the error when working with large and complex models.</span></span>  
  
#### <a name="consider-using-the-notracking-merge-option-for-queries"></a><span data-ttu-id="ede7a-265">Sorgular için NoTracking birleştirme seçeneğini kullanmayı düşünün</span><span class="sxs-lookup"><span data-stu-id="ede7a-265">Consider using the NoTracking merge option for queries</span></span>  
 <span data-ttu-id="ede7a-266">Nesne bağlamındaki döndürülen nesneleri izlemek için gereken bir maliyet vardır.</span><span class="sxs-lookup"><span data-stu-id="ede7a-266">There is a cost required to track returned objects in the object context.</span></span> <span data-ttu-id="ede7a-267">Nesnelerde yapılan değişiklikler algılanıyor ve aynı mantıksal varlık için birden çok isteğin aynı nesne örneğini döndürmesini sağlamak, nesnelerin bir <xref:System.Data.Objects.ObjectContext> örneğe eklenmesini gerektirir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-267">Detecting changes to objects and ensuring that multiple requests for the same logical entity return the same object instance requires that objects be attached to an <xref:System.Data.Objects.ObjectContext> instance.</span></span> <span data-ttu-id="ede7a-268">Nesneler üzerinde güncelleştirme veya silme yapmayı planlamıyorsanız ve kimlik yönetimi gerektirmiyorsa, sorguları yürüttüğünüzde <xref:System.Data.Objects.MergeOption.NoTracking> birleştirme seçeneklerini kullanmayı düşünün.</span><span class="sxs-lookup"><span data-stu-id="ede7a-268">If you do not plan to make updates or deletes to objects and do not require identity management, consider using the <xref:System.Data.Objects.MergeOption.NoTracking> merge options when you execute queries.</span></span>  
  
#### <a name="return-the-correct-amount-of-data"></a><span data-ttu-id="ede7a-269">Doğru miktarda veriyi döndür</span><span class="sxs-lookup"><span data-stu-id="ede7a-269">Return the correct amount of data</span></span>  
 <span data-ttu-id="ede7a-270">Bazı senaryolarda <xref:System.Data.Objects.ObjectQuery%601.Include%2A> yöntemi kullanarak bir sorgu yolunun belirtilmesi, veritabanına daha az gidiş dönüş gerektirdiğinden daha hızlıdır.</span><span class="sxs-lookup"><span data-stu-id="ede7a-270">In some scenarios, specifying a query path using the <xref:System.Data.Objects.ObjectQuery%601.Include%2A> method is much faster because it requires fewer round trips to the database.</span></span> <span data-ttu-id="ede7a-271">Ancak, diğer senaryolarda, daha az birleştirme içeren daha basit sorgular verilerin artıklığına neden olduğu için ilgili nesneleri yüklemek üzere veritabanına yapılan diğer gidiş dönüş daha hızlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-271">However, in other scenarios, additional round trips to the database to load related objects may be faster because the simpler queries with fewer joins result in less redundancy of data.</span></span> <span data-ttu-id="ede7a-272">Bu nedenle, ilgili nesneleri almak için çeşitli yolların performansını sınamanızı öneririz.</span><span class="sxs-lookup"><span data-stu-id="ede7a-272">Because of this, we recommend that you test the performance of various ways to retrieve related objects.</span></span> <span data-ttu-id="ede7a-273">Daha fazla bilgi için bkz. [Ilgili nesneleri yükleme](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="ede7a-273">For more information, see [Loading Related Objects](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span></span>  
  
 <span data-ttu-id="ede7a-274">Tek bir sorguda çok fazla veri döndürmeyi önlemek için sorgunun sonuçlarını daha yönetilebilir gruplar halinde sayfalamayı göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="ede7a-274">To avoid returning too much data in a single query, consider paging the results of the query into more manageable groups.</span></span> <span data-ttu-id="ede7a-275">Daha fazla bilgi için [nasıl yapılır: Sorgu sonuçları](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100))aracılığıyla sayfa.</span><span class="sxs-lookup"><span data-stu-id="ede7a-275">For more information, see [How to: Page Through Query Results](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span></span>  
  
#### <a name="limit-the-scope-of-the-objectcontext"></a><span data-ttu-id="ede7a-276">ObjectContext kapsamını sınırlandırma</span><span class="sxs-lookup"><span data-stu-id="ede7a-276">Limit the scope of the ObjectContext</span></span>  
 <span data-ttu-id="ede7a-277">Çoğu durumda, bir <xref:System.Data.Objects.ObjectContext> `using` deyimin içinde bir örnek oluşturmanız gerekir (`Using…End Using` Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="ede7a-277">In most cases, you should create an <xref:System.Data.Objects.ObjectContext> instance within a `using` statement (`Using…End Using` in Visual Basic).</span></span> <span data-ttu-id="ede7a-278">Bu, kod deyimin bloğundan çıkıldığında nesne bağlamıyla ilişkili kaynakların otomatik olarak atılmasını sağlayarak performansı artırabilir.</span><span class="sxs-lookup"><span data-stu-id="ede7a-278">This can increase performance by ensuring that the resources associated with the object context are disposed automatically when the code exits the statement block.</span></span> <span data-ttu-id="ede7a-279">Ancak, denetimler nesne bağlamı tarafından yönetilen nesnelere bağlandığında, <xref:System.Data.Objects.ObjectContext> bağlamanın gerekli olduğu ve el ile bırakıldığı sürece örnek korunur.</span><span class="sxs-lookup"><span data-stu-id="ede7a-279">However, when controls are bound to objects managed by the object context, the <xref:System.Data.Objects.ObjectContext> instance should be maintained as long as the binding is needed and disposed of manually.</span></span> <span data-ttu-id="ede7a-280">Daha fazla bilgi için bkz. [bağlantıları ve Işlemleri yönetme](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="ede7a-280">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
#### <a name="consider-opening-the-database-connection-manually"></a><span data-ttu-id="ede7a-281">Veritabanı bağlantısını el ile açmayı düşünün</span><span class="sxs-lookup"><span data-stu-id="ede7a-281">Consider opening the database connection manually</span></span>  
 <span data-ttu-id="ede7a-282">Uygulamanız, veri kaynağında <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] oluşturma, güncelleştirme ve silme işlemlerini kalıcı hale getirmek için bir dizi nesne sorgusu veya sık yapılan çağrılar yürüttüğünde, her zaman veri kaynağı bağlantısını açıp kapatmalıdır.</span><span class="sxs-lookup"><span data-stu-id="ede7a-282">When your application executes a series of object queries or frequently calls <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> to persist create, update, and delete operations to the data source, the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] must continuously open and close the connection to the data source.</span></span> <span data-ttu-id="ede7a-283">Bu durumlarda, bu işlemlerin başlangıcında bağlantıyı el ile açmayı ve işlemler tamamlandığında bağlantıyı kapatmayı ya da elden kaldırmayı düşünün.</span><span class="sxs-lookup"><span data-stu-id="ede7a-283">In these situations, consider manually opening the connection at the start of these operations and either closing or disposing of the connection when the operations are complete.</span></span> <span data-ttu-id="ede7a-284">Daha fazla bilgi için bkz. [bağlantıları ve Işlemleri yönetme](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="ede7a-284">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
## <a name="performance-data"></a><span data-ttu-id="ede7a-285">Performans Verileri</span><span class="sxs-lookup"><span data-stu-id="ede7a-285">Performance Data</span></span>  
 <span data-ttu-id="ede7a-286">Entity Framework ilişkin bazı performans verileri [ADO.NET ekip blogundan](https://go.microsoft.com/fwlink/?LinkId=91905)aşağıdaki gönderilerde yayımlanır:</span><span class="sxs-lookup"><span data-stu-id="ede7a-286">Some performance data for the Entity Framework is published in the following posts on the [ADO.NET team blog](https://go.microsoft.com/fwlink/?LinkId=91905):</span></span>  
  
- [<span data-ttu-id="ede7a-287">ADO.NET Entity Framework performansını keşfetme-Bölüm 1</span><span class="sxs-lookup"><span data-stu-id="ede7a-287">Exploring the Performance of the ADO.NET Entity Framework - Part 1</span></span>](https://go.microsoft.com/fwlink/?LinkId=123907)  
  
- [<span data-ttu-id="ede7a-288">ADO.NET Entity Framework performansını keşfetme – Bölüm 2</span><span class="sxs-lookup"><span data-stu-id="ede7a-288">Exploring the Performance of the ADO.NET Entity Framework – Part 2</span></span>](https://go.microsoft.com/fwlink/?LinkId=123909)  
  
- [<span data-ttu-id="ede7a-289">ADO.NET Entity Framework performans karşılaştırması</span><span class="sxs-lookup"><span data-stu-id="ede7a-289">ADO.NET Entity Framework Performance Comparison</span></span>](https://go.microsoft.com/fwlink/?LinkID=123913)  
  
## <a name="see-also"></a><span data-ttu-id="ede7a-290">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="ede7a-290">See also</span></span>

- [<span data-ttu-id="ede7a-291">Geliştirme ve Dağıtım Konuları</span><span class="sxs-lookup"><span data-stu-id="ede7a-291">Development and Deployment Considerations</span></span>](../../../../../docs/framework/data/adonet/ef/development-and-deployment-considerations.md)
