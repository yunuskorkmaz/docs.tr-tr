---
title: Veri Aktarımı Mimarisi Genel Bakış
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- data transfer [WCF], architectural overview
ms.assetid: 343c2ca2-af53-4936-a28c-c186b3524ee9
ms.openlocfilehash: f34bf82ec44140827c5d8da59911afe10ab7a853
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 06/09/2020
ms.locfileid: "84576479"
---
# <a name="data-transfer-architectural-overview"></a><span data-ttu-id="60a12-102">Veri Aktarımı Mimarisi Genel Bakış</span><span class="sxs-lookup"><span data-stu-id="60a12-102">Data Transfer Architectural Overview</span></span>
<span data-ttu-id="60a12-103">Windows Communication Foundation (WCF), bir mesajlaşma altyapısı olarak düşünülebilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-103">Windows Communication Foundation (WCF) can be thought of as a messaging infrastructure.</span></span> <span data-ttu-id="60a12-104">Daha fazla eylem için ileti alabilir, bunları işleyebilir ve Kullanıcı koduna gönderebilir veya Kullanıcı kodu tarafından verilen verilerden iletiler oluşturabilir ve bunları bir hedefe teslim edebilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-104">It can receive messages, process them, and dispatch them to user code for further action, or it can construct messages from data given by user code and deliver them to a destination.</span></span> <span data-ttu-id="60a12-105">Gelişmiş geliştiricilere yönelik bu konu, iletileri ve kapsanan verileri işleme mimarisini açıklar.</span><span class="sxs-lookup"><span data-stu-id="60a12-105">This topic, which is intended for advanced developers, describes the architecture for handling messages and the contained data.</span></span> <span data-ttu-id="60a12-106">Verilerin nasıl gönderileceğini ve alınacağını gösteren daha basit, görev odaklı bir görünüm için bkz. [hizmet sözleşmeleri içinde veri aktarımı belirtme](specifying-data-transfer-in-service-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="60a12-106">For a simpler, task-oriented view of how to send and receive data, see [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="60a12-107">Bu konu, WCF nesne modelini inceleyerek görünmeyen WCF uygulama ayrıntılarını açıklamaktadır.</span><span class="sxs-lookup"><span data-stu-id="60a12-107">This topic discusses WCF implementation details that are not visible by examining the WCF object model.</span></span> <span data-ttu-id="60a12-108">Belgelenmiş uygulama ayrıntıları ile ilgili olarak iki sözcük dikkatli olun.</span><span class="sxs-lookup"><span data-stu-id="60a12-108">Two words of caution are in order with regard to documented implementation details.</span></span> <span data-ttu-id="60a12-109">İlk olarak, açıklamalar basitleştirilmiştir; iyileştirmeler veya diğer nedenlerden dolayı gerçek uygulama daha karmaşık olabilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-109">First, the descriptions are simplified; actual implementation may be more complex due to optimizations or other reasons.</span></span> <span data-ttu-id="60a12-110">İkinci olarak, belirli uygulama ayrıntılarına asla güvenmelisiniz, aksi halde, bu, sürümden sürüme veya bir bakım sürümünde bile fark etmeksizin değişebilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-110">Second, you should never rely on specific implementation details, even documented ones, because these may change without notice from version to version or even in a servicing release.</span></span>  
  
## <a name="basic-architecture"></a><span data-ttu-id="60a12-111">Temel mimari</span><span class="sxs-lookup"><span data-stu-id="60a12-111">Basic Architecture</span></span>  
 <span data-ttu-id="60a12-112">WCF ileti işleme yeteneklerinin çekirdeği, <xref:System.ServiceModel.Channels.Message> [Ileti sınıfını kullanma](using-the-message-class.md)konusunda ayrıntılı olarak açıklanan sınıftır.</span><span class="sxs-lookup"><span data-stu-id="60a12-112">At the core of WCF message-handling capabilities is the <xref:System.ServiceModel.Channels.Message> class, which is described in detail in [Using the Message Class](using-the-message-class.md).</span></span> <span data-ttu-id="60a12-113">WCF çalışma zamanı bileşenleri iki ana parçaya ayrılabilir: kanal yığını ve hizmet çerçevesi, <xref:System.ServiceModel.Channels.Message> sınıf bağlantı noktası olur.</span><span class="sxs-lookup"><span data-stu-id="60a12-113">The run-time components of WCF can be divided into two major parts: the channel stack and the service framework, with the <xref:System.ServiceModel.Channels.Message> class being the connection point.</span></span>  
  
 <span data-ttu-id="60a12-114">Kanal yığını, <xref:System.ServiceModel.Channels.Message> ileti verilerinin gönderilmesi veya alınmasına karşılık gelen geçerli bir örnek ve bazı eylemler arasında dönüştürme yapmaktan sorumludur.</span><span class="sxs-lookup"><span data-stu-id="60a12-114">The channel stack is responsible for converting between a valid <xref:System.ServiceModel.Channels.Message> instance and some action that corresponds to the sending or receiving of message data.</span></span> <span data-ttu-id="60a12-115">Gönderme tarafında, kanal yığını geçerli bir <xref:System.ServiceModel.Channels.Message> örnek alır ve bazı işlemler yapıldıktan sonra, iletiyi göndermek için mantıksal olarak karşılık gelen bazı işlemleri gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="60a12-115">On the sending side, the channel stack takes a valid <xref:System.ServiceModel.Channels.Message> instance and, after some processing, performs some action that logically corresponds to sending the message.</span></span> <span data-ttu-id="60a12-116">Bu eylem TCP veya HTTP paketleri gönderiyor, Message Queuing ileti sıraya alıyor, bir veritabanına ileti yazıyor, dosyayı bir dosya paylaşımında ya da uygulamaya bağlı olarak başka bir eylem olarak kaydediyor olabilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-116">The action may be sending TCP or HTTP packets, queuing the message in Message Queuing, writing the message to a database, saving it to a file share, or any other action, depending on the implementation.</span></span> <span data-ttu-id="60a12-117">En yaygın eylem, iletiyi bir ağ protokolü üzerinden gönderiyor.</span><span class="sxs-lookup"><span data-stu-id="60a12-117">The most common action is sending the message over a network protocol.</span></span> <span data-ttu-id="60a12-118">Alma tarafında, tersi durum — bir işlem algılanır (TCP veya HTTP paketleri ya da başka bir eylem olabilir) ve işlemeden sonra kanal yığını bu eylemi geçerli bir <xref:System.ServiceModel.Channels.Message> örneğe dönüştürür.</span><span class="sxs-lookup"><span data-stu-id="60a12-118">On the receive side, the opposite happens—an action is detected (which may be TCP or HTTP packets arriving or any other action), and, after processing, the channel stack converts this action into a valid <xref:System.ServiceModel.Channels.Message> instance.</span></span>  
  
 <span data-ttu-id="60a12-119">WCF <xref:System.ServiceModel.Channels.Message> 'yi, sınıfını ve kanal yığınını doğrudan kullanarak kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="60a12-119">You can use WCF by using the <xref:System.ServiceModel.Channels.Message> class and the channel stack directly.</span></span> <span data-ttu-id="60a12-120">Ancak bunu yapmak zor ve zaman alır.</span><span class="sxs-lookup"><span data-stu-id="60a12-120">However, doing so is difficult and time-consuming.</span></span> <span data-ttu-id="60a12-121">Ayrıca, <xref:System.ServiceModel.Channels.Message> nesne meta veri desteği sağlamaz, bu nedenle WCF 'yi bu şekilde kullanıyorsanız, türü kesin BELIRLENMIŞ WCF istemcileri oluşturamazsınız.</span><span class="sxs-lookup"><span data-stu-id="60a12-121">Additionally, the <xref:System.ServiceModel.Channels.Message> object provides no metadata support, so you cannot generate strongly typed WCF clients if you use WCF in this manner.</span></span>  
  
 <span data-ttu-id="60a12-122">Bu nedenle WCF, nesneleri oluşturmak ve almak için kullanabileceğiniz, kullanımı kolay bir programlama modeli sağlayan bir hizmet çerçevesi içerir `Message` .</span><span class="sxs-lookup"><span data-stu-id="60a12-122">Therefore, WCF includes a service framework that provides an easy-to-use programming model that you can use to construct and receive `Message` objects.</span></span> <span data-ttu-id="60a12-123">Service Framework, Hizmetleri hizmet sözleşmeleri kavramı aracılığıyla .NET Framework türlerine eşler ve yalnızca özniteliğiyle işaretlenmiş .NET Framework Yöntemler olan Kullanıcı işlemlerine ileti gönderir <xref:System.ServiceModel.OperationContractAttribute> (daha fazla bilgi için bkz. [hizmet sözleşmelerini tasarlama](../designing-service-contracts.md)).</span><span class="sxs-lookup"><span data-stu-id="60a12-123">The service framework maps services to .NET Framework types through the notion of service contracts, and dispatches messages to user operations that are simply .NET Framework methods marked with the <xref:System.ServiceModel.OperationContractAttribute> attribute (for more details, see [Designing Service Contracts](../designing-service-contracts.md)).</span></span> <span data-ttu-id="60a12-124">Bu yöntemlerin parametreleri ve dönüş değerleri olabilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-124">These methods may have parameters and return values.</span></span> <span data-ttu-id="60a12-125">Hizmet tarafında, hizmet çerçevesi gelen <xref:System.ServiceModel.Channels.Message> örnekleri parametrelere dönüştürür ve dönüş değerlerini giden <xref:System.ServiceModel.Channels.Message> örneklere dönüştürür.</span><span class="sxs-lookup"><span data-stu-id="60a12-125">On the service side, the service framework converts incoming <xref:System.ServiceModel.Channels.Message> instances into parameters and converts return values into outgoing <xref:System.ServiceModel.Channels.Message> instances.</span></span> <span data-ttu-id="60a12-126">İstemci tarafında, tersi olur.</span><span class="sxs-lookup"><span data-stu-id="60a12-126">On the client side, it does the opposite.</span></span> <span data-ttu-id="60a12-127">Örneğin, aşağıdaki işlemi göz önünde bulundurun `FindAirfare` .</span><span class="sxs-lookup"><span data-stu-id="60a12-127">For example, consider the `FindAirfare` operation below.</span></span>  
  
 [!code-csharp[c_DataArchitecture#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#1)]
 [!code-vb[c_DataArchitecture#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#1)]  
  
 <span data-ttu-id="60a12-128">`FindAirfare`İstemci üzerinde bir değer çağırılır.</span><span class="sxs-lookup"><span data-stu-id="60a12-128">Suppose `FindAirfare` is called on the client.</span></span> <span data-ttu-id="60a12-129">İstemci üzerindeki hizmet çerçevesi, `FromCity` ve `ToCity` parametrelerini giden <xref:System.ServiceModel.Channels.Message> örneğe dönüştürür ve gönderilecek kanal yığınına geçirir.</span><span class="sxs-lookup"><span data-stu-id="60a12-129">The service framework on the client converts the `FromCity` and `ToCity` parameters into an outgoing <xref:System.ServiceModel.Channels.Message> instance and passes it to the channel stack to be sent.</span></span>  
  
 <span data-ttu-id="60a12-130">Hizmet tarafında, bir <xref:System.ServiceModel.Channels.Message> örnek kanal yığınından ulaştığında, hizmet çerçevesi, ve parametrelerini doldurmak için iletiden ilgili verileri ayıklar `FromCity` `ToCity` ve ardından hizmet tarafı `FindAirfare` yöntemini çağırır.</span><span class="sxs-lookup"><span data-stu-id="60a12-130">On the service side, when a <xref:System.ServiceModel.Channels.Message> instance arrives from the channel stack, the service framework extracts the relevant data from the message to populate the `FromCity` and `ToCity` parameters and then calls the service-side `FindAirfare` method.</span></span> <span data-ttu-id="60a12-131">Yöntem döndüğünde, Service Framework döndürülen tamsayı değerini ve `IsDirectFlight` Çıkış parametresini alır ve <xref:System.ServiceModel.Channels.Message> Bu bilgileri içeren bir nesne örneği oluşturur.</span><span class="sxs-lookup"><span data-stu-id="60a12-131">When the method returns, the service framework takes the returned integer value and the `IsDirectFlight` output parameter and creates a <xref:System.ServiceModel.Channels.Message> object instance that contains this information.</span></span> <span data-ttu-id="60a12-132">Daha sonra `Message` örneği istemciye geri gönderilmek üzere kanal yığınına geçirir.</span><span class="sxs-lookup"><span data-stu-id="60a12-132">It then passes the `Message` instance to the channel stack to be sent back to the client.</span></span>  
  
 <span data-ttu-id="60a12-133">İstemci tarafında, <xref:System.ServiceModel.Channels.Message> yanıt iletisini içeren bir örnek kanal yığınından ortaya çıktı.</span><span class="sxs-lookup"><span data-stu-id="60a12-133">On the client side, a <xref:System.ServiceModel.Channels.Message> instance that contains the response message emerges from the channel stack.</span></span> <span data-ttu-id="60a12-134">Service Framework, dönüş değerini ve `IsDirectFlight` değerini ayıklar ve bunları istemci çağıranına döndürür.</span><span class="sxs-lookup"><span data-stu-id="60a12-134">The service framework extracts the return value and the `IsDirectFlight` value and returns these to the caller of the client.</span></span>  
  
## <a name="message-class"></a><span data-ttu-id="60a12-135">Message Sınıfı</span><span class="sxs-lookup"><span data-stu-id="60a12-135">Message Class</span></span>  
 <span data-ttu-id="60a12-136"><xref:System.ServiceModel.Channels.Message>Sınıfın bir iletinin soyut temsili olması amaçlanmıştır, ancak TASARıMı SOAP iletisine kesin bir şekilde bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="60a12-136">The <xref:System.ServiceModel.Channels.Message> class is intended to be an abstract representation of a message, but its design is strongly tied to the SOAP message.</span></span> <span data-ttu-id="60a12-137"><xref:System.ServiceModel.Channels.Message>, Üç ana bilgi parçasını içerir: ileti gövdesi, ileti üstbilgileri ve ileti özellikleri.</span><span class="sxs-lookup"><span data-stu-id="60a12-137">A <xref:System.ServiceModel.Channels.Message> contains three major pieces of information: a message body, message headers, and message properties.</span></span>  
  
## <a name="message-body"></a><span data-ttu-id="60a12-138">İleti gövdesi</span><span class="sxs-lookup"><span data-stu-id="60a12-138">Message Body</span></span>  
 <span data-ttu-id="60a12-139">İleti gövdesi iletinin gerçek veri yükünü temsil etmek üzere tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="60a12-139">The message body is intended to represent the actual data payload of the message.</span></span> <span data-ttu-id="60a12-140">İleti gövdesi her zaman bir XML bilgi kümesi olarak temsil edilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-140">The message body is always represented as an XML Infoset.</span></span> <span data-ttu-id="60a12-141">Bu, WCF 'de oluşturulan veya alınan tüm iletilerin XML biçiminde olması anlamına gelmez.</span><span class="sxs-lookup"><span data-stu-id="60a12-141">This does not mean that all messages created or received in WCF must be in XML format.</span></span> <span data-ttu-id="60a12-142">İleti gövdesinin nasıl yorumlanacağına karar vermek için kanal yığınına kadar olur.</span><span class="sxs-lookup"><span data-stu-id="60a12-142">It is up to the channel stack to decide how to interpret the message body.</span></span> <span data-ttu-id="60a12-143">Bu, XML olarak yayabilir, başka bir biçime dönüştürebilir, hatta tamamen atlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="60a12-143">It may emit it as XML, convert it to some other format, or even omit it entirely.</span></span> <span data-ttu-id="60a12-144">Kuşkusuz, her bağlamanın WCF sağladığı ileti gövdesi, bir SOAP zarfının gövde bölümünde XML içeriği olarak temsil edilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-144">Of course, with most of the bindings WCF supplies, the message body is represented as XML content in the body section of a SOAP envelope.</span></span>  
  
 <span data-ttu-id="60a12-145">`Message`Sınıfın, gövdesi temsil eden XML verileri içeren bir arabellek içermesi gerekmediğini fark etmek önemlidir.</span><span class="sxs-lookup"><span data-stu-id="60a12-145">It is important to realize that the `Message` class does not necessarily contain a buffer with XML data representing the body.</span></span> <span data-ttu-id="60a12-146">Mantıksal olarak, `Message` BIR XML bilgi kümesi içerir, ancak bu bilgi kümesi dinamik olarak oluşturulabilir ve bellekte hiç fiziksel olarak bulunmayabilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-146">Logically, `Message` contains an XML Infoset, but this Infoset may be dynamically constructed and may never physically exist in memory.</span></span>  
  
### <a name="putting-data-into-the-message-body"></a><span data-ttu-id="60a12-147">Verilerin Ileti gövdesine yerleştirilmesi</span><span class="sxs-lookup"><span data-stu-id="60a12-147">Putting Data into the Message Body</span></span>  
 <span data-ttu-id="60a12-148">Bir ileti gövdesine veri yerleştirmek için Tekdüzen mekanizması yoktur.</span><span class="sxs-lookup"><span data-stu-id="60a12-148">There is no uniform mechanism to put data into a message body.</span></span> <span data-ttu-id="60a12-149"><xref:System.ServiceModel.Channels.Message>Sınıfının bir soyut yöntemi vardır, <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> Bu bir <xref:System.Xml.XmlDictionaryWriter> .</span><span class="sxs-lookup"><span data-stu-id="60a12-149">The <xref:System.ServiceModel.Channels.Message> class has an abstract method, <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, which takes an <xref:System.Xml.XmlDictionaryWriter>.</span></span> <span data-ttu-id="60a12-150">Sınıfın her alt sınıfı <xref:System.ServiceModel.Channels.Message> , bu yöntemi geçersiz kılmaktan ve kendi içeriğini yazmadan sorumludur.</span><span class="sxs-lookup"><span data-stu-id="60a12-150">Each subclass of the <xref:System.ServiceModel.Channels.Message> class is responsible for overriding this method and writing out its own contents.</span></span> <span data-ttu-id="60a12-151">İleti gövdesi mantıksal olarak, üreten XML bilgi kümesini içerir `OnWriteBodyContent` .</span><span class="sxs-lookup"><span data-stu-id="60a12-151">The message body logically contains the XML Infoset that `OnWriteBodyContent` produces.</span></span> <span data-ttu-id="60a12-152">Örneğin, aşağıdaki alt sınıfı göz önünde bulundurun `Message` .</span><span class="sxs-lookup"><span data-stu-id="60a12-152">For example, consider the following `Message` subclass.</span></span>  
  
 [!code-csharp[c_DataArchitecture#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#2)]
 [!code-vb[c_DataArchitecture#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#2)]  
  
 <span data-ttu-id="60a12-153">Fiziksel olarak, bir `AirfareRequestMessage` örnek yalnızca iki dize ("fromCity" ve "toCity") içerir.</span><span class="sxs-lookup"><span data-stu-id="60a12-153">Physically, an `AirfareRequestMessage` instance contains only two strings ("fromCity" and "toCity").</span></span> <span data-ttu-id="60a12-154">Ancak, mantıksal olarak ileti aşağıdaki XML bilgi kümesini içerir:</span><span class="sxs-lookup"><span data-stu-id="60a12-154">However, logically the message contains the following XML infoset:</span></span>  
  
```xml  
<airfareRequest>  
    <from>Tokyo</from>  
    <to>London</to>  
</airfareRequest>  
```  
  
 <span data-ttu-id="60a12-155">Kuşkusuz, işlem sözleşmesi parametrelerinden önceki bir ileti oluşturmak üzere Service Framework 'ü kullanabilmeniz için normalde bu şekilde ileti oluşturmayız.</span><span class="sxs-lookup"><span data-stu-id="60a12-155">Of course, you would normally not create messages in this manner, because you can use the service framework to create a message like the preceding one from operation contract parameters.</span></span> <span data-ttu-id="60a12-156">Ayrıca, <xref:System.ServiceModel.Channels.Message> sınıfının `CreateMessage` ortak içerik türleri ile ileti oluşturmak için kullanabileceğiniz statik yöntemleri vardır: boş bir ileti, ile XML 'e serileştirilmiş bir nesne içeren bir ILETI, soap hatası içeren bir ileti, <xref:System.Runtime.Serialization.DataContractSerializer> bir Ile temsil edilen XML içeren bir ileti <xref:System.Xml.XmlReader> ve bu şekilde devam eder.</span><span class="sxs-lookup"><span data-stu-id="60a12-156">Additionally, the <xref:System.ServiceModel.Channels.Message> class has static `CreateMessage` methods that you can use to create messages with common types of content: an empty message, a message that contains an object serialized to XML with the <xref:System.Runtime.Serialization.DataContractSerializer>, a message that contains a SOAP fault, a message that contains XML represented by an <xref:System.Xml.XmlReader>, and so on.</span></span>  
  
### <a name="getting-data-from-a-message-body"></a><span data-ttu-id="60a12-157">Ileti gövdesinden veri alma</span><span class="sxs-lookup"><span data-stu-id="60a12-157">Getting Data from a Message Body</span></span>  
 <span data-ttu-id="60a12-158">İleti gövdesinde depolanan verileri iki ana şekilde ayıklayabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="60a12-158">You can extract the data stored in a message body in two main ways:</span></span>  
  
- <span data-ttu-id="60a12-159"><xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29>Yöntemini çağırarak ve BIR XML yazıcısına geçirerek, tüm ileti gövdesini tek seferde alabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="60a12-159">You can get the entire message body at one time by calling the <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> method and passing in an XML writer.</span></span> <span data-ttu-id="60a12-160">Tüm ileti gövdesi bu yazıcıya yazılır.</span><span class="sxs-lookup"><span data-stu-id="60a12-160">The complete message body is written out to this writer.</span></span> <span data-ttu-id="60a12-161">Tüm ileti gövdesinin tek seferde alınması de *ileti yazma*olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="60a12-161">Getting the entire message body at one time is also called *writing a message*.</span></span> <span data-ttu-id="60a12-162">Yazma işlemi öncelikli olarak ileti gönderilirken kanal yığını tarafından yapılır — kanal yığınının bir bölümü genellikle tüm ileti gövdesine erişebilir, kodlanacak ve gönderilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-162">Writing is done primarily by the channel stack when sending messages—some part of the channel stack will usually get access to the entire message body, encode it, and send it.</span></span>  
  
- <span data-ttu-id="60a12-163">İleti gövdesinden bilgi almanın bir başka yolu da <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> BIR XML okuyucusu çağırmak ve almak.</span><span class="sxs-lookup"><span data-stu-id="60a12-163">Another way to get information out of the message body is to call <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> and get an XML reader.</span></span> <span data-ttu-id="60a12-164">İleti gövdesine, okuyucudaki Yöntemler çağrılırken gerektiği şekilde sırayla erişilebilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-164">The message body can then be accessed sequentially as needed by calling methods on the reader.</span></span> <span data-ttu-id="60a12-165">İleti gövdesinin *bir ileti okuma*da denir.</span><span class="sxs-lookup"><span data-stu-id="60a12-165">Getting the message body piece-by-piece is also called *reading a message*.</span></span> <span data-ttu-id="60a12-166">İletiyi okumak, öncelikle ileti alırken Service Framework tarafından kullanılır.</span><span class="sxs-lookup"><span data-stu-id="60a12-166">Reading the message is primarily used by the service framework when receiving messages.</span></span> <span data-ttu-id="60a12-167">Örneğin,, kullanılırken, <xref:System.Runtime.Serialization.DataContractSerializer> hizmet çerçevesi gövde üzerinde BIR XML okuyucusu alır ve bunu seri kaldırma altyapısına iletir. böylece, öğe tarafından ileti öğesini okumaya başlar ve ilgili nesne grafiğini oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="60a12-167">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> is in use, the service framework will get an XML reader over the body and pass it to the deserialization engine, which will then start reading the message element-by-element and constructing the corresponding object graph.</span></span>  
  
 <span data-ttu-id="60a12-168">İleti gövdesi yalnızca bir kez alınabilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-168">A message body can be retrieved only once.</span></span> <span data-ttu-id="60a12-169">Bu, yalnızca ileri akışlarla çalışmayı mümkün kılar.</span><span class="sxs-lookup"><span data-stu-id="60a12-169">This makes it possible to work with forward-only streams.</span></span> <span data-ttu-id="60a12-170">Örneğin, <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> öğesinden okuyan <xref:System.IO.FileStream> ve sonuçları bir xml bilgi kümesi olarak döndüren bir geçersiz kılma yazabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="60a12-170">For example, you can write an <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> override that reads from a <xref:System.IO.FileStream> and returns the results as an XML Infoset.</span></span> <span data-ttu-id="60a12-171">Dosyanın başlangıcına "geri sarma" gerek kalmaz.</span><span class="sxs-lookup"><span data-stu-id="60a12-171">You will never need to "rewind" to the beginning of the file.</span></span>  
  
 <span data-ttu-id="60a12-172">`WriteBodyContents`Ve `GetReaderAtBodyContents` yöntemleri, ileti gövdesinin daha önce hiç alınamamıştır ve sonra `OnWriteBodyContents` sırasıyla veya olarak çağrı yapılır `OnGetReaderAtBodyContents` .</span><span class="sxs-lookup"><span data-stu-id="60a12-172">The `WriteBodyContents` and `GetReaderAtBodyContents` methods simply check that the message body has never been retrieved before, and then call `OnWriteBodyContents` or `OnGetReaderAtBodyContents`, respectively.</span></span>  
  
## <a name="message-usage-in-wcf"></a><span data-ttu-id="60a12-173">WCF 'de ileti kullanımı</span><span class="sxs-lookup"><span data-stu-id="60a12-173">Message Usage in WCF</span></span>  
 <span data-ttu-id="60a12-174">Çoğu ileti, *giden* (kanal yığını tarafından gönderilmek üzere Service Framework tarafından oluşturulan) veya *gelen* (kanal yığınından gelen ve hizmet çerçevesi tarafından yorumlanan) olarak sınıflandırılabilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-174">Most messages can be classified as either *outgoing* (those that are created by the service framework to be sent by the channel stack) or *incoming* (those that arrive from the channel stack and are interpreted by the service framework).</span></span> <span data-ttu-id="60a12-175">Ayrıca, kanal yığını, ara belleğe alınmış ya da akış modunda çalışabilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-175">Furthermore, the channel stack can operate in either buffered or streaming mode.</span></span> <span data-ttu-id="60a12-176">Hizmet çerçevesi Ayrıca akışlı veya akış olmayan bir programlama modeli sunabilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-176">The service framework may also expose a streamed or nonstreamed programming model.</span></span> <span data-ttu-id="60a12-177">Bu, uygulamanın Basitleştirilmiş ayrıntılarıyla birlikte aşağıdaki tabloda listelenen servis taleplerine yol açar.</span><span class="sxs-lookup"><span data-stu-id="60a12-177">This leads to the cases listed in the following table, along with simplified details of their implementation.</span></span>  
  
|<span data-ttu-id="60a12-178">Mesaj türü</span><span class="sxs-lookup"><span data-stu-id="60a12-178">Message type</span></span>|<span data-ttu-id="60a12-179">İletideki gövde verileri</span><span class="sxs-lookup"><span data-stu-id="60a12-179">Body data in message</span></span>|<span data-ttu-id="60a12-180">Yazma (OnWriteBodyContents) uygulama</span><span class="sxs-lookup"><span data-stu-id="60a12-180">Write (OnWriteBodyContents) implementation</span></span>|<span data-ttu-id="60a12-181">Okuma (OnGetReaderAtBodyContents) uygulama</span><span class="sxs-lookup"><span data-stu-id="60a12-181">Read (OnGetReaderAtBodyContents) Implementation</span></span>|  
|------------------|--------------------------|--------------------------------------------------|-------------------------------------------------------|  
|<span data-ttu-id="60a12-182">Giden, akış olmayan programlama modelinden oluşturulan</span><span class="sxs-lookup"><span data-stu-id="60a12-182">Outgoing, created from nonstreamed programming model</span></span>|<span data-ttu-id="60a12-183">İletiyi yazmak için gereken veriler (örneğin, bir nesne ve <xref:System.Runtime.Serialization.DataContractSerializer> seri hale getirmek için gereken örnek) \*</span><span class="sxs-lookup"><span data-stu-id="60a12-183">The data needed to write the message (for example, an object and the <xref:System.Runtime.Serialization.DataContractSerializer> instance needed to serialize it)\*</span></span>|<span data-ttu-id="60a12-184">Depolanan verileri temel alarak iletiyi yazmak için özel mantık (örneğin, `WriteObject` `DataContractSerializer` kullanılmakta olan seri hale getirici ise üzerinde çağırın) \*</span><span class="sxs-lookup"><span data-stu-id="60a12-184">Custom logic to write out the message based on the stored data (for example, call `WriteObject` on the `DataContractSerializer` if that is the serializer in use)\*</span></span>|<span data-ttu-id="60a12-185">Arama `OnWriteBodyContents` yapın, sonuçları arabelleğe alarak arabellek üzerinde BIR XML okuyucusu döndürün</span><span class="sxs-lookup"><span data-stu-id="60a12-185">Call `OnWriteBodyContents`, buffer the results, return an XML reader over the buffer</span></span>|  
|<span data-ttu-id="60a12-186">Giden, akışlı programlama modelinden oluşturulan</span><span class="sxs-lookup"><span data-stu-id="60a12-186">Outgoing, created from streamed programming model</span></span>|<span data-ttu-id="60a12-187">`Stream`Yazılacak verilerle birlikte \*</span><span class="sxs-lookup"><span data-stu-id="60a12-187">The `Stream` with the data to be written\*</span></span>|<span data-ttu-id="60a12-188">Yöntemi kullanarak depolanan akıştan veri yazma <xref:System.Xml.IStreamProvider> \*</span><span class="sxs-lookup"><span data-stu-id="60a12-188">Write out data from the stored stream using the <xref:System.Xml.IStreamProvider> mechanism\*</span></span>|<span data-ttu-id="60a12-189">Arama `OnWriteBodyContents` yapın, sonuçları arabelleğe alarak arabellek üzerinde BIR XML okuyucusu döndürün</span><span class="sxs-lookup"><span data-stu-id="60a12-189">Call `OnWriteBodyContents`, buffer the results, return an XML reader over the buffer</span></span>|  
|<span data-ttu-id="60a12-190">Akış kanalı yığınından gelen</span><span class="sxs-lookup"><span data-stu-id="60a12-190">Incoming from streaming channel stack</span></span>|<span data-ttu-id="60a12-191">`Stream`Üzerinde bir ağ üzerinden gelen verileri temsil eden bir nesne <xref:System.Xml.XmlReader></span><span class="sxs-lookup"><span data-stu-id="60a12-191">A `Stream` object that represents the data coming in over the network with an <xref:System.Xml.XmlReader> over it</span></span>|<span data-ttu-id="60a12-192">İçeriği `XmlReader` depolanan bilgisayardan yaz`WriteNode`</span><span class="sxs-lookup"><span data-stu-id="60a12-192">Write out the contents from the stored `XmlReader` using `WriteNode`</span></span>|<span data-ttu-id="60a12-193">Depolanan`XmlReader`</span><span class="sxs-lookup"><span data-stu-id="60a12-193">Returns the stored `XmlReader`</span></span>|  
|<span data-ttu-id="60a12-194">Akış olmayan kanal yığınından gelen</span><span class="sxs-lookup"><span data-stu-id="60a12-194">Incoming from nonstreaming channel stack</span></span>|<span data-ttu-id="60a12-195">Üzerine gelen gövde verilerini içeren bir arabellek `XmlReader`</span><span class="sxs-lookup"><span data-stu-id="60a12-195">A buffer that contains body data with an `XmlReader` over it</span></span>|<span data-ttu-id="60a12-196">İçeriği `XmlReader` depolanan bilgisayardan yazar`WriteNode`</span><span class="sxs-lookup"><span data-stu-id="60a12-196">Writes out the contents from the stored `XmlReader` using `WriteNode`</span></span>|<span data-ttu-id="60a12-197">Depolanan dili döndürür</span><span class="sxs-lookup"><span data-stu-id="60a12-197">Returns the stored lang</span></span>|  
  
 <span data-ttu-id="60a12-198">\*Bu öğeler doğrudan alt `Message` sınıflarda, ancak sınıfının alt sınıflarında uygulanmaz <xref:System.ServiceModel.Channels.BodyWriter> .</span><span class="sxs-lookup"><span data-stu-id="60a12-198">\* These items are not implemented directly in `Message` subclasses, but in subclasses of the <xref:System.ServiceModel.Channels.BodyWriter> class.</span></span> <span data-ttu-id="60a12-199">Hakkında daha fazla bilgi için <xref:System.ServiceModel.Channels.BodyWriter> bkz. [Ileti sınıfını kullanma](using-the-message-class.md).</span><span class="sxs-lookup"><span data-stu-id="60a12-199">For more information about the <xref:System.ServiceModel.Channels.BodyWriter>, see [Using the Message Class](using-the-message-class.md).</span></span>  
  
## <a name="message-headers"></a><span data-ttu-id="60a12-200">İleti üstbilgileri</span><span class="sxs-lookup"><span data-stu-id="60a12-200">Message Headers</span></span>  
 <span data-ttu-id="60a12-201">İleti, üst bilgiler içerebilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-201">A message may contain headers.</span></span> <span data-ttu-id="60a12-202">Üst bilgi, bir ad, ad alanı ve diğer diğer özelliklerle ilişkili bir XML bilgi kümesinden mantıksal olarak oluşur.</span><span class="sxs-lookup"><span data-stu-id="60a12-202">A header logically consists of an XML Infoset that is associated with a name, a namespace, and a few other properties.</span></span> <span data-ttu-id="60a12-203">İleti üst bilgilerine `Headers` üzerindeki özelliği kullanılarak erişilir <xref:System.ServiceModel.Channels.Message> .</span><span class="sxs-lookup"><span data-stu-id="60a12-203">Message headers are accessed using the `Headers` property on <xref:System.ServiceModel.Channels.Message>.</span></span> <span data-ttu-id="60a12-204">Her üst bilgi bir sınıf tarafından temsil edilir <xref:System.ServiceModel.Channels.MessageHeader> .</span><span class="sxs-lookup"><span data-stu-id="60a12-204">Each header is represented by a <xref:System.ServiceModel.Channels.MessageHeader> class.</span></span> <span data-ttu-id="60a12-205">Normalde, SOAP iletileriyle çalışmak üzere yapılandırılmış bir kanal yığını kullanılırken, ileti üst bilgileri SOAP ileti üst bilgilerine eşlenir.</span><span class="sxs-lookup"><span data-stu-id="60a12-205">Normally, message headers are mapped to SOAP message headers when using a channel stack configured to work with SOAP messages.</span></span>  
  
 <span data-ttu-id="60a12-206">Bilgileri bir ileti başlığına koymak ve bundan bilgi ayıklamak ileti gövdesini kullanmaya benzer.</span><span class="sxs-lookup"><span data-stu-id="60a12-206">Putting information into a message header and extracting information from it is similar to using the message body.</span></span> <span data-ttu-id="60a12-207">Akış desteklenmediğinden işlem biraz basitleştirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="60a12-207">The process is somewhat simplified because streaming is not supported.</span></span> <span data-ttu-id="60a12-208">Aynı üstbilginin içeriğine birden çok kez erişmek mümkündür ve üstbilgilere rastgele sırayla erişilebilir ve üst bilgilerin her zaman arabelleğe alınbilmesini sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="60a12-208">It is possible to access the contents of the same header more than once, and headers can be accessed in arbitrary order, forcing headers to always be buffered.</span></span> <span data-ttu-id="60a12-209">Bir üst bilgi üzerinde bir XML okuyucusu almak için kullanılabilen genel amaçlı bir mekanizma yoktur, ancak bu `MessageHeader` tür bir özelliği olan okunabilir bir üst bilgiyi temsil eden WCF 'nin dahili bir alt sınıfı vardır.</span><span class="sxs-lookup"><span data-stu-id="60a12-209">There is no general-purpose mechanism available to get an XML reader over a header, but there is a `MessageHeader` subclass internal to WCF that represents a readable header with such a capability.</span></span> <span data-ttu-id="60a12-210">Bu tür, `MessageHeader` özel uygulama üstbilgileri ile bir ileti geldiğinde kanal yığını tarafından oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="60a12-210">This type of `MessageHeader` is created by the channel stack when a message with custom application headers comes in.</span></span> <span data-ttu-id="60a12-211">Bu, hizmet çerçevesinin <xref:System.Runtime.Serialization.DataContractSerializer> Bu üst bilgileri yorumlamak için gibi bir seri kaldırma altyapısı kullanmasına olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="60a12-211">This enables the service framework to use a deserialization engine, such as the <xref:System.Runtime.Serialization.DataContractSerializer>, to interpret these headers.</span></span>  
  
 <span data-ttu-id="60a12-212">Daha fazla bilgi için bkz. [Ileti sınıfını kullanma](using-the-message-class.md).</span><span class="sxs-lookup"><span data-stu-id="60a12-212">For more information, see [Using the Message Class](using-the-message-class.md).</span></span>  
  
## <a name="message-properties"></a><span data-ttu-id="60a12-213">İleti özellikleri</span><span class="sxs-lookup"><span data-stu-id="60a12-213">Message Properties</span></span>  
 <span data-ttu-id="60a12-214">Bir ileti, özellikler içerebilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-214">A message may contain properties.</span></span> <span data-ttu-id="60a12-215">Bir *özellik* , bir dize adıyla ilişkili .NET Framework nesnedir.</span><span class="sxs-lookup"><span data-stu-id="60a12-215">A *property* is any .NET Framework object that is associated with a string name.</span></span> <span data-ttu-id="60a12-216">Özellikleri üzerinde özelliği aracılığıyla erişilir `Properties` `Message` .</span><span class="sxs-lookup"><span data-stu-id="60a12-216">Properties are accessed through the `Properties` property on `Message`.</span></span>  
  
 <span data-ttu-id="60a12-217">İleti gövdesinin ve ileti başlıklarından farklı olarak (sırasıyla SOAP gövdesine ve SOAP üst bilgilerine eşlenir), ileti özellikleri normalde iletilerle birlikte gönderilmez veya alınmaz.</span><span class="sxs-lookup"><span data-stu-id="60a12-217">Unlike the message body and message headers (which normally map to the SOAP body and SOAP headers, respectively), message properties are normally not sent or received along with the messages.</span></span> <span data-ttu-id="60a12-218">İleti özellikleri, birincil olarak kanal yığınındaki çeşitli kanallar arasında ve kanal yığını ile hizmet modeli arasında ileti hakkında verileri geçirmek için bir iletişim mekanizması olarak mevcuttur.</span><span class="sxs-lookup"><span data-stu-id="60a12-218">Message properties exist primarily as a communication mechanism to pass data about the message between the various channels in the channel stack, and between the channel stack and the service model.</span></span>  
  
 <span data-ttu-id="60a12-219">Örneğin, WCF 'nin bir parçası olarak dahil edilen HTTP taşıma kanalı, istemcilere yanıt gönderdiğinde "404 (bulunamadı)" ve "500 (Iç sunucu hatası)" gibi çeşitli HTTP durum kodları üretebilme yeteneğine sahiptir.</span><span class="sxs-lookup"><span data-stu-id="60a12-219">For example, the HTTP transport channel included as part of WCF is capable of producing various HTTP status codes, such as "404 (Not Found)" and "500 (Internal Server Error)," when it sends replies to clients.</span></span> <span data-ttu-id="60a12-220">Bir yanıt iletisi göndermeden önce, `Properties` öğesinin `Message` ' de türünde bir nesne Içeren "HttpResponse" adlı bir özellik içerip içermediğini kontrol eder <xref:System.ServiceModel.Channels.HttpResponseMessageProperty> .</span><span class="sxs-lookup"><span data-stu-id="60a12-220">Before sending a reply message, it checks to see whether the `Properties` of the `Message` contain a property called "httpResponse" that contains an object of type <xref:System.ServiceModel.Channels.HttpResponseMessageProperty>.</span></span> <span data-ttu-id="60a12-221">Böyle bir özellik bulunursa, <xref:System.ServiceModel.Channels.HttpResponseMessageProperty.StatusCode%2A> özelliğine bakar ve bu durum kodunu kullanacaktır.</span><span class="sxs-lookup"><span data-stu-id="60a12-221">If such a property is found, it will look at the <xref:System.ServiceModel.Channels.HttpResponseMessageProperty.StatusCode%2A> property and use that status code.</span></span> <span data-ttu-id="60a12-222">Bulunmazsa, varsayılan "200 (Tamam)" kodu kullanılır.</span><span class="sxs-lookup"><span data-stu-id="60a12-222">If it is not found, the default "200 (OK)" code is used.</span></span>  
  
 <span data-ttu-id="60a12-223">Daha fazla bilgi için bkz. [Ileti sınıfını kullanma](using-the-message-class.md).</span><span class="sxs-lookup"><span data-stu-id="60a12-223">For more information, see [Using the Message Class](using-the-message-class.md).</span></span>  
  
### <a name="the-message-as-a-whole"></a><span data-ttu-id="60a12-224">Ileti bir bütün olarak</span><span class="sxs-lookup"><span data-stu-id="60a12-224">The Message as a Whole</span></span>  
 <span data-ttu-id="60a12-225">Şimdiye kadar, iletinin çeşitli bölümlerine yalıtımıyla erişim için yöntemler açıklanmıştır.</span><span class="sxs-lookup"><span data-stu-id="60a12-225">So far, we have discussed methods for accessing the various parts of the message in isolation.</span></span> <span data-ttu-id="60a12-226">Ancak, <xref:System.ServiceModel.Channels.Message> sınıfı tüm iletiyle birlikte çalışmak için yöntemler de sağlar.</span><span class="sxs-lookup"><span data-stu-id="60a12-226">However, the <xref:System.ServiceModel.Channels.Message> class also provides methods to work with the entire message as a whole.</span></span> <span data-ttu-id="60a12-227">Örneğin, `WriteMessage` yöntemi tüm iletiyi BIR XML yazıcısına yazar.</span><span class="sxs-lookup"><span data-stu-id="60a12-227">For example, the `WriteMessage` method writes out the entire message to an XML writer.</span></span>  
  
 <span data-ttu-id="60a12-228">Bunun mümkün olması için, tüm `Message` örnek ve BIR XML bilgi kümesi arasında bir eşlemenin tanımlanması gerekir.</span><span class="sxs-lookup"><span data-stu-id="60a12-228">For this to be possible, a mapping must be defined between the entire `Message` instance and an XML Infoset.</span></span> <span data-ttu-id="60a12-229">Böyle bir eşleme, aslında vardır: WCF bu eşlemeyi tanımlamak için SOAP standardını kullanır.</span><span class="sxs-lookup"><span data-stu-id="60a12-229">Such a mapping, in fact, exists: WCF uses the SOAP standard to define this mapping.</span></span> <span data-ttu-id="60a12-230">Bir `Message` Örnek BIR XML bilgi kümesi olarak yazıldığında, sonuçta elde edilen bilgi kümesi iletiyi içeren geçerli BIR SOAP Envelope.</span><span class="sxs-lookup"><span data-stu-id="60a12-230">When a `Message` instance is written out as an XML Infoset, the resulting Infoset is the valid SOAP envelope that contains the message.</span></span> <span data-ttu-id="60a12-231">Bu nedenle, `WriteMessage` normalde aşağıdaki adımları gerçekleştirir:</span><span class="sxs-lookup"><span data-stu-id="60a12-231">Thus, `WriteMessage` would normally perform the following steps:</span></span>  
  
1. <span data-ttu-id="60a12-232">SOAP Envelope öğesi açma etiketi yazın.</span><span class="sxs-lookup"><span data-stu-id="60a12-232">Write the SOAP envelope element opening tag.</span></span>  
  
2. <span data-ttu-id="60a12-233">SOAP üst bilgisi öğesi açma etiketi yazın, tüm üst bilgileri yazın ve üst bilgi öğesini kapatın.</span><span class="sxs-lookup"><span data-stu-id="60a12-233">Write the SOAP header element opening tag, write out all of the headers, and close the header element.</span></span>  
  
3. <span data-ttu-id="60a12-234">SOAP body öğesi açılış etiketini yazın.</span><span class="sxs-lookup"><span data-stu-id="60a12-234">Write the SOAP body element opening tag.</span></span>  
  
4. <span data-ttu-id="60a12-235">`WriteBodyContents`Gövdeyi yazmak için çağrı veya eşdeğer bir yöntem.</span><span class="sxs-lookup"><span data-stu-id="60a12-235">Call `WriteBodyContents` or an equivalent method to write out the body.</span></span>  
  
5. <span data-ttu-id="60a12-236">Body ve Envelope öğelerini kapatın.</span><span class="sxs-lookup"><span data-stu-id="60a12-236">Close the body and envelope elements.</span></span>  
  
 <span data-ttu-id="60a12-237">Yukarıdaki adımlar SOAP standardına yakından bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="60a12-237">The preceding steps are closely tied to the SOAP standard.</span></span> <span data-ttu-id="60a12-238">Bu, SOAP 'ın birden çok sürümünün mevcut olması nedeniyle karmaşıktır. Örneğin, kullanımdaki SOAP sürümünü bilmeden SOAP Envelope öğesini doğru bir şekilde yazmak olanaksızdır.</span><span class="sxs-lookup"><span data-stu-id="60a12-238">This is complicated by the fact that multiple versions of SOAP exist, for example, it is impossible to write out the SOAP envelope element correctly without knowing the SOAP version in use.</span></span> <span data-ttu-id="60a12-239">Ayrıca, bazı durumlarda, bu karmaşık SOAP 'a özgü eşlemeyi tamamen kapatmak istenebilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-239">Also, in some cases, it may be desirable to turn off this complex SOAP-specific mapping completely.</span></span>  
  
 <span data-ttu-id="60a12-240">Bu amaçlar için üzerinde bir `Version` Özellik sağlanır `Message` .</span><span class="sxs-lookup"><span data-stu-id="60a12-240">For these purposes, a `Version` property is provided on `Message`.</span></span> <span data-ttu-id="60a12-241">İleti yazılırken kullanılacak SOAP sürümüne ayarlanabilir veya `None` SOAP 'a özgü tüm eşlemeleri engellemek için olarak ayarlanabilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-241">It can be set to the SOAP version to use when writing out the message, or it can be set to `None` to prevent any SOAP-specific mappings.</span></span> <span data-ttu-id="60a12-242">`Version`Özelliği olarak ayarlandıysa `None` , tüm iletiyle çalışan yöntemler ileti yalnızca gövdesinden oluyordu gibi davranır, örneğin, `WriteMessage` `WriteBodyContents` yukarıda listelenen birden çok adımı gerçekleştirmek yerine yalnızca çağırır.</span><span class="sxs-lookup"><span data-stu-id="60a12-242">If the `Version` property is set to `None`, methods that work with the entire message act as if the message consisted of its body only, for example, `WriteMessage` would simply call `WriteBodyContents` instead of performing the multiple steps listed above.</span></span> <span data-ttu-id="60a12-243">Gelen iletilerde, `Version` otomatik olarak algılanır ve doğru şekilde ayarlanacaktır.</span><span class="sxs-lookup"><span data-stu-id="60a12-243">It is expected that on incoming messages, `Version` will be auto-detected and set correctly.</span></span>  
  
## <a name="the-channel-stack"></a><span data-ttu-id="60a12-244">Kanal yığını</span><span class="sxs-lookup"><span data-stu-id="60a12-244">The Channel Stack</span></span>  
  
### <a name="channels"></a><span data-ttu-id="60a12-245">Kanallar</span><span class="sxs-lookup"><span data-stu-id="60a12-245">Channels</span></span>  
 <span data-ttu-id="60a12-246">Daha önce belirtildiği gibi, kanal yığını, giden <xref:System.ServiceModel.Channels.Message> örnekleri bazı eylemlere (örneğin, ağ üzerinden paket gönderme) veya bazı eylemleri (örneğin, ağ paketleri alma) gelen örneklere dönüştürmekten sorumludur `Message` .</span><span class="sxs-lookup"><span data-stu-id="60a12-246">As stated before, the channel stack is responsible for converting outgoing <xref:System.ServiceModel.Channels.Message> instances into some action (such as sending packets over the network), or converting some action (such as receiving network packets) into incoming `Message` instances.</span></span>  
  
 <span data-ttu-id="60a12-247">Kanal yığını, sırayla sıralanan bir veya daha fazla kanaldan oluşur.</span><span class="sxs-lookup"><span data-stu-id="60a12-247">The channel stack is composed of one or more channels ordered in a sequence.</span></span> <span data-ttu-id="60a12-248">Giden bir `Message` örnek, yığındaki ilk kanala geçirilir ( *en üstteki kanal*olarak da adlandırılır), bunu yığındaki bir sonraki kanala geçirir ve bu şekilde devam eder.</span><span class="sxs-lookup"><span data-stu-id="60a12-248">An outgoing `Message` instance is passed to the first channel in the stack (also called the *topmost channel*), which passes it to the next channel down in stack, and so on.</span></span> <span data-ttu-id="60a12-249">İleti, *aktarım kanalı*olarak adlandırılan son kanalda sonlanır.</span><span class="sxs-lookup"><span data-stu-id="60a12-249">The message terminates in the last channel, which is called the *transport channel*.</span></span> <span data-ttu-id="60a12-250">Gelen iletiler, aktarım kanalında kaynaklanar ve yığından kanala kadar kanal üzerinden geçirilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-250">Incoming messages originate in the transport channel and are passed from channel to channel up the stack.</span></span> <span data-ttu-id="60a12-251">En üstteki kanaldan ileti genellikle hizmet çerçevesine geçirilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-251">From the topmost channel, the message is usually passed into the service framework.</span></span> <span data-ttu-id="60a12-252">Bu, uygulama iletileri için normal bir modelken, bazı kanallar biraz farklı çalışabilir, örneğin, yukarıdaki kanaldan bir ileti iletilmeksizin kendi altyapı iletilerini gönderebilirler.</span><span class="sxs-lookup"><span data-stu-id="60a12-252">While this is the usual pattern for application messages, some channels may work slightly differently, for example, they may send their own infrastructure messages without being passed a message from a channel above.</span></span>  
  
 <span data-ttu-id="60a12-253">Kanallar, yığın aracılığıyla geçerken ileti üzerinde çeşitli yollarla işlem gösterebilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-253">Channels may operate on the message in various ways as it passes through the stack.</span></span> <span data-ttu-id="60a12-254">En yaygın işlem, giden bir iletiye üst bilgi ekliyor ve gelen bir iletideki üst bilgileri okuyor.</span><span class="sxs-lookup"><span data-stu-id="60a12-254">The most common operation is adding a header to an outgoing message and reading headers on an incoming message.</span></span> <span data-ttu-id="60a12-255">Örneğin, bir kanal bir iletinin dijital imzasını gösterebilir ve üst bilgi olarak ekleyebilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-255">For example, a channel may compute the digital signature of a message and add it as a header.</span></span> <span data-ttu-id="60a12-256">Kanal Ayrıca, gelen iletilerde bu dijital imza üst bilgisini inceleyebilir ve kanal yığınının yolunu yaparak geçerli imzaya sahip olmayan iletileri engelleyebilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-256">A channel may also inspect this digital signature header on incoming messages and block messages that do not have a valid signature from making their way up the channel stack.</span></span> <span data-ttu-id="60a12-257">Ayrıca kanallar, ileti özelliklerini de ayarlayabilir veya inceler.</span><span class="sxs-lookup"><span data-stu-id="60a12-257">Channels also often set or inspect message properties.</span></span> <span data-ttu-id="60a12-258">İleti gövdesi genellikle değiştirilmez, ancak buna izin verilir; Örneğin, WCF güvenlik kanalı ileti gövdesini şifreleyebilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-258">The message body is usually not modified, although this is allowed, for example, the WCF security channel can encrypt the message body.</span></span>  
  
### <a name="transport-channels-and-message-encoders"></a><span data-ttu-id="60a12-259">Taşıma kanalları ve Ileti kodlayıcıları</span><span class="sxs-lookup"><span data-stu-id="60a12-259">Transport Channels and Message Encoders</span></span>  
 <span data-ttu-id="60a12-260">Yığındaki en altta bulunan kanal, <xref:System.ServiceModel.Channels.Message> başka kanallar tarafından değiştirilmiş şekilde giden bir işlemi bazı eylemlere dönüştürmekten sorumludur.</span><span class="sxs-lookup"><span data-stu-id="60a12-260">The bottommost channel in the stack is responsible for actually transforming an outgoing <xref:System.ServiceModel.Channels.Message>, as modified by other channels, into some action.</span></span> <span data-ttu-id="60a12-261">Alma tarafında bu, bazı eylemleri `Message` diğer kanallar sürecine dönüştüren kanaldır.</span><span class="sxs-lookup"><span data-stu-id="60a12-261">On the receive side, this is the channel that converts some action into a `Message` that other channels process.</span></span>  
  
 <span data-ttu-id="60a12-262">Daha önce belirtildiği gibi, eylemler değiştirilebilir: çeşitli protokoller üzerinden ağ paketleri gönderme veya alma, iletiyi bir veritabanında okuma veya yazma ya da birkaç örnek sağlamak için bir Message Queuing sırasındaki iletiyi sıraya alma veya sıradan kaldırma.</span><span class="sxs-lookup"><span data-stu-id="60a12-262">As stated previously, the actions may be varied: sending or receiving network packets over various protocols, reading or writing the message in a database, or queuing or dequeuing the message in a Message Queuing queue, to provide but a few examples.</span></span> <span data-ttu-id="60a12-263">Tüm bu eylemlerin yaygın olarak bir şeyi vardır: WCF `Message` örneği ve gönderilebilecek, alınabilen, okunan, yazılan, sıraya alınmış veya kuyruğa alınan bir bayt grubu arasında bir dönüşüm gerektirir.</span><span class="sxs-lookup"><span data-stu-id="60a12-263">All these actions have one thing in common: they require a transformation between the WCF`Message` instance and an actual group of bytes that can be sent, received, read, written, queued, or dequeued.</span></span> <span data-ttu-id="60a12-264">Bir bayt grubuna dönüştürme işlemine `Message` *kodlama*denir ve bir bayt grubundan oluşturmak için ters işlem `Message` *kod çözme*olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="60a12-264">The process of converting a `Message` into a group of bytes is called *encoding*, and the reverse process of creating a `Message` from a group of bytes is called *decoding*.</span></span>  
  
 <span data-ttu-id="60a12-265">Çoğu aktarım kanalı kodlama ve kod çözme işini gerçekleştirmek için *ileti kodlayıcıları* adlı bileşenleri kullanır.</span><span class="sxs-lookup"><span data-stu-id="60a12-265">Most transport channels use components called *message encoders* to accomplish the encoding and decoding work.</span></span> <span data-ttu-id="60a12-266">İleti Kodlayıcısı, sınıfının bir alt sınıfıdır <xref:System.ServiceModel.Channels.MessageEncoder> .</span><span class="sxs-lookup"><span data-stu-id="60a12-266">A message encoder is a subclass of the <xref:System.ServiceModel.Channels.MessageEncoder> class.</span></span> <span data-ttu-id="60a12-267">`MessageEncoder``ReadMessage` `WriteMessage` , ve bayt gruplarını dönüştürmek için çeşitli ve yöntem aşırı yüklemeleri içerir `Message` .</span><span class="sxs-lookup"><span data-stu-id="60a12-267">`MessageEncoder` includes various `ReadMessage` and `WriteMessage` method overloads to convert between `Message` and groups of bytes.</span></span>  
  
 <span data-ttu-id="60a12-268">Gönderme tarafında, bir arabelleğe alma aktarım kanalı, `Message` onun üzerindeki bir kanaldan aldığı nesneyi geçirir `WriteMessage` .</span><span class="sxs-lookup"><span data-stu-id="60a12-268">On the sending side, a buffering transport channel passes the `Message` object that it received from a channel above it to `WriteMessage`.</span></span> <span data-ttu-id="60a12-269">Bu, daha sonra eylemini gerçekleştirmek için kullandığı bir bayt dizisini geri alır (Bu baytları geçerli TCP paketleri olarak paketleme ve doğru hedefe göndermek gibi).</span><span class="sxs-lookup"><span data-stu-id="60a12-269">It gets back an array of bytes, which it then uses to perform its action (such as packaging these bytes as valid TCP packets and sending them to the correct destination).</span></span> <span data-ttu-id="60a12-270">Bir akış aktarım kanalı, ilk olarak bir `Stream` (örneğin, gıden TCP bağlantısı üzerinden) oluşturur ve sonra hem hem de `Stream` ' nin, `Message` iletiyi yazan uygun aşırı yüklemeye gönderilmesi gerekir `WriteMessage` .</span><span class="sxs-lookup"><span data-stu-id="60a12-270">A streaming transport channel first creates a `Stream` (for example, over the outgoing TCP connection), and then passes both the `Stream` and the `Message` it needs to send to the appropriate `WriteMessage` overload, which writes out the message.</span></span>  
  
 <span data-ttu-id="60a12-271">Alma tarafında, bir arabelleğe alma aktarım kanalı gelen baytları (örneğin, gelen TCP paketlerinden) bir diziye ayıklar ve `ReadMessage` `Message` Kanal yığınını daha fazla geçirebildiğini bir nesne almak için çağırır.</span><span class="sxs-lookup"><span data-stu-id="60a12-271">On the receiving side, a buffering transport channel extracts incoming bytes (for example, from incoming TCP packets) into an array and calls `ReadMessage` to get a `Message` object that it can pass further up the channel stack.</span></span> <span data-ttu-id="60a12-272">Akış taşıma kanalı bir `Stream` nesne (örneğin, gelen TCP bağlantısı üzerinden bir ağ akışı) oluşturur ve `ReadMessage` bir nesneyi geri almak için ' a geçirir `Message` .</span><span class="sxs-lookup"><span data-stu-id="60a12-272">A streaming transport channel creates a `Stream` object (for example, a network stream over the incoming TCP connection) and passes that to `ReadMessage` to get back a `Message` object.</span></span>  
  
 <span data-ttu-id="60a12-273">Aktarım kanalları ve ileti Kodlayıcısı arasındaki ayrım zorunlu değildir; ileti Kodlayıcısı kullanmayan bir taşıma kanalı yazmak mümkündür.</span><span class="sxs-lookup"><span data-stu-id="60a12-273">The separation between the transport channels and the message encoder is not mandatory; it is possible to write a transport channel that does not use a message encoder.</span></span> <span data-ttu-id="60a12-274">Ancak, bu ayırmanın avantajı, bileşim kolaylığıdır.</span><span class="sxs-lookup"><span data-stu-id="60a12-274">However, the advantage of this separation is ease of composition.</span></span> <span data-ttu-id="60a12-275">Bir taşıma kanalı yalnızca temeli kullandığı sürece <xref:System.ServiceModel.Channels.MessageEncoder> , herhangi BIR WCF veya üçüncü taraf ileti Kodlayıcısı ile çalışabilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-275">As long as a transport channel uses only the base <xref:System.ServiceModel.Channels.MessageEncoder>, it can work with any WCF or third-party message encoder.</span></span> <span data-ttu-id="60a12-276">Benzer şekilde, aynı kodlayıcı normalde herhangi bir aktarım kanalında kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-276">Likewise, the same encoder can normally be used in any transport channel.</span></span>  
  
### <a name="message-encoder-operation"></a><span data-ttu-id="60a12-277">İleti Kodlayıcısı Işlemi</span><span class="sxs-lookup"><span data-stu-id="60a12-277">Message Encoder Operation</span></span>  
 <span data-ttu-id="60a12-278">Bir kodlayıcının tipik işlemini anlatmak için, aşağıdaki dört durumu göz önünde bulundurmanız yararlı olur.</span><span class="sxs-lookup"><span data-stu-id="60a12-278">To describe the typical operation of an encoder, it is useful to consider the following four cases.</span></span>  
  
|<span data-ttu-id="60a12-279">Çalışma</span><span class="sxs-lookup"><span data-stu-id="60a12-279">Operation</span></span>|<span data-ttu-id="60a12-280">Yorum</span><span class="sxs-lookup"><span data-stu-id="60a12-280">Comment</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="60a12-281">Kodlama, arabelleğe alınmış</span><span class="sxs-lookup"><span data-stu-id="60a12-281">Encoding, Buffered</span></span>|<span data-ttu-id="60a12-282">Tamponlanmış modda, kodlayıcı normalde değişken boyutlu bir arabellek oluşturur ve bundan sonra bunun üzerinde bir XML yazıcı oluşturur.</span><span class="sxs-lookup"><span data-stu-id="60a12-282">In buffered mode, the encoder normally creates a variable-size buffer and then creates an XML writer over it.</span></span> <span data-ttu-id="60a12-283">Daha sonra, <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> Bu konunun önceki bölümünde açıklandığı gibi, üst bilgileri ve ardından gövde bilgilerini yazan, kodlanan iletiyi çağırır `Message` .</span><span class="sxs-lookup"><span data-stu-id="60a12-283">It then calls <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> on the message being encoded, which writes out the headers and then the body using <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, as explained in the preceding section about `Message` in this topic.</span></span> <span data-ttu-id="60a12-284">Arabellek içeriği (bayt dizisi olarak gösterilir), daha sonra aktarım kanalının kullanması için döndürülür.</span><span class="sxs-lookup"><span data-stu-id="60a12-284">The contents of the buffer (represented as an array of bytes) are then returned for the transport channel to use.</span></span>|  
|<span data-ttu-id="60a12-285">Kodlama, akış</span><span class="sxs-lookup"><span data-stu-id="60a12-285">Encoding, Streamed</span></span>|<span data-ttu-id="60a12-286">Akış modunda, işlem yukarıya benzerdir, ancak daha basittir.</span><span class="sxs-lookup"><span data-stu-id="60a12-286">In streamed mode, the operation is similar to the above, but simpler.</span></span> <span data-ttu-id="60a12-287">Arabellek gereksinimi yoktur.</span><span class="sxs-lookup"><span data-stu-id="60a12-287">There is no need for a buffer.</span></span> <span data-ttu-id="60a12-288">Normalde akış üzerinden bir XML yazıcı oluşturulur ve <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> `Message` Bu yazıcıya yazmak için üzerinde çağrılır.</span><span class="sxs-lookup"><span data-stu-id="60a12-288">An XML writer is normally created over the stream and <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> is called on the `Message` to write it out to this writer.</span></span>|  
|<span data-ttu-id="60a12-289">Kod çözme, arabelleğe alınmış</span><span class="sxs-lookup"><span data-stu-id="60a12-289">Decoding, Buffered</span></span>|<span data-ttu-id="60a12-290">Arabelleğe alınan modda kod çözülürken, `Message` arabelleğe alınan verileri içeren özel bir alt sınıf normalde oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="60a12-290">When decoding in buffered mode, a special `Message` subclass that contains the buffered data is normally created.</span></span> <span data-ttu-id="60a12-291">İletinin üstbilgileri okunurdur ve ileti gövdesinde konumlandırılmış bir XML okuyucusu oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="60a12-291">The headers of the message are read, and an XML reader positioned on the message body is created.</span></span> <span data-ttu-id="60a12-292">Bu, ile döndürülecek olan okuyucudur <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> .</span><span class="sxs-lookup"><span data-stu-id="60a12-292">This is the reader that will be returned with <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span></span>|  
|<span data-ttu-id="60a12-293">Kod çözme, akışlı</span><span class="sxs-lookup"><span data-stu-id="60a12-293">Decoding, Streamed</span></span>|<span data-ttu-id="60a12-294">Akan modda kod çözmede, normalde özel bir Ileti alt sınıfı oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="60a12-294">When decoding in streamed mode, a special Message subclass is normally created.</span></span> <span data-ttu-id="60a12-295">Akış, tüm üst bilgileri okumak ve ileti gövdesinde konumlandırmak için yeterince gelişmiş bir hale gelir.</span><span class="sxs-lookup"><span data-stu-id="60a12-295">The stream is advanced just enough to read all the headers and position it on the message body.</span></span> <span data-ttu-id="60a12-296">Daha sonra Stream üzerinden bir XML okuyucusu oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="60a12-296">An XML reader is then created over the stream.</span></span> <span data-ttu-id="60a12-297">Bu, ile döndürülecek olan okuyucudur <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> .</span><span class="sxs-lookup"><span data-stu-id="60a12-297">This is the reader that will be returned with <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span></span>|  
  
 <span data-ttu-id="60a12-298">Kodlayıcılar, diğer işlevleri de gerçekleştirebilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-298">Encoders can perform other functions as well.</span></span> <span data-ttu-id="60a12-299">Örneğin, kodlayıcılar XML okuyucularını ve yazarları havuza alabilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-299">For example, the encoders can pool XML readers and writers.</span></span> <span data-ttu-id="60a12-300">Her gerektiğinde yeni bir XML okuyucu veya yazıcı oluşturmak pahalıdır.</span><span class="sxs-lookup"><span data-stu-id="60a12-300">It is expensive to create a new XML reader or writer every time one is needed.</span></span> <span data-ttu-id="60a12-301">Bu nedenle, kodlayıcılar normalde bir okuyucu havuzunu ve yapılandırılabilir boyuttaki bir yazıcı havuzunu korur.</span><span class="sxs-lookup"><span data-stu-id="60a12-301">Therefore, encoders normally maintain a pool of readers and a pool of writers of configurable size.</span></span> <span data-ttu-id="60a12-302">Daha önce açıklanan kodlayıcı, "bir XML okuyucu/yazıcı oluştur" ifadesi kullanıldığında, normalde "havuzdan bir tane al veya yoksa bir tane oluştur" anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="60a12-302">In the descriptions of encoder operation described previously, whenever the phrase "create an XML reader/writer" is used, it normally means "take one from the pool, or create one if one is not available."</span></span> <span data-ttu-id="60a12-303">Kodlayıcı (ve `Message` kod çözme sırasında oluşturduğu alt sınıflar), artık gerekli olmadığında (örneğin, kapatıldığında), bu havuzlara okuyucuları ve yazarları döndürme mantığını içerir `Message` .</span><span class="sxs-lookup"><span data-stu-id="60a12-303">The encoder (and the `Message` subclasses it creates while decoding) contain logic to return readers and writers to the pools once they are no longer needed (for example, when the `Message` is closed).</span></span>  
  
 <span data-ttu-id="60a12-304">WCF, ek özel türler oluşturmak mümkün olsa da üç ileti kodlayıcıları sağlar.</span><span class="sxs-lookup"><span data-stu-id="60a12-304">WCF provides three message encoders, although it is possible to create additional custom types.</span></span> <span data-ttu-id="60a12-305">Sağlanan türler metin, Ikili ve Ileti Iletimi Iyileştirme mekanizmasıdır (MTOM).</span><span class="sxs-lookup"><span data-stu-id="60a12-305">The supplied types are Text, Binary, and Message Transmission Optimization Mechanism (MTOM).</span></span> <span data-ttu-id="60a12-306">Bunlar, [Ileti Kodlayıcısı seçme](choosing-a-message-encoder.md)konusunda ayrıntılı olarak açıklanmıştır.</span><span class="sxs-lookup"><span data-stu-id="60a12-306">These are described in detail in [Choosing a Message Encoder](choosing-a-message-encoder.md).</span></span>  
  
### <a name="the-istreamprovider-interface"></a><span data-ttu-id="60a12-307">IStreamProvider arabirimi</span><span class="sxs-lookup"><span data-stu-id="60a12-307">The IStreamProvider Interface</span></span>  
 <span data-ttu-id="60a12-308">Bir XML yazıcısına akışlı gövde içeren giden bir ileti yazarken, <xref:System.ServiceModel.Channels.Message> uygulamasında şuna benzer bir çağrı dizisi kullanır <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> :</span><span class="sxs-lookup"><span data-stu-id="60a12-308">When writing an outgoing message that contains a streamed body to an XML writer, the <xref:System.ServiceModel.Channels.Message> uses a sequence of calls similar to the following in its <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> implementation:</span></span>  
  
- <span data-ttu-id="60a12-309">Akıştan önce gerekli tüm bilgileri yazın (örneğin, açılış XML etiketi).</span><span class="sxs-lookup"><span data-stu-id="60a12-309">Write any necessary information preceding the stream (for example, the opening XML tag).</span></span>  
  
- <span data-ttu-id="60a12-310">Akışı yazın.</span><span class="sxs-lookup"><span data-stu-id="60a12-310">Write the stream.</span></span>  
  
- <span data-ttu-id="60a12-311">Akışı izleyen tüm bilgileri yazın (örneğin, kapanış XML etiketi).</span><span class="sxs-lookup"><span data-stu-id="60a12-311">Write any information following the stream (for example, the closing XML tag).</span></span>  
  
 <span data-ttu-id="60a12-312">Bu, metinsel XML kodlamasıyla benzer kodlamalar ile iyi sonuç verir.</span><span class="sxs-lookup"><span data-stu-id="60a12-312">This works well with encodings that are similar to the textual XML encoding.</span></span> <span data-ttu-id="60a12-313">Ancak bazı kodlamalar, XML bilgi kümesi bilgilerini (örneğin, XML öğelerini başlatma ve sonlandırma etiketleri) öğeler içinde içerilen verilerle birlikte yerleştirmez.</span><span class="sxs-lookup"><span data-stu-id="60a12-313">However, some encodings do not place XML Infoset information (for example, tags for starting and ending XML elements) together with the data contained within elements.</span></span> <span data-ttu-id="60a12-314">Örneğin, MTOM kodlamasıyla ileti birden çok parçaya bölünür.</span><span class="sxs-lookup"><span data-stu-id="60a12-314">For example, in the MTOM encoding, the message is split into multiple parts.</span></span> <span data-ttu-id="60a12-315">Bir parça, gerçek öğe içerikleri için diğer bölümlere başvurular içerebilen XML bilgi kümesini içerir.</span><span class="sxs-lookup"><span data-stu-id="60a12-315">One part contains the XML Infoset, which may contain references to other parts for actual element contents.</span></span> <span data-ttu-id="60a12-316">XML bilgi kümesi normal olarak akışla karşılaştırıldığında küçük, bu nedenle bilgi kümesini arabelleğe alma, yazma ve sonra içeriği akışlı bir şekilde yazma açısından anlamlı hale gelir.</span><span class="sxs-lookup"><span data-stu-id="60a12-316">The XML Infoset is normally small compared to the streamed contents, so it makes sense to buffer the Infoset, write it out, and then write the contents in a streamed way.</span></span> <span data-ttu-id="60a12-317">Bu, kapanış öğesi etiketinin yazıldığı zamana göre akışın henüz yazılmamış olması anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="60a12-317">This means that by the time the closing element tag is written, the stream should not have been written out yet.</span></span>  
  
 <span data-ttu-id="60a12-318">Bu amaçla, <xref:System.Xml.IStreamProvider> arabirim kullanılır.</span><span class="sxs-lookup"><span data-stu-id="60a12-318">For this purpose, the <xref:System.Xml.IStreamProvider> interface is used.</span></span> <span data-ttu-id="60a12-319">Arabirimin <xref:System.Xml.IStreamProvider.GetStream> yazılacak akışı döndüren bir yöntemi vardır.</span><span class="sxs-lookup"><span data-stu-id="60a12-319">The interface has a <xref:System.Xml.IStreamProvider.GetStream> method that returns the stream to be written.</span></span> <span data-ttu-id="60a12-320">Akış ileti gövdesini yazmanın doğru yolu <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> aşağıdaki gibidir:</span><span class="sxs-lookup"><span data-stu-id="60a12-320">The correct way to write out a streamed message body in <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> is as follows:</span></span>  
  
1. <span data-ttu-id="60a12-321">Akıştan önce gerekli tüm bilgileri yazın (örneğin, açılış XML etiketi).</span><span class="sxs-lookup"><span data-stu-id="60a12-321">Write any necessary information preceding the stream (for example, the opening XML tag).</span></span>  
  
2. <span data-ttu-id="60a12-322">`WriteValue`Üzerine <xref:System.Xml.XmlDictionaryWriter> <xref:System.Xml.IStreamProvider> yazılacak akışı döndüren bir uygulamayla birlikte olan aşırı yüklemeyi çağırın `IStreamProvider` .</span><span class="sxs-lookup"><span data-stu-id="60a12-322">Call the `WriteValue` overload on the <xref:System.Xml.XmlDictionaryWriter> that takes an <xref:System.Xml.IStreamProvider>, with an `IStreamProvider` implementation that returns the stream to be written.</span></span>  
  
3. <span data-ttu-id="60a12-323">Akışı izleyen tüm bilgileri yazın (örneğin, kapanış XML etiketi).</span><span class="sxs-lookup"><span data-stu-id="60a12-323">Write any information following the stream (for example, the closing XML tag).</span></span>  
  
 <span data-ttu-id="60a12-324">Bu yaklaşımda XML yazıcı, akış verilerinin ne zaman çağrılacağını ve yazılacağı bir seçenek içerir <xref:System.Xml.IStreamProvider.GetStream> .</span><span class="sxs-lookup"><span data-stu-id="60a12-324">With this approach, the XML writer has a choice of when to call <xref:System.Xml.IStreamProvider.GetStream> and write out the streamed data.</span></span> <span data-ttu-id="60a12-325">Örneğin, metin ve ikili XML yazarları hemen çağırır ve başlangıç ve bitiş etiketleri arasında akış içeriğini içine yazar.</span><span class="sxs-lookup"><span data-stu-id="60a12-325">For example, the textual and binary XML writers will call it immediately and write out the streamed contents in-between the start and end tags.</span></span> <span data-ttu-id="60a12-326">MTOM yazıcısı, <xref:System.Xml.IStreamProvider.GetStream> iletinin ilgili bölümünü yazmaya uygun olduğunda daha sonra çağrı yapmaya karar verebilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-326">The MTOM writer may decide to call <xref:System.Xml.IStreamProvider.GetStream> later, when it is ready to write the appropriate part of the message.</span></span>  
  
## <a name="representing-data-in-the-service-framework"></a><span data-ttu-id="60a12-327">Hizmet çerçevesindeki verileri temsil etme</span><span class="sxs-lookup"><span data-stu-id="60a12-327">Representing Data in the Service Framework</span></span>  
 <span data-ttu-id="60a12-328">Bu konunun "temel mimari" bölümünde belirtildiği gibi, hizmet çerçevesi, diğer şeyler arasında, ileti verileri ve gerçek örnekler için Kullanıcı dostu bir programlama modeli arasında dönüştürme yapmaktan sorumludur `Message` .</span><span class="sxs-lookup"><span data-stu-id="60a12-328">As stated in the "Basic Architecture" section of this topic, the service framework is the part of WCF that, among other things, is responsible for converting between a user-friendly programming model for message data and actual `Message` instances.</span></span> <span data-ttu-id="60a12-329">Normalde, bir ileti alışverişi, Service Framework 'te özniteliğiyle işaretlenmiş .NET Framework yöntemi olarak temsil edilir <xref:System.ServiceModel.OperationContractAttribute> .</span><span class="sxs-lookup"><span data-stu-id="60a12-329">Normally, a message exchange is represented in the service framework as a .NET Framework method marked with the <xref:System.ServiceModel.OperationContractAttribute> attribute.</span></span> <span data-ttu-id="60a12-330">Yöntemi bazı parametreleri alabilir ve dönüş değeri veya out parametreleri (veya her ikisi) döndürebilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-330">The method can take in some parameters and can return a return value or out parameters (or both).</span></span> <span data-ttu-id="60a12-331">Hizmet tarafında, giriş parametreleri gelen iletiyi temsil eder ve dönüş değeri ve çıkış parametreleri giden iletiyi temsil eder.</span><span class="sxs-lookup"><span data-stu-id="60a12-331">On the service side, the input parameters represent the incoming message, and the return value and out parameters represent the outgoing message.</span></span> <span data-ttu-id="60a12-332">İstemci tarafında ters, doğru olur.</span><span class="sxs-lookup"><span data-stu-id="60a12-332">On the client side, the reverse is true.</span></span> <span data-ttu-id="60a12-333">Parametreleri ve dönüş değerini kullanarak iletileri tanımlamaya yönelik programlama modeli, [hizmet sözleşmelerinde veri aktarımı belirtme](specifying-data-transfer-in-service-contracts.md)konusunda ayrıntılı olarak açıklanmıştır.</span><span class="sxs-lookup"><span data-stu-id="60a12-333">The programming model for describing messages using parameters and the return value is described in detail in [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span></span> <span data-ttu-id="60a12-334">Ancak, bu bölümde kısa bir genel bakış sağlanır.</span><span class="sxs-lookup"><span data-stu-id="60a12-334">However, this section will provide a brief overview.</span></span>  
  
## <a name="programming-models"></a><span data-ttu-id="60a12-335">Programlama modelleri</span><span class="sxs-lookup"><span data-stu-id="60a12-335">Programming Models</span></span>  
 <span data-ttu-id="60a12-336">WCF hizmet çerçevesi, iletileri açıklamak için beş farklı programlama modelini destekler:</span><span class="sxs-lookup"><span data-stu-id="60a12-336">The WCF service framework supports five different programming models for describing messages:</span></span>  
  
### <a name="1-the-empty-message"></a><span data-ttu-id="60a12-337">1. boş Ileti</span><span class="sxs-lookup"><span data-stu-id="60a12-337">1. The Empty Message</span></span>  
 <span data-ttu-id="60a12-338">Bu en basit durumdur.</span><span class="sxs-lookup"><span data-stu-id="60a12-338">This is the simplest case.</span></span> <span data-ttu-id="60a12-339">Boş bir gelen iletiyi anlatmak için herhangi bir giriş parametresi kullanmayın.</span><span class="sxs-lookup"><span data-stu-id="60a12-339">To describe an empty incoming message, do not use any input parameters.</span></span>  
  
 [!code-csharp[C_DataArchitecture#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#3)]
 [!code-vb[C_DataArchitecture#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#3)]  
  
 <span data-ttu-id="60a12-340">Boş bir giden iletiyi anlatmak için, void dönüş değeri kullanın ve herhangi bir out parametresi kullanmayın:</span><span class="sxs-lookup"><span data-stu-id="60a12-340">To describe an empty outgoing message, use a void return value and do not use any out parameters:</span></span>  
  
 [!code-csharp[C_DataArchitecture#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#4)]
 [!code-vb[C_DataArchitecture#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#4)]  
  
 <span data-ttu-id="60a12-341">Bunun tek yönlü bir işlem sözleşmesinden farklı olduğunu unutmayın:</span><span class="sxs-lookup"><span data-stu-id="60a12-341">Note that this is different from a one-way operation contract:</span></span>  
  
 [!code-csharp[C_DataArchitecture#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#5)]
 [!code-vb[C_DataArchitecture#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#5)]  
  
 <span data-ttu-id="60a12-342">`SetDesiredTemperature`Örnekte, iki yönlü bir ileti değişimi deseninin açıklaması vardır.</span><span class="sxs-lookup"><span data-stu-id="60a12-342">In the `SetDesiredTemperature` example, a two-way message exchange pattern is described.</span></span> <span data-ttu-id="60a12-343">İşlemden bir ileti döndürülür, ancak boştur.</span><span class="sxs-lookup"><span data-stu-id="60a12-343">A message is returned from the operation, but it is empty.</span></span> <span data-ttu-id="60a12-344">İşlemden bir hata döndürmek mümkündür.</span><span class="sxs-lookup"><span data-stu-id="60a12-344">It is possible to return a fault from the operation.</span></span> <span data-ttu-id="60a12-345">"Ampul ayarla" örneğinde ileti değişim şekli tek yönlü olduğundan, görüntülenecek giden bir ileti yoktur.</span><span class="sxs-lookup"><span data-stu-id="60a12-345">In the "Set Lightbulb" example, the message exchange pattern is one-way, so there is no outgoing message to describe.</span></span> <span data-ttu-id="60a12-346">Hizmet bu durumda istemciye herhangi bir durum geri iletişim kuramıyor.</span><span class="sxs-lookup"><span data-stu-id="60a12-346">The service cannot communicate any status back to the client in this case.</span></span>  
  
### <a name="2-using-the-message-class-directly"></a><span data-ttu-id="60a12-347">2. Ileti sınıfını doğrudan kullanma</span><span class="sxs-lookup"><span data-stu-id="60a12-347">2. Using the Message Class Directly</span></span>  
 <span data-ttu-id="60a12-348"><xref:System.ServiceModel.Channels.Message>Doğrudan bir işlem sözleşmesindeki sınıfı (veya alt sınıflarından birini) kullanmak mümkündür.</span><span class="sxs-lookup"><span data-stu-id="60a12-348">It is possible to use the <xref:System.ServiceModel.Channels.Message> class (or one of its subclasses) directly in an operation contract.</span></span> <span data-ttu-id="60a12-349">Bu durumda, Service Framework, `Message` işlemi daha fazla işleme olmadan işlemden yalnızca kanal yığınına geçirir.</span><span class="sxs-lookup"><span data-stu-id="60a12-349">In this case, the service framework just passes the `Message` from the operation to the channel stack and vice versa, with no further processing.</span></span>  
  
 <span data-ttu-id="60a12-350">Doğrudan kullanımı için iki ana kullanım durumu vardır `Message` .</span><span class="sxs-lookup"><span data-stu-id="60a12-350">There are two main use cases for using `Message` directly.</span></span> <span data-ttu-id="60a12-351">Diğer programlama modellerinin hiçbiri size iletinizi anlatmak için yeterli esneklik sunmadığı durumlarda bu gelişmiş senaryolar için kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="60a12-351">You can use this for advanced scenarios, when none of the other programming models gives you enough flexibility to describe your message.</span></span> <span data-ttu-id="60a12-352">Örneğin, dosyanın özellikleri ileti üst bilgileri ve dosyanın içeriği ileti gövdesinde olacak şekilde bir iletiyi anlatmak için diskteki dosyaları kullanmak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="60a12-352">For example, you might want to use files on disk to describe a message, with the file’s properties becoming message headers and the file’s contents becoming the message body.</span></span> <span data-ttu-id="60a12-353">Ardından aşağıdakine benzer bir şey oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="60a12-353">You can then create something similar to the following.</span></span>  
  
 [!code-csharp[C_DataArchitecture#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#6)]
 [!code-vb[C_DataArchitecture#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#6)]  
  
 <span data-ttu-id="60a12-354">`Message`Bir işlem sözleşmesindeki ikinci yaygın kullanımı, bir hizmetin belirli ileti içeriğiyle ilgilenmez ve bir siyah kutuda olduğu gibi ileti üzerinde işlem yapar.</span><span class="sxs-lookup"><span data-stu-id="60a12-354">The second common use for `Message` in an operation contract is when a service does not care about the particular message contents and acts on the message as on a black box.</span></span> <span data-ttu-id="60a12-355">Örneğin, iletileri birden çok alıcıya ileten bir hizmetiniz olabilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-355">For example, you might have a service that forwards messages to multiple other recipients.</span></span> <span data-ttu-id="60a12-356">Sözleşme aşağıdaki gibi yazılabilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-356">The contract can be written as follows.</span></span>  
  
 [!code-csharp[C_DataArchitecture#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#7)]
 [!code-vb[C_DataArchitecture#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#7)]  
  
 <span data-ttu-id="60a12-357">Action = "\*" satırı, ileti gönderme işlemini etkin bir şekilde devre dışı bırakır ve sözleşmeye gönderilen tüm iletilerin `IForwardingService` işlem için kendi yolunu yapmasını sağlar `ForwardMessage` .</span><span class="sxs-lookup"><span data-stu-id="60a12-357">The Action="\*" line effectively turns off message dispatching and ensures that all messages sent to the `IForwardingService` contract make their way to the `ForwardMessage` operation.</span></span> <span data-ttu-id="60a12-358">(Normalde, dağıtıcı iletinin "eylem" üst bilgisini inceleyerek hangi işlemin hedeflendiğinden belirlenir.</span><span class="sxs-lookup"><span data-stu-id="60a12-358">(Normally, the dispatcher would examine the message’s "Action" header to determine which operation it is intended for.</span></span> <span data-ttu-id="60a12-359">Action = " \* ", "eylem üstbilgisinin tüm olası değerleri" anlamına gelir.) # "" Eyleminin birleşimi \* ve iletinin bir parametre olarak kullanılması "evrensel sözleşme" olarak bilinir, çünkü tüm olası iletileri alabiliyor.</span><span class="sxs-lookup"><span data-stu-id="60a12-359">Action="\*" means "all possible values of the Action header".) The combination of Action="\*" and using Message as a parameter is known as the "universal contract" because it is able to receive all possible messages.</span></span> <span data-ttu-id="60a12-360">Olası tüm iletileri gönderebilmek için, dönüş değeri olarak Ileti kullanın ve `ReplyAction` "" olarak ayarlayın \* .</span><span class="sxs-lookup"><span data-stu-id="60a12-360">To be able to send all possible messages, use Message as the return value and set `ReplyAction` to "\*".</span></span> <span data-ttu-id="60a12-361">Bu, Service Framework 'ün kendi eylem üst bilgisini eklemesini engelleyecek ve bu üstbilgiyi, geri yüklediğiniz nesneyi kullanarak denetlemenizi sağlar `Message` .</span><span class="sxs-lookup"><span data-stu-id="60a12-361">This will prevent the service framework from adding its own Action header, enabling you to control this header using the `Message` object you return.</span></span>  
  
### <a name="3-message-contracts"></a><span data-ttu-id="60a12-362">3. ileti sözleşmeleri</span><span class="sxs-lookup"><span data-stu-id="60a12-362">3. Message Contracts</span></span>  
 <span data-ttu-id="60a12-363">WCF, *İleti sözleşmeleri*olarak adlandırılan iletileri açıklamak için bildirim temelli bir programlama modeli sağlar.</span><span class="sxs-lookup"><span data-stu-id="60a12-363">WCF provides a declarative programming model for describing messages, called *message contracts*.</span></span> <span data-ttu-id="60a12-364">Bu model, [Ileti sözleşmelerini kullanma](using-message-contracts.md)konusunda ayrıntılı olarak açıklanmıştır.</span><span class="sxs-lookup"><span data-stu-id="60a12-364">This model is described in detail in [Using Message Contracts](using-message-contracts.md).</span></span> <span data-ttu-id="60a12-365">Esas olarak, tüm ileti, ileti <xref:System.ServiceModel.MessageBodyMemberAttribute> <xref:System.ServiceModel.MessageHeaderAttribute> sözleşmesi sınıfının hangi bölümlerinin ileti parçasını eşlemek için ve gibi öznitelikleri kullanan tek bir .NET Framework türü ile temsil edilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-365">Essentially, the entire message is represented by a single .NET Framework type that uses attributes like the <xref:System.ServiceModel.MessageBodyMemberAttribute> and <xref:System.ServiceModel.MessageHeaderAttribute> to describe which parts of the message contract class should map to which part of the message.</span></span>  
  
 <span data-ttu-id="60a12-366">İleti sözleşmeleri, sonuçta elde edilen örnekler üzerinde çok fazla denetim sağlar `Message` (ancak doğrudan sınıfı kullanmakla çok fazla denetim olmasa da `Message` ).</span><span class="sxs-lookup"><span data-stu-id="60a12-366">Message contracts provide a lot of control over the resulting `Message` instances (although obviously not as much control as using the `Message` class directly).</span></span> <span data-ttu-id="60a12-367">Örneğin, ileti gövdeleri genellikle kendi XML öğesiyle temsil edilen birden çok bilgi parçalarından oluşur.</span><span class="sxs-lookup"><span data-stu-id="60a12-367">For example, message bodies are often composed of multiple pieces of information, each represented by its own XML element.</span></span> <span data-ttu-id="60a12-368">Bu öğeler doğrudan gövdede (*çıplak* mod) gerçekleşebilir ya da çevreleyen bir XML öğesinde *kaydırılmış* olabilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-368">These elements can either occur directly in the body (*bare* mode) or can be *wrapped* in an encompassing XML element.</span></span> <span data-ttu-id="60a12-369">İleti sözleşmesi programlama modelinin kullanılması, tam olarak sarmalanmış kararı yapmanızı ve sarmalayıcı adının ve ad alanının adını denetlemenizi sağlar.</span><span class="sxs-lookup"><span data-stu-id="60a12-369">Using the message contract programming model enables you to make the bare-versus-wrapped decision and control the name of the wrapper name and namespace.</span></span>  
  
 <span data-ttu-id="60a12-370">Bir ileti sözleşmesinin aşağıdaki kod örneği bu özellikleri gösterir.</span><span class="sxs-lookup"><span data-stu-id="60a12-370">The following code example of a message contract demonstrates these features.</span></span>  
  
 [!code-csharp[C_DataArchitecture#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#9)]
 [!code-vb[C_DataArchitecture#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#9)]  
  
 <span data-ttu-id="60a12-371">Serileştirilmesi için işaretlenmiş öğelerin ( <xref:System.ServiceModel.MessageBodyMemberAttribute> , <xref:System.ServiceModel.MessageHeaderAttribute> veya diğer ilgili özniteliklerle) bir ileti sözleşmesine katılması için seri hale getirilebilir olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="60a12-371">Items marked to be serialized (with the <xref:System.ServiceModel.MessageBodyMemberAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>, or other related attributes) must be serializable to participate in a message contract.</span></span> <span data-ttu-id="60a12-372">Daha fazla bilgi için bu konunun ilerleyen bölümlerindeki "serileştirme" bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="60a12-372">For more information, see the "Serialization" section later in this topic.</span></span>  
  
### <a name="4-parameters"></a><span data-ttu-id="60a12-373">4. parametreler</span><span class="sxs-lookup"><span data-stu-id="60a12-373">4. Parameters</span></span>  
 <span data-ttu-id="60a12-374">Genellikle, birden çok veri parçasına davranan bir işlemi anlatmak isteyen bir geliştirici, ileti sözleşmelerinin sağladığı denetim derecesini gerektirmez.</span><span class="sxs-lookup"><span data-stu-id="60a12-374">Often, a developer who wants to describe an operation that acts on multiple pieces of data does not need the degree of control that message contracts provide.</span></span> <span data-ttu-id="60a12-375">Örneğin, yeni hizmetler oluştururken, bir tane genellikle, tek başına sarmalanmış kararı yapmak ve sarmalayıcı öğe adına karar vermek istemez.</span><span class="sxs-lookup"><span data-stu-id="60a12-375">For example, when creating new services, one does not usually want to make the bare-versus-wrapped decision and decide on the wrapper element name.</span></span> <span data-ttu-id="60a12-376">Bu kararların genellikle Web Hizmetleri ve SOAP hakkında ayrıntılı bilgi sahibi olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="60a12-376">Making these decisions often requires deep knowledge of Web services and SOAP.</span></span>  
  
 <span data-ttu-id="60a12-377">WCF hizmet çerçevesi, bu seçeneklere Kullanıcı üzerinde zorlanmadan, birden fazla ilgili bilgi alma veya alma için en iyi ve en fazla birlikte çalışabilen SOAP gösterimini otomatik olarak seçebilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-377">The WCF service framework can automatically pick the best and most interoperable SOAP representation for sending or receiving multiple related pieces of information, without forcing these choices on the user.</span></span> <span data-ttu-id="60a12-378">Bu, yalnızca bu bilgi parçalarını parametre olarak açıklayarak veya bir işlem sözleşmesinin dönüş değeri tarafından gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-378">This is accomplished by simply describing these pieces of information as parameters or return values of an operation contract.</span></span> <span data-ttu-id="60a12-379">Örneğin, aşağıdaki işlem sözleşmesini göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="60a12-379">For example, consider the following operation contract.</span></span>  
  
 [!code-csharp[C_DataArchitecture#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#11)]
 [!code-vb[C_DataArchitecture#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#11)]  
  
 <span data-ttu-id="60a12-380">Service Framework, her üç bilgi parçasını ( `customerID` , `item` , ve `quantity` ) ileti gövdesine yerleştirmeye ve bunları adlı bir sarmalayıcı öğesinde sarmalamaya otomatik olarak karar verir `SubmitOrderRequest` .</span><span class="sxs-lookup"><span data-stu-id="60a12-380">The service framework automatically decides to put all three pieces of information (`customerID`, `item`, and `quantity`) into the message body and wrap them in a wrapper element named `SubmitOrderRequest`.</span></span>  
  
 <span data-ttu-id="60a12-381">Daha karmaşık ileti sözleşmesine veya tabanlı programlama modellerine geçiş yapmak için özel nedenler olmadığı sürece, işlem sözleşmesi parametrelerinin basit bir listesi olarak gönderilecek veya alınacak bilgilerin açıklaması önerilen yaklaşımdır `Message` .</span><span class="sxs-lookup"><span data-stu-id="60a12-381">Describing the information to be sent or received as a simple list of operation contract parameters is the recommended approach, unless special reasons exist to move to the more-complex message contract or `Message`-based programming models.</span></span>  
  
### <a name="5-stream"></a><span data-ttu-id="60a12-382">5. akış</span><span class="sxs-lookup"><span data-stu-id="60a12-382">5. Stream</span></span>  
 <span data-ttu-id="60a12-383">Bir `Stream` işlem sözleşmesindeki alt sınıflarından veya bir ileti sözleşmesinin tek bir ileti gövdesinde bir parçası olarak, yukarıda açıklananlardan farklı bir programlama modeli olarak düşünülebilir.</span><span class="sxs-lookup"><span data-stu-id="60a12-383">Using `Stream` or one of its subclasses in an operation contract or as a sole message body part in a message contract can be considered a separate programming model from the ones described above.</span></span> <span data-ttu-id="60a12-384">`Stream`Bu şekilde kullanılması, sözleşmenizi, akış uyumlu alt sınıfınıza yazmanın kısa bir süre içinde kullanılabilir olacağını güvence altına almanın tek yoludur `Message` .</span><span class="sxs-lookup"><span data-stu-id="60a12-384">Using `Stream` in this way is the only way to guarantee that your contract will be usable in a streamed fashion, short of writing your own streaming-compatible `Message` subclass.</span></span> <span data-ttu-id="60a12-385">Daha fazla bilgi için bkz. [büyük veri ve akış](large-data-and-streaming.md).</span><span class="sxs-lookup"><span data-stu-id="60a12-385">For more information, see [Large Data and Streaming](large-data-and-streaming.md).</span></span>  
  
 <span data-ttu-id="60a12-386">`Stream`Bu şekilde bir veya alt sınıflarından biri kullanıldığında seri hale getirici çağrılmaz.</span><span class="sxs-lookup"><span data-stu-id="60a12-386">When `Stream` or one of its subclasses is used in this way, the serializer is not invoked.</span></span> <span data-ttu-id="60a12-387">Giden iletiler için özel bir akış `Message` alt sınıfı oluşturulur ve bu akış, arabirimdeki bölümünde açıklandığı gibi yazılır <xref:System.Xml.IStreamProvider> .</span><span class="sxs-lookup"><span data-stu-id="60a12-387">For outgoing messages, a special streaming `Message` subclass is created and the stream is written out as described in the section on the <xref:System.Xml.IStreamProvider> interface.</span></span> <span data-ttu-id="60a12-388">Gelen iletilerde, Service Framework `Stream` gelen ileti üzerinde bir alt sınıf oluşturur ve bunu işleme sağlar.</span><span class="sxs-lookup"><span data-stu-id="60a12-388">For incoming messages, the service framework creates a `Stream` subclass over the incoming message and provides it to the operation.</span></span>  
  
## <a name="programming-model-restrictions"></a><span data-ttu-id="60a12-389">Programlama modeli kısıtlamaları</span><span class="sxs-lookup"><span data-stu-id="60a12-389">Programming Model Restrictions</span></span>  
 <span data-ttu-id="60a12-390">Yukarıda açıklanan programlama modelleri rastgele birleştirilemez.</span><span class="sxs-lookup"><span data-stu-id="60a12-390">The programming models described above cannot be arbitrarily combined.</span></span> <span data-ttu-id="60a12-391">Örneğin, bir işlem bir ileti sözleşme türünü kabul ediyorsa, ileti sözleşmesinin yalnızca giriş parametresi olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="60a12-391">For example, if an operation accepts a message contract type, the message contract must be its only input parameter.</span></span> <span data-ttu-id="60a12-392">Ayrıca, işlemin daha sonra boş bir ileti (void dönüş türü) ya da başka bir ileti sözleşmesi döndürmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="60a12-392">Furthermore, the operation must then either return an empty message (return type of void) or another message contract.</span></span> <span data-ttu-id="60a12-393">Bu programlama modeli kısıtlamaları, her belirli programlama modeli için konularda açıklanmaktadır: ileti [sözleşmelerini](using-message-contracts.md)kullanma, [Ileti sınıfı](using-the-message-class.md)ve [büyük veri ve akış](large-data-and-streaming.md).</span><span class="sxs-lookup"><span data-stu-id="60a12-393">These programming model restrictions are described in the topics for each specific programming model: [Using Message Contracts](using-message-contracts.md), [Using the Message Class](using-the-message-class.md), and [Large Data and Streaming](large-data-and-streaming.md).</span></span>  
  
## <a name="message-formatters"></a><span data-ttu-id="60a12-394">İleti formatları</span><span class="sxs-lookup"><span data-stu-id="60a12-394">Message Formatters</span></span>  
 <span data-ttu-id="60a12-395">Yukarıda açıklanan programlama modelleri, hizmet çerçevesine *ileti biçimleri* olarak adlandırılan bileşenleri takarak desteklenir.</span><span class="sxs-lookup"><span data-stu-id="60a12-395">The programming models described above are supported by plugging in components called *message formatters* into the service framework.</span></span> <span data-ttu-id="60a12-396">İleti formatlayıcıları, <xref:System.ServiceModel.Dispatcher.IClientMessageFormatter> veya <xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter> arabirimini veya her ikisini de, istemcilerde ve hizmet WCF istemcilerinde kullanılmak üzere, sırasıyla uygulayan türlerdir.</span><span class="sxs-lookup"><span data-stu-id="60a12-396">Message formatters are types that implement the <xref:System.ServiceModel.Dispatcher.IClientMessageFormatter> or <xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter> interface, or both, for use in clients and service WCF clients, respectively.</span></span>  
  
 <span data-ttu-id="60a12-397">İleti formatları normalde davranışlara göre prize takılır.</span><span class="sxs-lookup"><span data-stu-id="60a12-397">Message formatters are normally plugged in by behaviors.</span></span> <span data-ttu-id="60a12-398">Örneğin, <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> veri sözleşmesi ileti biçimlendirici içindeki takar.</span><span class="sxs-lookup"><span data-stu-id="60a12-398">For example, the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> plugs in the data contract message formatter.</span></span> <span data-ttu-id="60a12-399">Bu, <xref:System.ServiceModel.Dispatcher.DispatchOperation.Formatter%2A> yöntemde doğru biçimlendirici olarak ayarlanarak <xref:System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.DispatchOperation%29> veya <xref:System.ServiceModel.Dispatcher.ClientOperation.Formatter%2A> metotta doğru biçimlendirici olarak ayarlanarak hizmet tarafında yapılır <xref:System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.ClientOperation%29> .</span><span class="sxs-lookup"><span data-stu-id="60a12-399">This is done on the service side by setting <xref:System.ServiceModel.Dispatcher.DispatchOperation.Formatter%2A> to the correct formatter in the <xref:System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.DispatchOperation%29> method, or on the client side by setting <xref:System.ServiceModel.Dispatcher.ClientOperation.Formatter%2A> to the correct formatter in the <xref:System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.ClientOperation%29> method.</span></span>  
  
 <span data-ttu-id="60a12-400">Aşağıdaki tablolarda, bir ileti biçimlendirici tarafından uygulayabileceğiniz yöntemler listelenmiştir.</span><span class="sxs-lookup"><span data-stu-id="60a12-400">The following tables lists the methods that a message formatter may implement.</span></span>  
  
|<span data-ttu-id="60a12-401">Arabirim</span><span class="sxs-lookup"><span data-stu-id="60a12-401">Interface</span></span>|<span data-ttu-id="60a12-402">Yöntem</span><span class="sxs-lookup"><span data-stu-id="60a12-402">Method</span></span>|<span data-ttu-id="60a12-403">Eylem</span><span class="sxs-lookup"><span data-stu-id="60a12-403">Action</span></span>|  
|---------------|------------|------------|  
|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter.DeserializeRequest%28System.ServiceModel.Channels.Message%2CSystem.Object%5B%5D%29>|<span data-ttu-id="60a12-404">Gelen `Message` işlem parametrelerine dönüştürür</span><span class="sxs-lookup"><span data-stu-id="60a12-404">Converts an incoming `Message` to operation parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter.SerializeReply%28System.ServiceModel.Channels.MessageVersion%2CSystem.Object%5B%5D%2CSystem.Object%29>|<span data-ttu-id="60a12-405">Bir giden `Message` işlem dönüş değeri/Out parametrelerini oluşturur</span><span class="sxs-lookup"><span data-stu-id="60a12-405">Creates an outgoing `Message` from operation return value/out parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter.SerializeRequest%28System.ServiceModel.Channels.MessageVersion%2CSystem.Object%5B%5D%29>|<span data-ttu-id="60a12-406">İşlem parametrelerinden giden bir giden oluşturur `Message`</span><span class="sxs-lookup"><span data-stu-id="60a12-406">Creates an outgoing `Message` from operation parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter.DeserializeReply%28System.ServiceModel.Channels.Message%2CSystem.Object%5B%5D%29>|<span data-ttu-id="60a12-407">Gelen bir `Message` dönüş değeri/Out parametrelerine dönüştürür</span><span class="sxs-lookup"><span data-stu-id="60a12-407">Converts an incoming `Message` to a return value/out parameters</span></span>|  
  
## <a name="serialization"></a><span data-ttu-id="60a12-408">Serileştirme</span><span class="sxs-lookup"><span data-stu-id="60a12-408">Serialization</span></span>  
 <span data-ttu-id="60a12-409">İleti içeriklerini betimleyen ileti sözleşmelerini veya parametrelerini her kullandığınızda .NET Framework türleri ve XML bilgi kümesi temsili arasında dönüştürme yapmak için serileştirme kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="60a12-409">Whenever you use message contracts or parameters to describe message contents, you must use serialization to convert between .NET Framework types and XML Infoset representation.</span></span> <span data-ttu-id="60a12-410">Serileştirme, WCF 'deki diğer yerlerde kullanılır, örneğin, <xref:System.ServiceModel.Channels.Message> <xref:System.ServiceModel.Channels.Message.GetBody%2A> seri durumdan çıkarılan iletinin tamamının gövdesini okumak Için kullanabileceğiniz genel bir yöntemi vardır.</span><span class="sxs-lookup"><span data-stu-id="60a12-410">Serialization is used in other places in WCF, for example, <xref:System.ServiceModel.Channels.Message> has a Generic <xref:System.ServiceModel.Channels.Message.GetBody%2A> method that you can use to read the entire body of the message deserialized into an object.</span></span>  
  
 <span data-ttu-id="60a12-411">WCF, parametreleri ve ileti parçalarını seri hale getirmek ve seri durumdan çıkarmak için "kutudan çıkar" iki serileştirme teknolojisini destekler: <xref:System.Runtime.Serialization.DataContractSerializer> ve `XmlSerializer` .</span><span class="sxs-lookup"><span data-stu-id="60a12-411">WCF supports two serialization technologies "out of the box" for serializing and deserializing parameters and message parts: the <xref:System.Runtime.Serialization.DataContractSerializer> and the `XmlSerializer`.</span></span> <span data-ttu-id="60a12-412">Ayrıca, özel serileştiriciler yazabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="60a12-412">Additionally, you can write custom serializers.</span></span> <span data-ttu-id="60a12-413">Ancak, WCF 'nin diğer bölümleri (genel `GetBody` Yöntem veya SOAP hata serileştirme gibi) yalnızca alt sınıfları kullanacak şekilde kısıtlanabilir <xref:System.Runtime.Serialization.XmlObjectSerializer> ( <xref:System.Runtime.Serialization.DataContractSerializer> ve <xref:System.Runtime.Serialization.NetDataContractSerializer> , ancak değil <xref:System.Xml.Serialization.XmlSerializer> ) ya da yalnızca ' i kullanmak için sabit kodlanmış olabilir <xref:System.Runtime.Serialization.DataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="60a12-413">However, other parts of WCF (such as the Generic `GetBody` method or SOAP fault serialization) may be restricted to use only the <xref:System.Runtime.Serialization.XmlObjectSerializer> subclasses (<xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer>, but not the <xref:System.Xml.Serialization.XmlSerializer>), or may even be hard-coded to use only the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span>  
  
 <span data-ttu-id="60a12-414">, `XmlSerializer` ASP.NET Web hizmetlerinde kullanılan serileştirme altyapısıdır.</span><span class="sxs-lookup"><span data-stu-id="60a12-414">The `XmlSerializer` is the serialization engine used in ASP.NET Web services.</span></span> <span data-ttu-id="60a12-415">, `DataContractSerializer` Yeni veri sözleşmesi programlama modelini anlayan yeni serileştirme altyapısıdır.</span><span class="sxs-lookup"><span data-stu-id="60a12-415">The `DataContractSerializer` is the new serialization engine that understands the new data contract programming model.</span></span> <span data-ttu-id="60a12-416">`DataContractSerializer`varsayılan seçenektir ve öğesini kullanma seçeneği `XmlSerializer` özniteliği kullanılarak işlem başına temelinde yapılabilir <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.DataContractFormatAttribute%2A> .</span><span class="sxs-lookup"><span data-stu-id="60a12-416">`DataContractSerializer` is the default choice, and the choice to use the `XmlSerializer` can be made on a per-operation basis using the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.DataContractFormatAttribute%2A> attribute.</span></span>  
  
 <span data-ttu-id="60a12-417"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior>ve, <xref:System.ServiceModel.Description.XmlSerializerOperationBehavior> sırasıyla ve için ileti formatlarını takmaktan sorumlu işlem davranışlardır `DataContractSerializer` `XmlSerializer` .</span><span class="sxs-lookup"><span data-stu-id="60a12-417"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> and <xref:System.ServiceModel.Description.XmlSerializerOperationBehavior> are the operation behaviors responsible for plugging in the message formatters for the `DataContractSerializer` and the `XmlSerializer`, respectively.</span></span> <span data-ttu-id="60a12-418"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior>Bu davranış <xref:System.Runtime.Serialization.XmlObjectSerializer> , <xref:System.Runtime.Serialization.NetDataContractSerializer> (tek başına serileştirme kullanma konusunda ayrıntılı olarak açıklanmıştır) dahil olmak üzere, ' den türetilen tüm serileştiricilerle çalışır.</span><span class="sxs-lookup"><span data-stu-id="60a12-418">The <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> behavior can actually operate with any serializer that derives from <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.NetDataContractSerializer> (described in detail in Using Stand-Alone Serialization).</span></span> <span data-ttu-id="60a12-419">Bu davranış, `CreateSerializer` serileştiriciyi almak için sanal yöntem aşırı yüklerinden birini çağırır.</span><span class="sxs-lookup"><span data-stu-id="60a12-419">The behavior calls one of the `CreateSerializer` virtual method overloads to obtain the serializer.</span></span> <span data-ttu-id="60a12-420">Farklı bir seri hale getirici eklemek için yeni bir <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> alt sınıf oluşturun ve her iki aşırı yüklemeyi geçersiz kılın `CreateSerializer` .</span><span class="sxs-lookup"><span data-stu-id="60a12-420">To plug in a different serializer, create a new <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> subclass and override both `CreateSerializer` overloads.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="60a12-421">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="60a12-421">See also</span></span>

- [<span data-ttu-id="60a12-422">Hizmet Anlaşmalarında Veri Aktarımını Belirtme</span><span class="sxs-lookup"><span data-stu-id="60a12-422">Specifying Data Transfer in Service Contracts</span></span>](specifying-data-transfer-in-service-contracts.md)
