---
title: Bir İleti Değişim Deseni seçin
ms.date: 03/30/2017
ms.assetid: 0f502ca1-6a8e-4607-ba15-59198c0e6146
ms.openlocfilehash: 518a21ef34d52ef4b70871ba8bad7876374dd319
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 08/22/2019
ms.locfileid: "69951856"
---
# <a name="choosing-a-message-exchange-pattern"></a><span data-ttu-id="b5156-102">Bir İleti Değişim Deseni seçin</span><span class="sxs-lookup"><span data-stu-id="b5156-102">Choosing a Message Exchange Pattern</span></span>
<span data-ttu-id="b5156-103">Özel bir aktarım yazarken ilk adım, geliştirmekte olduğunuz kanal için hangi *ileti Exchange desenlerinin* (veya MEPs) gerekli olduğuna karar vermeye yöneliktir.</span><span class="sxs-lookup"><span data-stu-id="b5156-103">The first step in writing a custom transport is to decide which *message exchange patterns* (or MEPs) are required for the channel you are developing.</span></span> <span data-ttu-id="b5156-104">Bu konu başlığı altında sunulan seçenekler açıklanmakta ve çeşitli gereksinimler ele alınmaktadır.</span><span class="sxs-lookup"><span data-stu-id="b5156-104">This topic describes the options available and discusses the various requirements.</span></span> <span data-ttu-id="b5156-105">Bu, [kanalların geliştirilmesi](../../../../docs/framework/wcf/extending/developing-channels.md)bölümünde açıklanan Kanal geliştirme görev listesindeki ilk görevdir.</span><span class="sxs-lookup"><span data-stu-id="b5156-105">This is the first task in the channel development task list described in [Developing Channels](../../../../docs/framework/wcf/extending/developing-channels.md).</span></span>  
  
## <a name="six-message-exchange-patterns"></a><span data-ttu-id="b5156-106">Altı Ileti değişimi desenleri</span><span class="sxs-lookup"><span data-stu-id="b5156-106">Six Message Exchange Patterns</span></span>  
 <span data-ttu-id="b5156-107">Aralarından seçim yapabileceğiniz üç/PS vardır:</span><span class="sxs-lookup"><span data-stu-id="b5156-107">There are three MEPs to choose from:</span></span>  
  
- <span data-ttu-id="b5156-108">Veri birimi<xref:System.ServiceModel.Channels.IInputChannel> ( <xref:System.ServiceModel.Channels.IOutputChannel>ve)</span><span class="sxs-lookup"><span data-stu-id="b5156-108">Datagram (<xref:System.ServiceModel.Channels.IInputChannel> and <xref:System.ServiceModel.Channels.IOutputChannel>)</span></span>  
  
     <span data-ttu-id="b5156-109">Bir veri birimi MEP kullanırken, istemci bir ateş kullanarak bir ileti gönderir *ve Exchange 'i unutur* .</span><span class="sxs-lookup"><span data-stu-id="b5156-109">When using a datagram MEP, a client sends a message using a *fire and forget* exchange.</span></span> <span data-ttu-id="b5156-110">Bir ateş ve unutur, başarılı teslimin bant dışı onayını gerektiren bir adım.</span><span class="sxs-lookup"><span data-stu-id="b5156-110">A fire and forget exchange is one that requires out-of-band confirmation of successful delivery.</span></span> <span data-ttu-id="b5156-111">İleti iletimde kaybolmuş olabilir ve hizmete hiçbir şekilde ulaşamamalıdır.</span><span class="sxs-lookup"><span data-stu-id="b5156-111">The message might be lost in transit and never reach the service.</span></span> <span data-ttu-id="b5156-112">Gönderme işlemi istemci sonunda başarıyla tamamlanırsa, uzak uç noktanın iletiyi aldığını garanti etmez.</span><span class="sxs-lookup"><span data-stu-id="b5156-112">If the send operation completes successfully at the client end, it does not guarantee that the remote endpoint has received the message.</span></span> <span data-ttu-id="b5156-113">Bu veri birimi, güvenilir protokoller ve güvenli protokoller de dahil olmak üzere kendi protokollerinizi oluşturabileceğiniz gibi, mesajlaşma için temel bir yapı taşıdır.</span><span class="sxs-lookup"><span data-stu-id="b5156-113">The datagram is a fundamental building block for messaging, as you can build your own protocols on top of it—including reliable protocols and secure protocols.</span></span> <span data-ttu-id="b5156-114">İstemci veri birimi kanalları arabirimini <xref:System.ServiceModel.Channels.IOutputChannel> <xref:System.ServiceModel.Channels.IInputChannel> uygulayan arabirimi ve hizmet veri birimi kanallarını uygular.</span><span class="sxs-lookup"><span data-stu-id="b5156-114">Client datagram channels implement the <xref:System.ServiceModel.Channels.IOutputChannel> interface and service datagram channels implement the <xref:System.ServiceModel.Channels.IInputChannel> interface.</span></span>  
  
- <span data-ttu-id="b5156-115">İstek-yanıt (<xref:System.ServiceModel.Channels.IRequestChannel> ve <xref:System.ServiceModel.Channels.IReplyChannel>)</span><span class="sxs-lookup"><span data-stu-id="b5156-115">Request-Response (<xref:System.ServiceModel.Channels.IRequestChannel> and <xref:System.ServiceModel.Channels.IReplyChannel>)</span></span>  
  
     <span data-ttu-id="b5156-116">Bu MEP 'de bir ileti gönderilir ve bir yanıt alındı.</span><span class="sxs-lookup"><span data-stu-id="b5156-116">In this MEP, a message is sent, and a reply is received.</span></span> <span data-ttu-id="b5156-117">Bu model, istek-yanıt çiftlerinden oluşur.</span><span class="sxs-lookup"><span data-stu-id="b5156-117">The pattern consists of request-response pairs.</span></span> <span data-ttu-id="b5156-118">İstek-yanıt çağrılarına örnek olarak uzak yordam çağrıları (RPC) ve tarayıcı GET istekleri verilebilir.</span><span class="sxs-lookup"><span data-stu-id="b5156-118">Examples of request-response calls are remote procedure calls (RPC) and browser GET requests.</span></span> <span data-ttu-id="b5156-119">Bu model, yarı çift yönlü olarak da bilinir.</span><span class="sxs-lookup"><span data-stu-id="b5156-119">This pattern is also known as half-duplex.</span></span> <span data-ttu-id="b5156-120">Bu MEP 'de, istemci kanalları <xref:System.ServiceModel.Channels.IRequestChannel> ve hizmet kanalları uygular. <xref:System.ServiceModel.Channels.IReplyChannel></span><span class="sxs-lookup"><span data-stu-id="b5156-120">In this MEP, client channels implement <xref:System.ServiceModel.Channels.IRequestChannel> and service channels implement <xref:System.ServiceModel.Channels.IReplyChannel>.</span></span>  
  
- <span data-ttu-id="b5156-121">Çift yönlü<xref:System.ServiceModel.Channels.IDuplexChannel>()</span><span class="sxs-lookup"><span data-stu-id="b5156-121">Duplex (<xref:System.ServiceModel.Channels.IDuplexChannel>)</span></span>  
  
     <span data-ttu-id="b5156-122">Çift yönlü MEP, istemci tarafından rastgele sayıda iletinin gönderilmesini ve herhangi bir sırada alınmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="b5156-122">The duplex MEP allows an arbitrary number of messages to be sent by a client and received in any order.</span></span> <span data-ttu-id="b5156-123">Çift yönlü MEP, konuşulan her sözcüğün bir ileti olduğu bir telefon konuşması gibidir.</span><span class="sxs-lookup"><span data-stu-id="b5156-123">The duplex MEP is like a phone conversation, where each word being spoken is a message.</span></span> <span data-ttu-id="b5156-124">Her iki taraf da bu MEP 'de gönderebildiğinden ve alabileceği için, istemci ve hizmet kanalları <xref:System.ServiceModel.Channels.IDuplexChannel>tarafından uygulanan arabirim.</span><span class="sxs-lookup"><span data-stu-id="b5156-124">Because both sides can send and receive in this MEP, the interface implemented by the client and service channels is <xref:System.ServiceModel.Channels.IDuplexChannel>.</span></span>  
  
 <span data-ttu-id="b5156-125">![İleti değişim modelini seçme](../../../../docs/framework/wcf/extending/media/wcfc-basicthreemepsc.gif "wcfc_BasicThreeMEPsc")</span><span class="sxs-lookup"><span data-stu-id="b5156-125">![Choosing a message exchange pattern](../../../../docs/framework/wcf/extending/media/wcfc-basicthreemepsc.gif "wcfc_BasicThreeMEPsc")</span></span>  
<span data-ttu-id="b5156-126">Üç temel ileti değişim deseni.</span><span class="sxs-lookup"><span data-stu-id="b5156-126">The three basic message exchange patterns.</span></span> <span data-ttu-id="b5156-127">Üstten alta: veri birimi, istek-yanıt ve çift yönlü.</span><span class="sxs-lookup"><span data-stu-id="b5156-127">Top to bottom: datagram, request-response, and duplex.</span></span>  
  
 <span data-ttu-id="b5156-128">Bu MEPs 'lerin her biri, *oturumları*da destekleyebilir.</span><span class="sxs-lookup"><span data-stu-id="b5156-128">Each of these MEPs can also support *sessions*.</span></span> <span data-ttu-id="b5156-129">Bir oturum (ve türünün <xref:System.ServiceModel.Channels.ISessionChannel%601?displayProperty=nameWithType> <xref:System.ServiceModel.Channels.ISession?displayProperty=nameWithType>uygulanması), bir kanalda gönderilen ve alınan tüm iletileri ilişkilendirir.</span><span class="sxs-lookup"><span data-stu-id="b5156-129">A session (and implementation of <xref:System.ServiceModel.Channels.ISessionChannel%601?displayProperty=nameWithType> of type <xref:System.ServiceModel.Channels.ISession?displayProperty=nameWithType>) correlates all messages sent and received on a channel.</span></span> <span data-ttu-id="b5156-130">İstek ve yanıt bağıntılı olduğundan, istek-yanıt deseninin tek başına iki ileti oturumu vardır.</span><span class="sxs-lookup"><span data-stu-id="b5156-130">The request-response pattern is a stand-alone two-message session, as the request and reply are correlated.</span></span> <span data-ttu-id="b5156-131">Buna karşılık, oturumları destekleyen istek-yanıt deseninin, o kanaldaki tüm istek/yanıt çiftlerinin birbirleriyle bağıntılı olduğu anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="b5156-131">In contrast, the request-response pattern that supports sessions implies that all request/response pairs on that channel are correlated with each other.</span></span> <span data-ttu-id="b5156-132">Bu, aralarından seçim yapabileceğiniz toplam altı MEPs sağlar:</span><span class="sxs-lookup"><span data-stu-id="b5156-132">This gives you a total of six MEPs to choose from:</span></span>  
  
- <span data-ttu-id="b5156-133">Inın</span><span class="sxs-lookup"><span data-stu-id="b5156-133">Datagram</span></span>  
  
- <span data-ttu-id="b5156-134">İstek-yanıt</span><span class="sxs-lookup"><span data-stu-id="b5156-134">Request-response</span></span>  
  
- <span data-ttu-id="b5156-135">Çift Yönlü</span><span class="sxs-lookup"><span data-stu-id="b5156-135">Duplex</span></span>  
  
- <span data-ttu-id="b5156-136">Oturumlarla veri birimi</span><span class="sxs-lookup"><span data-stu-id="b5156-136">Datagram with sessions</span></span>  
  
- <span data-ttu-id="b5156-137">İstek-oturumlarla yanıt</span><span class="sxs-lookup"><span data-stu-id="b5156-137">Request-response with sessions</span></span>  
  
- <span data-ttu-id="b5156-138">Oturumlarla çift yönlü</span><span class="sxs-lookup"><span data-stu-id="b5156-138">Duplex with sessions</span></span>  
  
> [!NOTE]
> <span data-ttu-id="b5156-139">UDP, doğal olarak bir yangın ve unutma Protokolü olduğundan, UDP taşıması için desteklenen tek MEP yalnızca veri birimi olur.</span><span class="sxs-lookup"><span data-stu-id="b5156-139">For the UDP transport, the only MEP that is supported is datagram, because UDP is inherently a fire and forget protocol.</span></span>  
  
## <a name="sessions-and-sessionful-channels"></a><span data-ttu-id="b5156-140">Oturumlar ve oturumsuz kanallar</span><span class="sxs-lookup"><span data-stu-id="b5156-140">Sessions and Sessionful Channels</span></span>  
 <span data-ttu-id="b5156-141">Ağ dünyasında bağlantı yönelimli protokoller (örneğin, TCP) ve bağlantı açısından daha az protokol (örneğin, UDP) vardır.</span><span class="sxs-lookup"><span data-stu-id="b5156-141">In the networking world, there are connection-oriented protocols (for example, TCP) and connection-less protocols (for example, UDP).</span></span> <span data-ttu-id="b5156-142">WCF, bağlantı benzeri bir mantıksal soyutlama için oturum terimini kullanır.</span><span class="sxs-lookup"><span data-stu-id="b5156-142">WCF uses the term session to mean a connection-like logical abstraction.</span></span> <span data-ttu-id="b5156-143">Oturumsuz WCF protokolleri, bağlantı odaklı ağ protokollerine benzerdir ve oturumsuz WCF protokolleri, bağlantı açısından daha az ağ protokollerine benzer.</span><span class="sxs-lookup"><span data-stu-id="b5156-143">Sessionful WCF protocols are similar to connection-oriented network protocols and sessionless WCF protocols are similar to connection-less network protocols.</span></span>  
  
 <span data-ttu-id="b5156-144">Kanal nesne modelinde her mantıksal oturum, bir oturum kanalının bir örneği olarak bildirimlidir.</span><span class="sxs-lookup"><span data-stu-id="b5156-144">In the channel object model, each logical session manifests as an instance of a sessionful channel.</span></span> <span data-ttu-id="b5156-145">Bu nedenle, istemci tarafından oluşturulan ve hizmette kabul edilen her yeni oturum, her bir tarafta yeni bir oturumsuz kanala karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="b5156-145">Therefore every new session created by the client, and accepted on the service, corresponds to a new sessionful channel on each side.</span></span> <span data-ttu-id="b5156-146">Aşağıdaki diyagramda, en üstteki, sessionless kanalların yapısı ve en altta, oturum kanalların yapısı gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="b5156-146">The following diagram shows, on the top, the structure of sessionless channels, and on the bottom, the structure of sessionful channels.</span></span>  
  
 <span data-ttu-id="b5156-147">![İleti değişim modelini seçme](../../../../docs/framework/wcf/extending/media/wcfc-sessionandsessionlesschannelsc.gif "wcfc_SessionAndSessionlessChannelsc")</span><span class="sxs-lookup"><span data-stu-id="b5156-147">![Choosing a message exchange pattern](../../../../docs/framework/wcf/extending/media/wcfc-sessionandsessionlesschannelsc.gif "wcfc_SessionAndSessionlessChannelsc")</span></span>  
  
 <span data-ttu-id="b5156-148">İstemci yeni bir oturumsuz kanal oluşturur ve bir ileti gönderir.</span><span class="sxs-lookup"><span data-stu-id="b5156-148">A client creates a new sessionful channel and sends a message.</span></span> <span data-ttu-id="b5156-149">Hizmet tarafında, kanal dinleyicisi bu iletiyi alır ve yeni bir oturuma ait olduğunu algılar ve yeni bir oturum kanalı oluşturur ve uygulamayı uygulamaya (kanal dinleyicisinde AcceptChannel çağıran uygulamaya yanıt olarak) sahip olur.</span><span class="sxs-lookup"><span data-stu-id="b5156-149">On the service side, the channel listener receives this message and detects that it belongs to a new session so it creates a new sessionful channel and hands it to the application (in response to the application calling AcceptChannel on the channel listener).</span></span> <span data-ttu-id="b5156-150">Daha sonra uygulama bu iletiyi ve sonraki tüm iletileri aynı oturumda, aynı oturumdaki kanal üzerinden gönderilir.</span><span class="sxs-lookup"><span data-stu-id="b5156-150">The application then receives this message and all subsequent messages sent in the same session through the same sessionful channel.</span></span>  
  
 <span data-ttu-id="b5156-151">Başka bir istemci (veya aynı istemci) yeni bir oturumsuz oluşturur ve bir ileti gönderir.</span><span class="sxs-lookup"><span data-stu-id="b5156-151">Another client (or the same client) creates a new sessionful and sends a message.</span></span> <span data-ttu-id="b5156-152">Kanal dinleyicisi, bu iletinin yeni bir oturumda olduğunu algılar ve yeni bir sessionchannel oluşturur ve işlem yinelenir.</span><span class="sxs-lookup"><span data-stu-id="b5156-152">The channel listener detects this message is in a new session and creates a new sessionful channel and the process repeats.</span></span>  
  
 <span data-ttu-id="b5156-153">Oturumlar olmadan, kanallar ve oturumlar arasında bir bağıntı yoktur.</span><span class="sxs-lookup"><span data-stu-id="b5156-153">Without sessions, there is no correlation between channels and sessions.</span></span> <span data-ttu-id="b5156-154">Bu nedenle, kanal dinleyicisi tüm alınan iletilerin uygulamaya teslim edildiği yalnızca bir kanal oluşturur.</span><span class="sxs-lookup"><span data-stu-id="b5156-154">Therefore a channel listener creates only one channel through which all received messages are delivered to the application.</span></span> <span data-ttu-id="b5156-155">İleti sıralaması, içinde ileti sırası korunacak bir oturum olmadığından da yoktur.</span><span class="sxs-lookup"><span data-stu-id="b5156-155">There is also no message ordering because there is no session within which to maintain message order.</span></span> <span data-ttu-id="b5156-156">Yukarıdaki grafiğin en üst kısmında oturumsuz ileti alışverişi gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="b5156-156">The top portion of the preceding graphic illustrates a sessionless message exchange.</span></span>  
  
## <a name="starting-and-terminating-sessions"></a><span data-ttu-id="b5156-157">Oturumları başlatma ve sonlandırma</span><span class="sxs-lookup"><span data-stu-id="b5156-157">Starting and Terminating Sessions</span></span>  
 <span data-ttu-id="b5156-158">Oturumlar yalnızca yeni bir sessionchannel oluşturularak istemci üzerinde başlatılır.</span><span class="sxs-lookup"><span data-stu-id="b5156-158">Sessions are started on the client by simply creating a new sessionful channel.</span></span> <span data-ttu-id="b5156-159">Hizmet yeni bir oturumda gönderilen bir ileti aldığında hizmette başlatılır.</span><span class="sxs-lookup"><span data-stu-id="b5156-159">They are started on the service when the service receives a message that was sent in a new session.</span></span> <span data-ttu-id="b5156-160">Benzer şekilde, oturumlar, oturumsuz bir kanalı kapatarak veya iptal ederek sonlandırılır.</span><span class="sxs-lookup"><span data-stu-id="b5156-160">Likewise, sessions are terminated by closing or aborting a sessionful channel.</span></span>  
  
 <span data-ttu-id="b5156-161">Bunun <xref:System.ServiceModel.Channels.IDuplexSessionChannel> özel durumu, çift yönlü ve oturumsuz iletişim düzeninde ileti göndermek ve almak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="b5156-161">The exception to this is <xref:System.ServiceModel.Channels.IDuplexSessionChannel> which is used for both sending and receiving messages in a duplex, sessionful communication pattern.</span></span> <span data-ttu-id="b5156-162">Bir tarafın ileti göndermeyi durdurmak, ancak ileti <xref:System.ServiceModel.Channels.IDuplexSessionChannel> almaya devam etmek, daha fazla ileti gönderemeyeceğinizi ancak giriş oturumunu kapatmayacağını belirten bir mekanizma olduğunda açıldığında, ileti almaya devam etmeniz sağlanır.</span><span class="sxs-lookup"><span data-stu-id="b5156-162">It is possible that one side will want to stop sending messages but continue to receive messages therefore when using <xref:System.ServiceModel.Channels.IDuplexSessionChannel> there is a mechanism that lets you close the output session indicating you will not send any more messages but keep the input session opened allowing you to continue to receive messages.</span></span>  
  
 <span data-ttu-id="b5156-163">Genel olarak, oturumlar giden tarafta kapatılır ve gelen tarafta değildir.</span><span class="sxs-lookup"><span data-stu-id="b5156-163">In general, sessions are closed on the outgoing side and not on the incoming side.</span></span> <span data-ttu-id="b5156-164">Diğer bir deyişle, oturumsuz çıkış kanalları kapatılabilir ve bu sayede oturumu temiz bir şekilde sonlandıralabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b5156-164">That is, sessionful output channels can be closed, thereby cleanly terminating the session.</span></span> <span data-ttu-id="b5156-165">Oturumsuz çıkış kanalının kapatılması, karşılık gelen oturum giriş kanalının, <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> <xref:System.ServiceModel.Channels.IDuplexSessionChannel>üzerinde çağıran uygulamaya null döndürmesine neden olur.</span><span class="sxs-lookup"><span data-stu-id="b5156-165">Closing a sessionful output channel causes the corresponding sessionful input channel to return null to the application calling <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel>.</span></span>  
  
 <span data-ttu-id="b5156-166">Ancak, oturumun zaten kapatıldığını belirten null değeri döndürülmediği <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> takdirde <xref:System.ServiceModel.Channels.IDuplexSessionChannel> oturumsuz giriş kanalları kapanmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="b5156-166">However sessionful input channels should not be closed unless <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel> returns null, indicating that the session is already closed.</span></span> <span data-ttu-id="b5156-167">Üzerinde null döndürülmediğinde, oturum açma işlemi sırasında beklenmeyen iletiler alabileceği için <xref:System.ServiceModel.Channels.IDuplexSessionChannel> bir oturum giriş kanalının kapatılması bir özel durum oluşturabilir. <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="b5156-167">If <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel> has not returned null, closing a sessionful input channel may throw an exception because it may receive unexpected messages while closing.</span></span> <span data-ttu-id="b5156-168">Bir alıcı, gönderen olmadan önce bir oturumu sonlandırmaya istiyorsa, oturum beklenmedik bir şekilde <xref:System.ServiceModel.ICommunicationObject.Abort%2A> sona ermeden giriş kanalını çağırmalıdır.</span><span class="sxs-lookup"><span data-stu-id="b5156-168">If a receiver wishes to terminate a session before the sender does, it should call <xref:System.ServiceModel.ICommunicationObject.Abort%2A> on the input channel, which abruptly terminates the session.</span></span>  
  
## <a name="writing-sessionful-channels"></a><span data-ttu-id="b5156-169">Oturumsuz kanallar yazma</span><span class="sxs-lookup"><span data-stu-id="b5156-169">Writing Sessionful Channels</span></span>  
 <span data-ttu-id="b5156-170">Oturumsuz kanal yazarı olarak, kanalınızın oturum sunmak için yapması gereken birkaç nokta vardır.</span><span class="sxs-lookup"><span data-stu-id="b5156-170">As a sessionful channel author, there are a few things your channel must do to provide sessions.</span></span> <span data-ttu-id="b5156-171">Gönderme tarafında, kanalınızın şunları yapması gerekir:</span><span class="sxs-lookup"><span data-stu-id="b5156-171">On the send side, your channel needs to:</span></span>  
  
- <span data-ttu-id="b5156-172">Her yeni kanal için yeni bir oturum oluşturun ve benzersiz bir dize olan yeni bir oturum kimliğiyle ilişkilendirin.</span><span class="sxs-lookup"><span data-stu-id="b5156-172">For each new channel, create a new session and associate it with a new session id which is a unique string.</span></span> <span data-ttu-id="b5156-173">Ya da, yığında aşağıda bulunan oturumsuz kanaldan yeni bir oturum elde edin.</span><span class="sxs-lookup"><span data-stu-id="b5156-173">Or obtain a new session from the sessionful channel below you in the stack.</span></span>  
  
- <span data-ttu-id="b5156-174">Bu kanalı kullanarak gönderilen her ileti için, kanalınız oturumu (sizin için aşağıdaki katmandan elde etmenin aksine) oluşturduysanız, iletiyi oturumla ilişkilendirmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="b5156-174">For each message sent using this channel, if your channel created the session (as opposed to obtaining it from the layer below you), you need to associate the message with the session.</span></span> <span data-ttu-id="b5156-175">Protokol kanalları için bu genellikle bir SOAP üst bilgisi eklenerek yapılır.</span><span class="sxs-lookup"><span data-stu-id="b5156-175">For protocol channels, this is typically done by adding a SOAP header.</span></span> <span data-ttu-id="b5156-176">Taşıma kanalları için, bu genellikle yeni bir aktarım bağlantısı oluşturularak veya çerçeveleme protokolüne oturum bilgileri eklenerek yapılır.</span><span class="sxs-lookup"><span data-stu-id="b5156-176">For transport channels, this is typically done by creating a new transport connection or adding session information to the framing protocol.</span></span>  
  
- <span data-ttu-id="b5156-177">Bu kanalı kullanarak gönderilen her ileti için yukarıda bahsedilen teslim garantisi sağlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="b5156-177">For each message sent using this channel, you need to provide the delivery guarantees mentioned above.</span></span> <span data-ttu-id="b5156-178">Oturumu sağlamanız için aşağıdaki kanala sahipseniz, bu kanal teslim garantisi verir.</span><span class="sxs-lookup"><span data-stu-id="b5156-178">If you are relying on the channel below you to provide the session, that channel will also provide the delivery guarantees.</span></span> <span data-ttu-id="b5156-179">Oturumu kendiniz sağladıysanız, bu garantiyi protokolizin kapsamında uygulamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="b5156-179">If you’re providing the session yourself, you need to implement those guarantees as part of your protocol.</span></span> <span data-ttu-id="b5156-180">Genel olarak, her iki tarafta WCF 'yi kabul eden bir protokol kanalı yazıyorsanız, TCP aktarımı veya güvenilir mesajlaşma kanalı gerektirebilir ve bir oturum sağlamak için bunlardan birini kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b5156-180">In general, if you are writing a protocol channel that assumes WCF on both sides you may require the TCP transport or the Reliable Messaging channel and rely on either one to provide a session.</span></span>  
  
- <span data-ttu-id="b5156-181"><xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> Kanalınıza çağrıldığında, belirtilen zaman aşımını veya varsayılan olanı kullanarak oturumu kapatmak için gerekli işleri gerçekleştirin.</span><span class="sxs-lookup"><span data-stu-id="b5156-181">When <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> is called on your channel, perform the necessary work to close the session using either the specified timeout or the default one.</span></span> <span data-ttu-id="b5156-182">Bu, aşağıdaki kanala çağrı <xref:System.ServiceModel.ICommunicationObject.Close%2A> yapmak kadar kolay olabilir (oturumu bundan önce edindiyseniz) veya özel bir soap iletisi gönderiyor veya bir aktarım bağlantısını kapatıyor.</span><span class="sxs-lookup"><span data-stu-id="b5156-182">This can be as simple as calling <xref:System.ServiceModel.ICommunicationObject.Close%2A> on the channel below you (if you just obtained the session from it) or sending a special SOAP message or closing a transport connection.</span></span>  
  
- <span data-ttu-id="b5156-183"><xref:System.ServiceModel.ICommunicationObject.Abort%2A> Kanalınıza çağrıldığında, g/ç yapmadan oturumu aniden sonlandırın.</span><span class="sxs-lookup"><span data-stu-id="b5156-183">When <xref:System.ServiceModel.ICommunicationObject.Abort%2A> is called on your channel, terminate the session abruptly without performing I/O.</span></span> <span data-ttu-id="b5156-184">Bu, herhangi bir şey yapmanın veya bir ağ bağlantısının ya da başka bir kaynağın iptal edilme olabileceği anlamına gelebilir.</span><span class="sxs-lookup"><span data-stu-id="b5156-184">This may mean doing nothing or may involve aborting a network connection or some other resource.</span></span>  
  
 <span data-ttu-id="b5156-185">Alma tarafında, kanalınızın şunları yapması gerekir:</span><span class="sxs-lookup"><span data-stu-id="b5156-185">On the receive side, your channel needs to:</span></span>  
  
- <span data-ttu-id="b5156-186">Her gelen ileti için kanal dinleyicisi ait olduğu oturumu algılamamalıdır.</span><span class="sxs-lookup"><span data-stu-id="b5156-186">For each incoming message, the channel listener must detect the session it belongs to.</span></span> <span data-ttu-id="b5156-187">Bu, oturumdaki ilk iletidir, kanal dinleyicisi yeni bir kanal oluşturmalı ve çağrısından <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A?displayProperty=nameWithType>döndürmelidir.</span><span class="sxs-lookup"><span data-stu-id="b5156-187">If this is the first message in the session, the channel listener must create a new channel and return it from the call to <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b5156-188">Aksi halde kanal dinleyicisi, oturuma karşılık gelen mevcut kanalı bulmalıdır ve iletiyi bu kanal üzerinden teslim eder.</span><span class="sxs-lookup"><span data-stu-id="b5156-188">Otherwise the channel listener must find the existing channel that corresponds to the session and deliver the message through that channel.</span></span>  
  
- <span data-ttu-id="b5156-189">Kanalınızın oturumu sağlaması varsa (gerekli teslimat garantisi ile birlikte), iletileri yeniden sıralama veya bildirimleri gönderme gibi bazı eylemler gerçekleştirmek için alma tarafı gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="b5156-189">If your channel is providing the session (along with the required delivery guarantees) the receive side may be required to perform some actions such as re-order messages or send acknowledgements.</span></span>  
  
- <span data-ttu-id="b5156-190">Kanalınıza çağrıldığında, belirtilen zaman aşımı ya da varsayılan değer olanoturumukapatmakiçingerekliişlerigerçekleştirin.<xref:System.ServiceModel.ICommunicationObject.Close%2A></span><span class="sxs-lookup"><span data-stu-id="b5156-190">When <xref:System.ServiceModel.ICommunicationObject.Close%2A> is called on your channel, perform the necessary work to close the session either the specified timeout or the default one.</span></span> <span data-ttu-id="b5156-191">Bu, kanal bir ileti alırsa, kapatma zaman aşımının süresinin dolacağını beklerken özel durumlara neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="b5156-191">This could result in exceptions if the channel receives a message while waiting for the close timeout to expire.</span></span> <span data-ttu-id="b5156-192">Bunun nedeni, kanalın, oluşturması için bir ileti aldığında kapanış durumunda olacağı durumdur.</span><span class="sxs-lookup"><span data-stu-id="b5156-192">That’s because the channel will be in the Closing state when it receives a message so it would throw.</span></span>  
  
- <span data-ttu-id="b5156-193"><xref:System.ServiceModel.ICommunicationObject.Abort%2A> Kanalınıza çağrıldığında, g/ç yapmadan oturumu aniden sonlandırın.</span><span class="sxs-lookup"><span data-stu-id="b5156-193">When <xref:System.ServiceModel.ICommunicationObject.Abort%2A> is called on your channel, terminate the session abruptly without performing I/O.</span></span> <span data-ttu-id="b5156-194">Bu durum, bir ağ bağlantısını veya başka bir kaynağı iptal edebilir veya herhangi bir şey yapmanız anlamına gelebilir.</span><span class="sxs-lookup"><span data-stu-id="b5156-194">Again, this may mean doing nothing or may involve aborting a network connection or some other resource.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b5156-195">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="b5156-195">See also</span></span>

- [<span data-ttu-id="b5156-196">Kanal Modeline Genel Bakış</span><span class="sxs-lookup"><span data-stu-id="b5156-196">Channel Model Overview</span></span>](../../../../docs/framework/wcf/extending/channel-model-overview.md)
