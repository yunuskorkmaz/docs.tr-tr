---
title: Hizmet Sürümü Oluşturma
ms.date: 03/30/2017
ms.assetid: 37575ead-d820-4a67-8059-da11a2ab48e2
ms.openlocfilehash: 75a19c62f52c1d9468976f7ebea72245d1d341eb
ms.sourcegitcommit: 15109844229ade1c6449f48f3834db1b26907824
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 05/07/2018
ms.locfileid: "33809696"
---
# <a name="service-versioning"></a><span data-ttu-id="dc9c3-102">Hizmet Sürümü Oluşturma</span><span class="sxs-lookup"><span data-stu-id="dc9c3-102">Service Versioning</span></span>
<span data-ttu-id="dc9c3-103">İlk dağıtım ve olası birkaç kez kendi ömürleri sırasında sonra Hizmetleri (ve bunların kullanıma uç noktaları) çeşitli değişen işletme gereksinimlerine göre bilgi teknolojisi gereksinimleri gibi nedenlerle, değiştirilecek veya diğer gidermenin gerekebilir sorunları.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-103">After initial deployment, and potentially several times during their lifetime, services (and the endpoints they expose) may need to be changed for a variety of reasons, such as changing business needs, information technology requirements, or to address other issues.</span></span> <span data-ttu-id="dc9c3-104">Her değişiklik hizmeti yeni bir sürümünü kullanıma sunmaktadır.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-104">Each change introduces a new version of the service.</span></span> <span data-ttu-id="dc9c3-105">Bu konu, Windows Communication Foundation (WCF) sürüm göz önünde bulundurun açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-105">This topic explains how to consider versioning in Windows Communication Foundation (WCF).</span></span>  
  
## <a name="four-categories-of-service-changes"></a><span data-ttu-id="dc9c3-106">Hizmet değişikliklerini dört kategorisi</span><span class="sxs-lookup"><span data-stu-id="dc9c3-106">Four Categories of Service Changes</span></span>  
 <span data-ttu-id="dc9c3-107">Gerekli hizmetler değişiklikleri dört kategoriye sınıflandırılabilir:</span><span class="sxs-lookup"><span data-stu-id="dc9c3-107">The changes to services that may be required can be classified into four categories:</span></span>  
  
-   <span data-ttu-id="dc9c3-108">Sözleşme değişiklikleri: Örneğin, bir işlem eklenebilir veya bir veri öğesi iletide eklenen veya değiştirilen.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-108">Contract changes: For example, an operation might be added, or a data element in a message might be added or changed.</span></span>  
  
-   <span data-ttu-id="dc9c3-109">Adres değişiklikleri: Örneğin, bir hizmet uç noktaları yeni adresleri olduğu farklı bir konuma taşır.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-109">Address changes: For example, a service moves to a different location where endpoints have new addresses.</span></span>  
  
-   <span data-ttu-id="dc9c3-110">Değişiklikleri bağlama: Örneğin, bir güvenlik mekanizması değiştirir veya ayarlarını değiştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-110">Binding changes: For example, a security mechanism changes or its settings change.</span></span>  
  
-   <span data-ttu-id="dc9c3-111">Uygulama değişiklikleri: Örneğin, bir iç yöntem uygulaması değiştiğinde.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-111">Implementation changes: For example, when an internal method implementation changes.</span></span>  
  
 <span data-ttu-id="dc9c3-112">Bu değişikliklerden bazıları "sonu" olarak adlandırılır ve diğerleri "bölünemez."</span><span class="sxs-lookup"><span data-stu-id="dc9c3-112">Some of these changes are called "breaking" and others are "nonbreaking."</span></span> <span data-ttu-id="dc9c3-113">Bir değişiklik *bölünemez* başarıyla yeni sürümde işlenen başarılı bir şekilde bir önceki sürümde işlenen tüm iletileri.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-113">A change is *nonbreaking* if all messages that would have been processed successfully in the previous version are processed successfully in the new version.</span></span> <span data-ttu-id="dc9c3-114">Bu ölçütü karşılamayan herhangi bir değişiklik olup bir *sonu* değiştirin.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-114">Any change that does not meet that criterion is a *breaking* change.</span></span>  
  
## <a name="service-orientation-and-versioning"></a><span data-ttu-id="dc9c3-115">Hizmet yönlendirmesi ve sürüm oluşturma</span><span class="sxs-lookup"><span data-stu-id="dc9c3-115">Service Orientation and Versioning</span></span>  
 <span data-ttu-id="dc9c3-116">Hizmet yönlendirmesi tenets hizmetler ve istemcileri otonom (veya bağımsız) biridir.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-116">One of the tenets of service orientation is that services and clients are autonomous (or independent).</span></span> <span data-ttu-id="dc9c3-117">Bunun yanı sıra, bu hizmet geliştiricileri denetlemek veya hatta tüm hizmeti istemcileri hakkında bilmeniz varsayın olamaz anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-117">Among other things, this implies that service developers cannot assume that they control or even know about all service clients.</span></span> <span data-ttu-id="dc9c3-118">Bu, yeniden oluşturma ve tüm istemcilere hizmet değişiklikleri sürümleri zaman dağıtarak seçeneğinin ortadan kaldırır.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-118">This eliminates the option of rebuilding and redeploying all clients when a service changes versions.</span></span> <span data-ttu-id="dc9c3-119">Bu konu, hizmet için bu tenet aynılarını ve bu nedenle, istemcileri değiştirilmiş veya "sürümlü" bağımsız olmalıdır varsayar.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-119">This topic assumes the service adheres to this tenet and therefore must be changed or "versioned" independent of its clients.</span></span>  
  
 <span data-ttu-id="dc9c3-120">Önemli bir değişiklik, beklenmeyen bir durumdur ve kaçınılmaz olduğu durumlarda, bir uygulama bu tenet yoksay ve istemcilerin yeniden ve hizmetin yeni bir sürümü ile imzalanmasını gerektirir seçebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-120">In cases where a breaking change is unexpected and cannot be avoided, an application may choose to ignore this tenet and require that clients be rebuilt and redeployed with a new version of the service.</span></span>  
  
## <a name="contract-versioning"></a><span data-ttu-id="dc9c3-121">Sözleşmesi sürümü oluşturma</span><span class="sxs-lookup"><span data-stu-id="dc9c3-121">Contract Versioning</span></span>  
 <span data-ttu-id="dc9c3-122">Bir istemci tarafından kullanılan sözleşmeleri hizmeti tarafından kullanılan sözleşme ile aynı olması gerekmez; yalnızca uyumlu olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-122">Contracts used by a client do not need to be the same as the contract used by the service; they need only to be compatible.</span></span>  
  
 <span data-ttu-id="dc9c3-123">Hizmet sözleşmeleri için Uyumluluk anlamına gelir yeni işlem hizmeti tarafından sunulan eklenebilir, ancak mevcut işlemleri kaldırılamıyor veya anlamsal olarak değiştirildi.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-123">For service contracts, compatibility means new operations exposed by the service can be added but existing operations cannot be removed or changed semantically.</span></span>  
  
 <span data-ttu-id="dc9c3-124">Veri sözleşmeleri için Uyumluluk tanımları eklenen yeni şema türü anlamına gelir ancak yolları bölme varolan şema türü tanımları değiştirilemez.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-124">For data contracts, compatibility means new schema type definitions can be added but existing schema type definitions cannot be changed in breaking ways.</span></span> <span data-ttu-id="dc9c3-125">Yeni değişiklikler veri üyeleri kaldırma veya kendi veri türü incompatibly değiştirme içerebilir.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-125">Breaking changes might include removing data members or changing their data type incompatibly.</span></span> <span data-ttu-id="dc9c3-126">Bu özellik, istemcilerin bozmadan kendi sözleşmeleri sürümü değiştirmede bazı enlem hizmet sağlar.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-126">This feature allows the service some latitude in changing the version of its contracts without breaking clients.</span></span> <span data-ttu-id="dc9c3-127">Sonraki iki bölümde WCF verilerde yapılan ve sözleşmeleri hizmet bölünemez ve yeni değişiklikler açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-127">The next two sections explain nonbreaking and breaking changes that can be made to WCF data and service contracts.</span></span>  
  
## <a name="data-contract-versioning"></a><span data-ttu-id="dc9c3-128">Veri Sözleşmesi Sürümü Oluşturma</span><span class="sxs-lookup"><span data-stu-id="dc9c3-128">Data Contract Versioning</span></span>  
 <span data-ttu-id="dc9c3-129">Bu bölüm veri sürüm oluşturma kullanırken ilgilenir <xref:System.Runtime.Serialization.DataContractSerializer> ve <xref:System.Runtime.Serialization.DataContractAttribute> sınıfları.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-129">This section deals with data versioning when using the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.DataContractAttribute> classes.</span></span>  
  
### <a name="strict-versioning"></a><span data-ttu-id="dc9c3-130">Katı sürüm oluşturma</span><span class="sxs-lookup"><span data-stu-id="dc9c3-130">Strict Versioning</span></span>  
 <span data-ttu-id="dc9c3-131">Çoğu senaryoda sürümleri değiştirme bir sorun olduğunda service Geliştirici istemciler üzerinde denetim sahibi değildir ve bu nedenle nasıl bunlar ileti XML veya şema değişiklikleri tepki hakkında varsayımlar yapamazsınız.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-131">In many scenarios when changing versions is an issue, the service developer does not have control over the clients and therefore cannot make assumptions about how they would react to changes in the message XML or schema.</span></span> <span data-ttu-id="dc9c3-132">Bu durumlarda, yeni iletiler iki nedenden dolayı eski şemasına göre doğrulayacak etmeleri gerekir:</span><span class="sxs-lookup"><span data-stu-id="dc9c3-132">In these cases, you must guarantee that the new messages will validate against the old schema, for two reasons:</span></span>  
  
-   <span data-ttu-id="dc9c3-133">Eski istemciler şema değişmez varsayımına ile geliştirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-133">The old clients were developed with the assumption that the schema will not change.</span></span> <span data-ttu-id="dc9c3-134">Bunlar hiçbir zaman için tasarlanmış iletileri işlemek başarısız.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-134">They may fail to process messages that they were never designed for.</span></span>  
  
-   <span data-ttu-id="dc9c3-135">Eski istemciler iletileri işlemek bile denemeden önce eski şemasına karşılık gerçek şema doğrulamasını gerçekleştirebilir.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-135">The old clients may perform actual schema validation against the old schema before even attempting to process the messages.</span></span>  
  
 <span data-ttu-id="dc9c3-136">Önerilen senaryolarda adları mevcut veri sözleşmeleri değişmez olarak kabul eder ve benzersiz XML ile yeni bir tane oluşturmak için tam bir yaklaşımdır.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-136">The recommended approach in such scenarios is to treat existing data contracts as immutable and create new ones with unique XML qualified names.</span></span> <span data-ttu-id="dc9c3-137">Hizmet Geliştirici ardından var olan bir hizmet sözleşmeyi yeni yöntemleri ekleyin ya da yeni bir hizmet sözleşmesi yeni veri sözleşmesi kullanan yöntemleri ile oluşturun.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-137">The service developer would then either add new methods to an existing service contract or create a new service contract with methods that use the new data contract.</span></span>  
  
 <span data-ttu-id="dc9c3-138">Bu genellikle bir veri sözleşmesi yanı sıra her bir veri sözleşmesi sürümü için sürüme özgü iş kodu tüm sürümleri içinde çalışması gereken bazı iş mantığı yazmak için bir hizmet geliştiricinin ihtiyacı durumda olacaktır.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-138">It will often be the case that a service developer needs to write some business logic that should run within all versions of a data contract plus version-specific business code for each version of the data contract.</span></span> <span data-ttu-id="dc9c3-139">Bu konunun sonundaki ek arabirimleri bu gereksinimi karşılamak için nasıl kullanılabileceği açıklanır.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-139">The appendix at the end of this topic explains how interfaces can be used to satisfy this need.</span></span>  
  
### <a name="lax-versioning"></a><span data-ttu-id="dc9c3-140">Belirsiz sürüm oluşturma</span><span class="sxs-lookup"><span data-stu-id="dc9c3-140">Lax Versioning</span></span>  
 <span data-ttu-id="dc9c3-141">Birçok diğer senaryolarda, hizmet geliştirici, yeni, isteğe bağlı bir üye veri sözleşmesi ekleme mevcut istemcilerin sonu olmayan varsayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-141">In many other scenarios, the service developer can make the assumption that adding a new, optional member to the data contract will not break existing clients.</span></span> <span data-ttu-id="dc9c3-142">Bu, mevcut istemciler şema doğrulaması gerçekleştirmiyorsanız olup araştırmak Hizmet Geliştirici gerektirir ve bilinmeyen veri üyelerini yoksay.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-142">This requires the service developer to investigate whether existing clients are not performing schema validation and that they ignore unknown data members.</span></span> <span data-ttu-id="dc9c3-143">Bu senaryolarda, bölünemez şekilde yeni üye eklemek için veri sözleşmesi özelliklerden yararlanmak mümkündür.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-143">In these scenarios, it is possible to take advantage of data contract features for adding new members in a nonbreaking way.</span></span> <span data-ttu-id="dc9c3-144">Sürüm oluşturma için veri sözleşmesi özellikleri zaten hizmet ilk sürüm için kullanıldıysa service geliştirici bu güvenle varsayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-144">The service developer can make this assumption with confidence if the data contract features for versioning were already used for the first version of the service.</span></span>  
  
 <span data-ttu-id="dc9c3-145">WCF, ASP.NET Web Hizmetleri ve diğer birçok Web hizmeti yığınları desteği *belirsiz sürüm*: başka bir deyişle, bunlar yeni bilinmeyen veri üyeleri için özel durumlar alınan verileri oluşturmayın.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-145">WCF, ASP.NET Web Services, and many other Web service stacks support *lax versioning*: that is, they do not throw exceptions for new unknown data members in received data.</span></span>  
  
 <span data-ttu-id="dc9c3-146">Yeni bir üye ekleme mevcut istemcilerin kesintiye uğrar değil, yanlışlıkla düşünüyorsanız kolaydır.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-146">It is easy to mistakenly believe that adding a new member will not break existing clients.</span></span> <span data-ttu-id="dc9c3-147">Tüm istemcilerin belirsiz sürüm işleyebilir, katı sürüm oluşturma yönergelerini kullanın ve veri önerilir değilseniz olarak değişmez sözleşme.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-147">If you are unsure that all clients can handle lax versioning, the recommendation is to use the strict versioning guidelines and treat data contracts as immutable.</span></span>  
  
 <span data-ttu-id="dc9c3-148">Veri sözleşmeleri belirsiz ve katı sürüm oluşturma için ayrıntılı yönergeler için bkz: [en iyi uygulamalar: veri sözleşmesi sürümü oluşturma](../../../docs/framework/wcf/best-practices-data-contract-versioning.md).</span><span class="sxs-lookup"><span data-stu-id="dc9c3-148">For detailed guidelines for both lax and strict versioning of data contracts, see [Best Practices: Data Contract Versioning](../../../docs/framework/wcf/best-practices-data-contract-versioning.md).</span></span>  
  
### <a name="distinguishing-between-data-contract-and-net-types"></a><span data-ttu-id="dc9c3-149">Veri sözleşmesi ve .NET türleri arasında ayrım</span><span class="sxs-lookup"><span data-stu-id="dc9c3-149">Distinguishing Between Data Contract and .NET Types</span></span>  
 <span data-ttu-id="dc9c3-150">.NET sınıf veya yapı bir veri sözleşmesi uygulayarak izlenebilir <xref:System.Runtime.Serialization.DataContractAttribute> öznitelik sınıfı.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-150">A .NET class or structure can be projected as a data contract by applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to the class.</span></span> <span data-ttu-id="dc9c3-151">.NET türü ve kendi veri sözleşmesi tahminleri iki ayrı önemlidir markalarıdır.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-151">The .NET type and its data contract projections are two distinct matters.</span></span> <span data-ttu-id="dc9c3-152">Aynı veri sözleşmesi projeksiyon birden çok .NET tür olması mümkündür.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-152">It is possible to have multiple .NET types with the same data contract projection.</span></span> <span data-ttu-id="dc9c3-153">Bu ayrım .NET türü böylece bile Word katı algılama mevcut istemcilerin uyumluluğunu koruma tahmini veri sözleşmesi korurken değiştirmenize olanak tanır özellikle yararlı olur.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-153">This distinction is especially useful in allowing you to change the .NET type while maintaining the projected data contract, thereby maintaining compatibility with existing clients even in the strict sense of the word.</span></span> <span data-ttu-id="dc9c3-154">Bu ayrım .NET türü ve veri sözleşmesi arasındaki korumak için her zaman yapmanız gereken iki şey vardır:</span><span class="sxs-lookup"><span data-stu-id="dc9c3-154">There are two things you should always do to maintain this distinction between .NET type and data contract:</span></span>  
  
-   <span data-ttu-id="dc9c3-155">Belirtin bir <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> ve <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-155">Specify a <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> and <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>.</span></span> <span data-ttu-id="dc9c3-156">Her zaman adını ve ad alanı .NET türünün adı önlemek için veri sözleşmesi olarak açık hale gelen ad belirtmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-156">You should always specify the name and namespace of your data contract to prevent your .NET type’s name and namespace from being exposed in the contract.</span></span> <span data-ttu-id="dc9c3-157">Daha sonra .NET ad alanı değiştirme veya adı yazın karar verirseniz, bu şekilde, veri sözleşmesi aynı kalır.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-157">This way, if you decide later to change the .NET namespace or type name, your data contract remains the same.</span></span>  
  
-   <span data-ttu-id="dc9c3-158">Belirtin <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A>.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-158">Specify <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A>.</span></span> <span data-ttu-id="dc9c3-159">Her zaman .NET üye adı olarak gösterilen önlemek için veri üyelerinin adını belirtmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-159">You should always specify the name of your data members to prevent your .NET member name from being exposed in the contract.</span></span> <span data-ttu-id="dc9c3-160">Daha sonra üye .NET adını değiştirmeye karar verirseniz, bu şekilde, veri sözleşmesi aynı kalır.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-160">This way, if you decide later to change the .NET name of the member, your data contract remains the same.</span></span>  
  
### <a name="changing-or-removing-members"></a><span data-ttu-id="dc9c3-161">Değiştirme veya üyeleri kaldırma</span><span class="sxs-lookup"><span data-stu-id="dc9c3-161">Changing or Removing Members</span></span>  
 <span data-ttu-id="dc9c3-162">Belirsiz sürüm izin üye adı veya veri türünü değiştirme veya veri üyeleri kaldırma önemli bir değişiklik olsa dahi.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-162">Changing the name or data type of a member, or removing data members is a breaking change even if lax versioning is allowed.</span></span> <span data-ttu-id="dc9c3-163">Bu gerekli ise, yeni bir veri sözleşmesi oluşturun.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-163">If this is necessary, create a new data contract.</span></span>  
  
 <span data-ttu-id="dc9c3-164">Hizmet uyumluluk yüksek önem düzeyi ise kullanılmayan veri üyeleri kodunuzda yoksayılıyor göz önünde bulundurun ve yerinde bırakın.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-164">If service compatibility is of high importance, you might consider ignoring unused data members in your code and leave them in place.</span></span> <span data-ttu-id="dc9c3-165">Bir veri üyesi birden çok üye içine yukarı bölme, varolan bir üye yerinde bir özellik olarak, gerekli bölme ve yeniden toplama alt düzey istemciler (en son sürüme yükseltilmemiş istemciler) için gerçekleştirilebilmesidir düşünebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-165">If you are splitting up a data member into multiple members, you might consider leaving the existing member in place as a property that can perform the required splitting and re-aggregation for down-level clients (clients that are not upgraded to the latest version).</span></span>  
  
 <span data-ttu-id="dc9c3-166">Benzer şekilde, veri sözleşmenin adı veya ad alanı değişiklikleri değişiklikleri ayırırsınız.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-166">Similarly, changes to the data contract’s name or namespace are breaking changes.</span></span>  
  
### <a name="round-trips-of-unknown-data"></a><span data-ttu-id="dc9c3-167">Gidiş dönüş bilinmeyen veri</span><span class="sxs-lookup"><span data-stu-id="dc9c3-167">Round-Trips of Unknown Data</span></span>  
 <span data-ttu-id="dc9c3-168">Bazı senaryolarda, yeni sürümde eklenen üyeler geldiği "gidiş dönüş" Bilinmeyen veri gerek yoktur.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-168">In some scenarios, there is a need to "round-trip" unknown data that comes from members added in a new version.</span></span> <span data-ttu-id="dc9c3-169">Örneğin, "versionNew" hizmeti bazı verilerle üyeleri "versionOld" istemcisi için yeni eklenen gönderir.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-169">For example, a "versionNew" service sends data with some newly added members to a "versionOld" client.</span></span> <span data-ttu-id="dc9c3-170">İleti işleme sırasında istemci yeni eklenen üyeler yoksayar, ancak geri versionNew hizmetine yeni eklenen üyeleri de dahil olmak üzere bu aynı verileri yeniden gönderir.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-170">The client ignores the newly added members when processing the message, but it resends that same data, including the newly added members, back to the versionNew service.</span></span> <span data-ttu-id="dc9c3-171">Tipik senaryo burada veri hizmetinden alınan, değiştirilen ve döndürülen veri güncelleştirmesidir.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-171">The typical scenario for this is data updates where data is retrieved from the service, changed, and returned.</span></span>  
  
 <span data-ttu-id="dc9c3-172">Belirli bir tür için gidiş etkinleştirmek için türü uygulamalıdır <xref:System.Runtime.Serialization.IExtensibleDataObject> arabirimi.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-172">To enable round-tripping for a particular type, the type must implement the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="dc9c3-173">Bir özellik arabirimi içerir <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> döndüren <xref:System.Runtime.Serialization.ExtensionDataObject> türü.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-173">The interface contains one property, <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> that returns the <xref:System.Runtime.Serialization.ExtensionDataObject> type.</span></span> <span data-ttu-id="dc9c3-174">Özelliği için geçerli sürümü bilinmiyor veri sözleşmesi gelecek sürümlerinden herhangi bir veriyi depolamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-174">The property is used to store any data from future versions of the data contract that is unknown to the current version.</span></span> <span data-ttu-id="dc9c3-175">Bu veriler opak istemciye, ancak örnek serileştirildiğinde, içeriği <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> özelliği, veri sözleşmesi üyeleri veri geri kalanı ile yazılır.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-175">This data is opaque to the client, but when the instance is serialized, the content of the <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> property is written with the rest of the data contract members' data.</span></span>  
  
 <span data-ttu-id="dc9c3-176">Tüm türleri yeni ve bilinmeyen gelecekteki üyeleri uyum sağlamak için bu arabirimi uygulayan önerilir.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-176">It is recommended that all your types implement this interface to accommodate new and unknown future members.</span></span>  
  
### <a name="data-contract-libraries"></a><span data-ttu-id="dc9c3-177">Veri sözleşmesi kitaplıkları</span><span class="sxs-lookup"><span data-stu-id="dc9c3-177">Data Contract Libraries</span></span>  
 <span data-ttu-id="dc9c3-178">Burada bir sözleşme merkezi bir depoya yayımlanır ve hizmeti ve türü Implementers uygulamak ve bu depodan veri sözleşmeleri kullanıma veri sözleşmeleri kitaplıklarının olabilir.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-178">There may be libraries of data contracts where a contract is published to a central repository, and service and type implementers implement and expose data contracts from that repository.</span></span> <span data-ttu-id="dc9c3-179">Bu durumda, bir veri sözleşmesi depoya yayımladığınızda, kimin uyguladıktan türleri oluşturur üzerinde denetiminiz yoktur.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-179">In that case, when you publish a data contract to the repository, you have no control over who creates types that implement it.</span></span> <span data-ttu-id="dc9c3-180">Bu nedenle, yayımlandıktan sonra etkili bir şekilde değişmez işleme sözleşme değiştiremezsiniz.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-180">Thus, you cannot modify the contract once it is published, rendering it effectively immutable.</span></span>  
  
### <a name="when-using-the-xmlserializer"></a><span data-ttu-id="dc9c3-181">XmlSerializer kullanırken</span><span class="sxs-lookup"><span data-stu-id="dc9c3-181">When Using the XmlSerializer</span></span>  
 <span data-ttu-id="dc9c3-182">Aynı sürüm oluşturma ilkeleri kullanırken geçerlidir <xref:System.Xml.Serialization.XmlSerializer> sınıfı.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-182">The same versioning principles apply when using the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="dc9c3-183">Katı sürüm gerekli olduğunda, veri sözleşmeleri değişmez olarak kabul eder ve yeni sürümler için benzersiz, tam adlarıyla yeni veri sözleşmeleri oluşturun.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-183">When strict versioning is required, treat data contracts as immutable and create new data contracts with unique, qualified names for the new versions.</span></span> <span data-ttu-id="dc9c3-184">Ne zaman belirsiz sürüm kullanılabilir, yeni sürümlerde yeni seri hale getirilebilir üye ekleyebilir eminseniz ancak değiştirme veya var olan üyeleri kaldırın.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-184">When you are sure that lax versioning can be used, you can add new serializable members in new versions but not change or remove existing members.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dc9c3-185"><xref:System.Xml.Serialization.XmlSerializer> Kullanan <xref:System.Xml.Serialization.XmlAnyElementAttribute> ve <xref:System.Xml.Serialization.XmlAnyAttributeAttribute> bilinmeyen veri gidiş desteklemek için öznitelikler.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-185">The <xref:System.Xml.Serialization.XmlSerializer> uses the <xref:System.Xml.Serialization.XmlAnyElementAttribute> and <xref:System.Xml.Serialization.XmlAnyAttributeAttribute> attributes to support round-tripping of unknown data.</span></span>  
  
## <a name="message-contract-versioning"></a><span data-ttu-id="dc9c3-186">İleti sözleşmesi sürümü oluşturma</span><span class="sxs-lookup"><span data-stu-id="dc9c3-186">Message Contract Versioning</span></span>  
 <span data-ttu-id="dc9c3-187">İleti sözleşmesi sürümü oluşturma için yönergeler sürüm veri sözleşmelerine çok benzer.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-187">The guidelines for message contract versioning are very similar to versioning data contracts.</span></span> <span data-ttu-id="dc9c3-188">Katı sürüm gerekiyorsa, ileti gövdesi değiştirilmemesi ancak bunun yerine benzersiz bir tam adı ile yeni bir ileti sözleşmesi oluşturun.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-188">If strict versioning is required, you should not change your message body but instead create a new message contract with a unique qualified name.</span></span> <span data-ttu-id="dc9c3-189">Belirsiz sürüm kullanabileceğiniz biliyorsanız, yeni ileti gövdesi bölümleri ekleyebilir ancak değil değiştirmek veya var olanları kaldırın.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-189">If you know that you can use lax versioning, you can add new message body parts but not change or remove existing ones.</span></span> <span data-ttu-id="dc9c3-190">Bu kılavuz, hem tam uygular ve ileti sözleşmeleri Sarmalanan.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-190">This guidance applies both to bare and wrapped message contracts.</span></span>  
  
 <span data-ttu-id="dc9c3-191">İleti üstbilgilerini, her zaman katı sürüm kullanımda olsa bile eklenebilir.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-191">Message headers can always be added, even if strict versioning is in use.</span></span> <span data-ttu-id="dc9c3-192">MustUnderstand bayrağı sürüm etkileyebilir.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-192">The MustUnderstand flag may affect versioning.</span></span> <span data-ttu-id="dc9c3-193">Genel olarak, sürüm oluşturma için WCF üstbilgilerinde SOAP belirtimi içinde açıklandığı gibi modelidir.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-193">In general, the versioning model for headers in WCF is as described in the SOAP specification.</span></span>  
  
## <a name="service-contract-versioning"></a><span data-ttu-id="dc9c3-194">Hizmet sözleşmesi sürümü oluşturma</span><span class="sxs-lookup"><span data-stu-id="dc9c3-194">Service Contract Versioning</span></span>  
 <span data-ttu-id="dc9c3-195">Benzer şekilde veri sözleşmesi sürümü oluşturma, hizmet sözleşmesi sürümü oluşturma da ekleme, değiştirme ve kaldırma işlemlerini içerir.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-195">Similar to data contract versioning, service contract versioning also involves adding, changing, and removing operations.</span></span>  
  
### <a name="specifying-name-namespace-and-action"></a><span data-ttu-id="dc9c3-196">Ad, Namespace ve eylem belirtme</span><span class="sxs-lookup"><span data-stu-id="dc9c3-196">Specifying Name, Namespace, and Action</span></span>  
 <span data-ttu-id="dc9c3-197">Varsayılan olarak, hizmet sözleşmesi adı arabirimi adıdır.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-197">By default, the name of a service contract is the name of the interface.</span></span> <span data-ttu-id="dc9c3-198">Varsayılan ad "http://tempuri.org", ve her işlemin işlem "http://tempuri.org/contractname/methodname".</span><span class="sxs-lookup"><span data-stu-id="dc9c3-198">Its default namespace is "http://tempuri.org", and each operation’s action is "http://tempuri.org/contractname/methodname".</span></span> <span data-ttu-id="dc9c3-199">Açıkça bir ad ve hizmet sözleşmesi için ad alanı ve her bir işlemin kullanmaktan kaçınmak bir eylem belirtin önerilir "http://tempuri.org" ve hizmetin sözleşmede gösterilen arabirim ve yöntem adları önlemek için.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-199">It is recommended that you explicitly specify a name and namespace for the service contract, and an action for each operation to avoid using "http://tempuri.org" and to prevent interface and method names from being exposed in the service’s contract.</span></span>  
  
### <a name="adding-parameters-and-operations"></a><span data-ttu-id="dc9c3-200">Parametreler ve işlemler ekleme</span><span class="sxs-lookup"><span data-stu-id="dc9c3-200">Adding Parameters and Operations</span></span>  
 <span data-ttu-id="dc9c3-201">Mevcut istemciler bu yeni işlemleri hakkında endişe olması gerekmez çünkü hizmeti tarafından sunulan hizmet işlemleri ekleme bölünemez bir değişikliktir.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-201">Adding service operations exposed by the service is a nonbreaking change because existing clients need not be concerned about those new operations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dc9c3-202">Çift yönlü geri çağırma sözleşmeye işlemleri eklenmesi sonu bir değişikliktir.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-202">Adding operations to a duplex callback contract is a breaking change.</span></span>  
  
### <a name="changing-operation-parameter-or-return-types"></a><span data-ttu-id="dc9c3-203">Değiştirme işlemi parametresi veya dönüş türleri</span><span class="sxs-lookup"><span data-stu-id="dc9c3-203">Changing Operation Parameter or Return Types</span></span>  
 <span data-ttu-id="dc9c3-204">Yeni türü eski türü tarafından uygulanan aynı veri sözleşmesi uygulayan sürece parametresi veya return türlerini genellikle değiştirme sonu farklıdır.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-204">Changing parameter or return types generally is a breaking change unless the new type implements the same data contract implemented by the old type.</span></span> <span data-ttu-id="dc9c3-205">Bu tür bir değişiklik yapmak için yeni bir işlem için hizmet sözleşmesini eklemek veya yeni bir hizmet sözleşmesi tanımlayın.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-205">To make such a change, add a new operation to the service contract or define a new service contract.</span></span>  
  
### <a name="removing-operations"></a><span data-ttu-id="dc9c3-206">İşlemleri kaldırma</span><span class="sxs-lookup"><span data-stu-id="dc9c3-206">Removing Operations</span></span>  
 <span data-ttu-id="dc9c3-207">İşlemleri kaldırma, önemli bir değişiklik değil.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-207">Removing operations is also a breaking change.</span></span> <span data-ttu-id="dc9c3-208">Bu tür bir değişiklik yapmak için yeni bir hizmet sözleşmesini tanımlama ve yeni bir uç noktada kullanıma sunar.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-208">To make such a change, define a new service contract and expose it on a new endpoint.</span></span>  
  
### <a name="fault-contracts"></a><span data-ttu-id="dc9c3-209">Hataya sözleşmeleri</span><span class="sxs-lookup"><span data-stu-id="dc9c3-209">Fault Contracts</span></span>  
 <span data-ttu-id="dc9c3-210"><xref:System.ServiceModel.FaultContractAttribute> Özniteliği sözleşmenin işlemlerinden döndürülen hatalar hakkında bilgi belirtmek bir hizmet sözleşmesi Geliştirici sağlar.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-210">The <xref:System.ServiceModel.FaultContractAttribute> attribute enables a service contract developer to specify information about faults that can be returned from the contract's operations.</span></span>  
  
 <span data-ttu-id="dc9c3-211">Bir hizmet sözleşmesinde açıklanan hatalarının listesini, kapsamlı sayılmaz.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-211">The list of faults described in a service's contract is not considered exhaustive.</span></span> <span data-ttu-id="dc9c3-212">Herhangi bir anda bir işlem, sözleşmede açıklanmayan hataları döndürebilir.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-212">At any time, an operation may return faults that are not described in its contract.</span></span> <span data-ttu-id="dc9c3-213">Bu yüzden sözleşmede açıklanan hataları kümesini değiştirme yeni olarak kabul edilmez.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-213">Therefore changing the set of faults described in the contract is not considered breaking.</span></span> <span data-ttu-id="dc9c3-214">Örneğin, yeni bir arıza sözleşme kullanmaya ekleme <xref:System.ServiceModel.FaultContractAttribute> veya varolan bir hataya sözleşmeden kaldırma.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-214">For example, adding a new fault to the contract using the <xref:System.ServiceModel.FaultContractAttribute> or removing an existing fault from the contract.</span></span>  
  
### <a name="service-contract-libraries"></a><span data-ttu-id="dc9c3-215">Hizmet sözleşmesi kitaplıkları</span><span class="sxs-lookup"><span data-stu-id="dc9c3-215">Service Contract Libraries</span></span>  
 <span data-ttu-id="dc9c3-216">Kuruluşlar, burada bir sözleşme merkezi bir depoya yayımlanır ve bu depoyu sözleşmelerinden hizmet Implementers uygulamak sözleşmeleri kitaplıklarının olabilir.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-216">Organizations may have libraries of contracts where a contract is published to a central repository and service implementers implement contracts from that repository.</span></span> <span data-ttu-id="dc9c3-217">Bu durumda, bir hizmet sözleşmesini depoya yayımladığınızda, kimin uyguladıktan Hizmetleri oluşturur üzerinde denetiminiz yoktur.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-217">In this case, when you publish a service contract to the repository you have no control over who creates services that implement it.</span></span> <span data-ttu-id="dc9c3-218">Bu nedenle, etkili bir şekilde değişmez işleme yayımlandıktan sonra hizmet sözleşmesini değiştiremiyor.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-218">Therefore, you cannot modify the service contract once published, rendering it effectively immutable.</span></span> <span data-ttu-id="dc9c3-219">WCF varolan sözleşmeleri genişleten yeni bir sözleşme oluşturmak için kullanılan sözleşme devralma destekler.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-219">WCF supports contract inheritance, which can be used to create a new contract that extends existing contracts.</span></span> <span data-ttu-id="dc9c3-220">Bu özelliği kullanmak için eski hizmet sözleşmesi arabirimden devralan yeni bir hizmet sözleşme arabirimi tanımlayın, sonra yeni arabirim yöntemleri ekleyin.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-220">To use this feature, define a new service contract interface that inherits from the old service contract interface, then add methods to the new interface.</span></span> <span data-ttu-id="dc9c3-221">Ardından, yeni sözleşme uygulamak ve yeni sözleşme kullanmak için "versionOld" uç nokta tanımı değiştirmek için eski sözleşme uygulayan hizmeti de değiştirin.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-221">You then change the service that implements the old contract to implement the new contract and change the "versionOld" endpoint definition to use the new contract.</span></span> <span data-ttu-id="dc9c3-222">"VersionOld" istemcilere uç nokta olarak sunan "versionOld" Sözleşme görünmeye devam edecek; "versionNew" istemcilere endpoint "versionNew" Sözleşme kullanıma sunmak için görüntülenir.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-222">To "versionOld" clients, the endpoint will continue to appear as exposing the "versionOld" contract; to "versionNew" clients, the endpoint will appear to expose the "versionNew" contract.</span></span>  
  
## <a name="address-and-binding-versioning"></a><span data-ttu-id="dc9c3-223">Adres ve bağlama sürüm oluşturma</span><span class="sxs-lookup"><span data-stu-id="dc9c3-223">Address and Binding Versioning</span></span>  
 <span data-ttu-id="dc9c3-224">İstemcileri yeni uç nokta adresi dinamik olarak bulma veya bağlama yeteneğine sahip olmadığınız sürece uç noktası adresi ve bağlama değişiklikler değişiklikleri ayırırsınız.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-224">Changes to endpoint address and binding are breaking changes unless clients are capable of dynamically discovering the new endpoint address or binding.</span></span> <span data-ttu-id="dc9c3-225">Bu özelliği uygulamak için bir kayıt defterine Evrensel bulma açıklama ve tümleştirme (UDDI) ve UDDI çağırma olduğu bir istemci bir uç nokta ile iletişim kurmaya çalışır ve, başarısızlık durumunda, iyi bilinen UDDI sorgular düzeni kullanarak mekanizmadır Geçerli uç nokta meta veriler için kayıt defteri.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-225">One mechanism for implementing this capability is by using a Universal Discovery Description and Integration (UDDI) registry and the UDDI Invocation Pattern where a client attempts to communicate with an endpoint and, upon failure, queries a well-known UDDI registry for the current endpoint metadata.</span></span> <span data-ttu-id="dc9c3-226">İstemci ardından adresi ve bu meta verilerden bağlama bitiş noktası ile iletişim kurmak için kullanır.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-226">The client then uses the address and binding from this metadata to communicate with the endpoint.</span></span> <span data-ttu-id="dc9c3-227">Bu iletişim başarılı olursa, istemci gelecekte kullanım için adres ve bağlama bilgilerini önbelleğe alır.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-227">If this communication succeeds, the client caches the address and binding information for future use.</span></span>  
  
## <a name="routing-service-and-versioning"></a><span data-ttu-id="dc9c3-228">Yönlendirme hizmeti ve sürüm oluşturma</span><span class="sxs-lookup"><span data-stu-id="dc9c3-228">Routing Service and Versioning</span></span>  
 <span data-ttu-id="dc9c3-229">Değişiklikleri ve yeni bir hizmet için yapılan değişiklikler, iki veya daha fazla farklı sürümlerini çalıştıran bir hizmet sağlamak için aynı anda WCF yönlendirme hizmeti iletileri yönlendirmek için uygun hizmet örneği için kullanabileceğiniz.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-229">If the changes made to a service are breaking changes and you need to have two or more different versions of a service running simultaneously you can use the WCF Routing Service to route messages to the appropriate service instance.</span></span> <span data-ttu-id="dc9c3-230">Yönlendirme WCF hizmeti içerik tabanlı yönlendirme kullanıyor, diğer bir deyişle, ileti yönlendirmek nereye belirlemek için ileti içindeki bilgileri kullanır.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-230">The WCF Routing Service uses content-based routing, in other words, it uses information within the message to determine where to route the message.</span></span> <span data-ttu-id="dc9c3-231">WCF yönlendirme hizmeti bakın hakkında daha fazla bilgi için [yönlendirme hizmeti](../../../docs/framework/wcf/feature-details/routing-service.md).</span><span class="sxs-lookup"><span data-stu-id="dc9c3-231">For more information about the WCF Routing Service see [Routing Service](../../../docs/framework/wcf/feature-details/routing-service.md).</span></span> <span data-ttu-id="dc9c3-232">Hizmet sürümü oluşturma için yönlendirme WCF hizmetini kullanma örneği için bkz: [nasıl yapılır: Hizmet sürümü oluşturma](../../../docs/framework/wcf/feature-details/how-to-service-versioning.md).</span><span class="sxs-lookup"><span data-stu-id="dc9c3-232">For an example of how to use the WCF Routing Service for service versioning see [How To: Service Versioning](../../../docs/framework/wcf/feature-details/how-to-service-versioning.md).</span></span>  
  
## <a name="appendix"></a><span data-ttu-id="dc9c3-233">Ek</span><span class="sxs-lookup"><span data-stu-id="dc9c3-233">Appendix</span></span>  
 <span data-ttu-id="dc9c3-234">Veri sözleşmeleri değişmez olarak kabul eder ve değişikliklerin gerekli olduğunda yeni kampanya oluşturmak için katı sürüm gerektiğinde genel veri sözleşmesi sürümü oluşturma yönergeler verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-234">The general data contract versioning guidance when strict versioning is needed is to treat data contracts as immutable and create new ones when changes are required.</span></span> <span data-ttu-id="dc9c3-235">Yeni bir sınıf için her yeni veri sözleşmesi oluşturulmalıdır, bir mekanizma cinsinden yazılmış varolan kodun almak zorunda kalmamak için gerektiği şekilde eski verileri sınıfı sözleşme ve yeni veri sözleşme sınıfı bakımından yeniden yazma.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-235">A new class needs to be created for each new data contract, so a mechanism is needed to avoid having to take existing code that was written in terms of the old data contract class and rewrite it in terms of the new data contract class.</span></span>  
  
 <span data-ttu-id="dc9c3-236">Bu tür bir mekanizma, her veri sözleşmesi üyelerini tanımlamak ve iç uygulama kodu arabirimlerini veri sözleşmesi sınıfları yerine arabirimler açısından yazma arabirimleri kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-236">One such mechanism is to use interfaces to define the members of each data contract and write internal implementation code in terms of the interfaces rather than the data contract classes that implement the interfaces.</span></span> <span data-ttu-id="dc9c3-237">Aşağıdaki kod, bir hizmetin sürüm 1 için gösterir bir `IPurchaseOrderV1` arabirimi ve `PurchaseOrderV1`:</span><span class="sxs-lookup"><span data-stu-id="dc9c3-237">The following code for version 1 of a service shows an `IPurchaseOrderV1` interface and a `PurchaseOrderV1`:</span></span>  
  
```  
public interface IPurchaseOrderV1  
{  
    string OrderId { get; set; }  
    string CustomerId { get; set; }  
}  
  
[DataContract(  
Name = "PurchaseOrder",  
Namespace = "http://examples.microsoft.com/WCF/2005/10/PurchaseOrder")]  
public class PurchaseOrderV1 : IPurchaseOrderV1  
{  
    [DataMember(...)]  
    public string OrderId {...}  
    [DataMember(...)]  
    public string CustomerId {...}  
}  
```  
  
 <span data-ttu-id="dc9c3-238">Hizmet sözleşmenin işlemleri cinsinden yazılacak sırada `PurchaseOrderV1`, gerçek iş mantığı cinsinden olacaktır `IPurchaseOrderV1`.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-238">While the service contract’s operations would be written in terms of `PurchaseOrderV1`, the actual business logic would be in terms of `IPurchaseOrderV1`.</span></span> <span data-ttu-id="dc9c3-239">Ardından, sürüm 2'de, olurdu yeni bir `IPurchaseOrderV2` arabirimi ve yeni bir `PurchaseOrderV2` sınıfı aşağıdaki kodda gösterildiği gibi:</span><span class="sxs-lookup"><span data-stu-id="dc9c3-239">Then, in version 2, there would be a new `IPurchaseOrderV2` interface and a new `PurchaseOrderV2` class as shown in the following code:</span></span>  
  
```  
public interface IPurchaseOrderV2  
{  
    DateTime OrderDate { get; set; }  
}

[DataContract(   
Name = "PurchaseOrder",  
Namespace = "http://examples.microsoft.com/WCF/2006/02/PurchaseOrder")]  
public class PurchaseOrderV2 : IPurchaseOrderV1, IPurchaseOrderV2  
{  
    [DataMember(...)]  
    public string OrderId {...}  
    [DataMember(...)]  
    public string CustomerId {...}  
    [DataMember(...)]  
    public DateTime OrderDate { ... }  
}  
```  
  
 <span data-ttu-id="dc9c3-240">Hizmet sözleşmesi cinsinden yazılan yeni işlem içerecek şekilde güncelleştirilmesi `PurchaseOrderV2`.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-240">The service contract would be updated to include new operations that are written in terms of `PurchaseOrderV2`.</span></span> <span data-ttu-id="dc9c3-241">Cinsinden yazılan var olan iş mantığı `IPurchaseOrderV1` için çalışmaya devam edeceği `PurchaseOrderV2` ve gereken yeni iş mantığı `OrderDate` özelliği cinsinden yazılması `IPurchaseOrderV2`.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-241">Existing business logic written in terms of `IPurchaseOrderV1` would continue to work for `PurchaseOrderV2` and new business logic that needs the `OrderDate` property would be written in terms of `IPurchaseOrderV2`.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="dc9c3-242">Ayrıca Bkz.</span><span class="sxs-lookup"><span data-stu-id="dc9c3-242">See Also</span></span>  
 <xref:System.Runtime.Serialization.DataContractSerializer>  
 <xref:System.Runtime.Serialization.DataContractAttribute>  
 <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A>  
 <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>  
 <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>  
 <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A>  
 <xref:System.Runtime.Serialization.IExtensibleDataObject>  
 <xref:System.Runtime.Serialization.ExtensionDataObject>  
 <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A>  
 <xref:System.Xml.Serialization.XmlSerializer>  
 [<span data-ttu-id="dc9c3-243">Veri Anlaşması Eşitliği</span><span class="sxs-lookup"><span data-stu-id="dc9c3-243">Data Contract Equivalence</span></span>](../../../docs/framework/wcf/feature-details/data-contract-equivalence.md)  
 [<span data-ttu-id="dc9c3-244">Sürüm Toleranslı Seri Hale Getirme Geri Çağrıları</span><span class="sxs-lookup"><span data-stu-id="dc9c3-244">Version-Tolerant Serialization Callbacks</span></span>](../../../docs/framework/wcf/feature-details/version-tolerant-serialization-callbacks.md)
