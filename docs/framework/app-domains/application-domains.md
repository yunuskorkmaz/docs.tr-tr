---
title: Uygulama Etki Alanları
ms.date: 03/30/2017
helpviewer_keywords:
- process boundaries for isolation
- application isolation
- application domains, about
- common language runtime, application domains
- application domains
- runtime, application domains
- isolation between applications
- code, verification process
- verification testing code
ms.assetid: 113a8bbf-6875-4a72-a49d-ca2d92e19cc8
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 04028a2b350493a3cc8f2c92bafafd9658fc7c58
ms.sourcegitcommit: 11f11ca6cefe555972b3a5c99729d1a7523d8f50
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 05/03/2018
---
# <a name="application-domains"></a><span data-ttu-id="2a152-102">Uygulama Etki Alanları</span><span class="sxs-lookup"><span data-stu-id="2a152-102">Application Domains</span></span>
<span data-ttu-id="2a152-103">İşletim sistemleri ve çalışma zamanı ortamları tipik olarak bazı form uygulamalar arasında yalıtım sağlar.</span><span class="sxs-lookup"><span data-stu-id="2a152-103">Operating systems and runtime environments typically provide some form of isolation between applications.</span></span> <span data-ttu-id="2a152-104">Örneğin, Windows uygulamalarını yalıtmak için işlemleri kullanır.</span><span class="sxs-lookup"><span data-stu-id="2a152-104">For example, Windows uses processes to isolate applications.</span></span> <span data-ttu-id="2a152-105">Bu yalıtım bir uygulamada çalışan kodu ilgisiz, diğer uygulamalar olumsuz etkileyemez sağlamak gereklidir.</span><span class="sxs-lookup"><span data-stu-id="2a152-105">This isolation is necessary to ensure that code running in one application cannot adversely affect other, unrelated applications.</span></span>  
  
 <span data-ttu-id="2a152-106">Uygulama etki alanları, güvenlik, güvenilirlik ve sürüm oluşturma ve yüklemeyi kaldırma derlemeler için bir yalıtım sınırı sağlar.</span><span class="sxs-lookup"><span data-stu-id="2a152-106">Application domains provide an isolation boundary for security, reliability, and versioning, and for unloading assemblies.</span></span> <span data-ttu-id="2a152-107">Uygulama etki alanları genellikle bir uygulamayı çalıştırmadan önce ortak dil çalışma zamanı önyüklemesinden sorumlu çalışma zamanı konaklar tarafından oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="2a152-107">Application domains are typically created by runtime hosts, which are responsible for bootstrapping the common language runtime before an application is run.</span></span>  
  
 <span data-ttu-id="2a152-108">Bu bölümdeki konular, belgelerin uygulama etki alanları arasında derlemeleri yalıtımı sağlamak için nasıl kullanılacağı açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="2a152-108">The topics in this section of the documentation explain how to use application domains to provide isolation between assemblies.</span></span>  
  
 <span data-ttu-id="2a152-109">Bu genel bakışta aşağıdaki bölümleri içerir:</span><span class="sxs-lookup"><span data-stu-id="2a152-109">This overview contains the following sections:</span></span>  
  
-   [<span data-ttu-id="2a152-110">Uygulamaları Yalıtma avantajları</span><span class="sxs-lookup"><span data-stu-id="2a152-110">The Benefits of Isolating Applications</span></span>](#benefits)  
  
-   [<span data-ttu-id="2a152-111">Başvuru</span><span class="sxs-lookup"><span data-stu-id="2a152-111">Reference</span></span>](#reference)  
  
<a name="benefits"></a>   
## <a name="the-benefits-of-isolating-applications"></a><span data-ttu-id="2a152-112">Uygulamaları Yalıtma avantajları</span><span class="sxs-lookup"><span data-stu-id="2a152-112">The Benefits of Isolating Applications</span></span>  
 <span data-ttu-id="2a152-113">Tarihsel olarak, aynı bilgisayarda çalışan uygulamalarını yalıtmak için işlem sınırları kullanıldı.</span><span class="sxs-lookup"><span data-stu-id="2a152-113">Historically, process boundaries have been used to isolate applications running on the same computer.</span></span> <span data-ttu-id="2a152-114">Her uygulama aynı bilgisayarda çalışan diğer uygulamalardan ayıran ayrı bir işlemde içine yüklenir.</span><span class="sxs-lookup"><span data-stu-id="2a152-114">Each application is loaded into a separate process, which isolates the application from other applications running on the same computer.</span></span>  
  
 <span data-ttu-id="2a152-115">Bellek adreslerini işlem göreli olduğundan uygulamaları yalıtılmış; başka bir işleminden geçirilen bir bellek işaretçisi herhangi anlamlı bir şekilde hedef işlemde kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="2a152-115">The applications are isolated because memory addresses are process-relative; a memory pointer passed from one process to another cannot be used in any meaningful way in the target process.</span></span> <span data-ttu-id="2a152-116">Ayrıca, iki işlem arasında doğrudan çağrılar yapamazsınız.</span><span class="sxs-lookup"><span data-stu-id="2a152-116">In addition, you cannot make direct calls between two processes.</span></span> <span data-ttu-id="2a152-117">Bunun yerine, bir yöneltme düzeyini sağlamak proxy'leri kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="2a152-117">Instead, you must use proxies, which provide a level of indirection.</span></span>  
  
 <span data-ttu-id="2a152-118">Yönetilen kod (yönetici Doğrulamayı atla izni sürece) çalıştırabilmeniz için önce bir doğrulama işlemi geçirilmelidir.</span><span class="sxs-lookup"><span data-stu-id="2a152-118">Managed code must be passed through a verification process before it can be run (unless the administrator has granted permission to skip the verification).</span></span> <span data-ttu-id="2a152-119">Doğrulama işlemi, kodu erişim geçersiz bellek adresleri veya içinde düzgün çalışması kapatmaya çalıştığı işlemin neden olabilecek başka bir eylemi gerçekleştirmek deneyebilirsiniz olup olmadığını belirler.</span><span class="sxs-lookup"><span data-stu-id="2a152-119">The verification process determines whether the code can attempt to access invalid memory addresses or perform some other action that could cause the process in which it is running to fail to operate properly.</span></span> <span data-ttu-id="2a152-120">Doğrulama testi geçirir kod tür kullanımı uyumlu olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="2a152-120">Code that passes the verification test is said to be type-safe.</span></span> <span data-ttu-id="2a152-121">Tür kullanımı uyumlu olarak kod doğrulamak için ortak dil çalışma zamanı olarak harika işlem sınırında bir çok düşük performans olarak yalıtım düzeyini sağlamak amacıyla sağlar.</span><span class="sxs-lookup"><span data-stu-id="2a152-121">The ability to verify code as type-safe enables the common language runtime to provide as great a level of isolation as the process boundary, at a much lower performance cost.</span></span>  
  
 <span data-ttu-id="2a152-122">Uygulama etki alanları ortak dil çalışma zamanı uygulamalar arasında yalıtım sağlamak için kullanabileceği işleme daha güvenli ve çok yönlü birimi sağlayın.</span><span class="sxs-lookup"><span data-stu-id="2a152-122">Application domains provide a more secure and versatile unit of processing that the common language runtime can use to provide isolation between applications.</span></span> <span data-ttu-id="2a152-123">Aynı ayrı işlemlerdeki ancak çapraz işlem çağrıları yapma veya işlemler arasında geçiş ek yükünü yansıtılmasını olmadan var yalıtım düzeyine sahip tek bir işlemde birkaç uygulama etki alanları çalıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2a152-123">You can run several application domains in a single process with the same level of isolation that would exist in separate processes, but without incurring the additional overhead of making cross-process calls or switching between processes.</span></span> <span data-ttu-id="2a152-124">Tek bir işlem içinde birden çok uygulama önemli ölçüde çalıştırma yeteneğini sunucu ölçeklenebilirliğini artırır.</span><span class="sxs-lookup"><span data-stu-id="2a152-124">The ability to run multiple applications within a single process dramatically increases server scalability.</span></span>  
  
 <span data-ttu-id="2a152-125">Uygulamaları Yalıtma da uygulama güvenliği için önemlidir.</span><span class="sxs-lookup"><span data-stu-id="2a152-125">Isolating applications is also important for application security.</span></span> <span data-ttu-id="2a152-126">Örneğin, bir tek tarayıcı işlemde denetimleri birbirlerinin verilerine ve kaynaklarına erişemiyor şekilde birkaç Web uygulamalarından denetimleri çalıştırabilir.</span><span class="sxs-lookup"><span data-stu-id="2a152-126">For example, you can run controls from several Web applications in a single browser process in such a way that the controls cannot access each other's data and resources.</span></span>  
  
 <span data-ttu-id="2a152-127">Uygulama etki alanları tarafından sağlanan yalıtım aşağıdaki faydaları vardır:</span><span class="sxs-lookup"><span data-stu-id="2a152-127">The isolation provided by application domains has the following benefits:</span></span>  
  
-   <span data-ttu-id="2a152-128">Bir uygulamadaki hataları diğer uygulamaları etkileyemez.</span><span class="sxs-lookup"><span data-stu-id="2a152-128">Faults in one application cannot affect other applications.</span></span> <span data-ttu-id="2a152-129">Tür kullanımı uyumlu kod bellek hatalarına neden yapılamıyor çünkü uygulama etki alanları kullanarak bir etki alanında çalışan kodu işlem diğer uygulamalarda etkileyemez sağlar.</span><span class="sxs-lookup"><span data-stu-id="2a152-129">Because type-safe code cannot cause memory faults, using application domains ensures that code running in one domain cannot affect other applications in the process.</span></span>  
  
-   <span data-ttu-id="2a152-130">Tek tek uygulamalar bütün işlem durdurmadan durdurulabilir.</span><span class="sxs-lookup"><span data-stu-id="2a152-130">Individual applications can be stopped without stopping the entire process.</span></span> <span data-ttu-id="2a152-131">Uygulama etki alanları kullanarak, tek bir uygulama içinde çalışan kodu unload olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="2a152-131">Using application domains enables you to unload the code running in a single application.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="2a152-132">Ayrı ayrı derlemeler veya türleri kaldıramıyor.</span><span class="sxs-lookup"><span data-stu-id="2a152-132">You cannot unload individual assemblies or types.</span></span> <span data-ttu-id="2a152-133">Yalnızca tam etki alanı kaldırılmış olabilir.</span><span class="sxs-lookup"><span data-stu-id="2a152-133">Only a complete domain can be unloaded.</span></span>  
  
-   <span data-ttu-id="2a152-134">Bir uygulamada çalışan kodu doğrudan erişim kodu ya da başka bir uygulama kaynaklardan yükleyemezsiniz.</span><span class="sxs-lookup"><span data-stu-id="2a152-134">Code running in one application cannot directly access code or resources from another application.</span></span> <span data-ttu-id="2a152-135">Ortak dil çalışma zamanı, farklı uygulama etki alanlarında nesneleri arasında doğrudan çağrılar engelleyerek bu yalıtım zorlar.</span><span class="sxs-lookup"><span data-stu-id="2a152-135">The common language runtime enforces this isolation by preventing direct calls between objects in different application domains.</span></span> <span data-ttu-id="2a152-136">Etki alanları arasında geçirmek nesneler kopyalanan ya da proxy tarafından erişilebilir.</span><span class="sxs-lookup"><span data-stu-id="2a152-136">Objects that pass between domains are either copied or accessed by proxy.</span></span> <span data-ttu-id="2a152-137">Nesne kopyaladıysanız, nesne için yerel çağrıdır.</span><span class="sxs-lookup"><span data-stu-id="2a152-137">If the object is copied, the call to the object is local.</span></span> <span data-ttu-id="2a152-138">Diğer bir deyişle, çağıran ve başvurulan nesne aynı uygulama etki alanındadır.</span><span class="sxs-lookup"><span data-stu-id="2a152-138">That is, both the caller and the object being referenced are in the same application domain.</span></span> <span data-ttu-id="2a152-139">Nesne bir proxy üzerinden erişilen, nesne çağrısı uzak olur.</span><span class="sxs-lookup"><span data-stu-id="2a152-139">If the object is accessed through a proxy, the call to the object is remote.</span></span> <span data-ttu-id="2a152-140">Bu durumda, çağıranın ve başvurulan nesne farklı uygulama etki alanlarında markalarıdır.</span><span class="sxs-lookup"><span data-stu-id="2a152-140">In this case, the caller and the object being referenced are in different application domains.</span></span> <span data-ttu-id="2a152-141">Etki alanları arası çağrılar çağrıları iki makine arasında veya iki işlemler arasında aynı uzak çağrı altyapısını kullanır.</span><span class="sxs-lookup"><span data-stu-id="2a152-141">Cross-domain calls use the same remote call infrastructure as calls between two processes or between two machines.</span></span> <span data-ttu-id="2a152-142">Bu nedenle, başvurulan nesne için meta veriler JIT derlenmiş düzgün olmasını yöntem çağrısı izin vermek için her iki uygulama etki alanları için kullanılabilir olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="2a152-142">As such, the metadata for the object being referenced must be available to both application domains to allow the method call to be JIT-compiled properly.</span></span> <span data-ttu-id="2a152-143">Çağıran etki çağrılan nesnesi için meta veri erişimi yoksa, derleme türünde bir özel durum ile başarısız olabilir **System.IO.FileNotFound**.</span><span class="sxs-lookup"><span data-stu-id="2a152-143">If the calling domain does not have access to the metadata for the object being called, the compilation might fail with an exception of type **System.IO.FileNotFound**.</span></span> <span data-ttu-id="2a152-144">Bkz: [uzak nesneleri](http://msdn.microsoft.com/library/515686e6-0a8d-42f7-8188-73abede57c58) daha fazla ayrıntı için.</span><span class="sxs-lookup"><span data-stu-id="2a152-144">See [Remote Objects](http://msdn.microsoft.com/library/515686e6-0a8d-42f7-8188-73abede57c58) for more details.</span></span> <span data-ttu-id="2a152-145">Nesneleri etki alanları arasında nasıl erişilebileceğini belirlemek için mekanizması nesne tarafından belirlenir.</span><span class="sxs-lookup"><span data-stu-id="2a152-145">The mechanism for determining how objects can be accessed across domains is determined by the object.</span></span> <span data-ttu-id="2a152-146">Daha fazla bilgi için bkz. <xref:System.MarshalByRefObject?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2a152-146">For more information, see <xref:System.MarshalByRefObject?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="2a152-147">Kod davranışını içinde çalışan uygulama tarafından kapsamlıdır.</span><span class="sxs-lookup"><span data-stu-id="2a152-147">The behavior of code is scoped by the application in which it runs.</span></span> <span data-ttu-id="2a152-148">Diğer bir deyişle, uygulama etki alanı uygulama sürüm ilkeleri, eriştiği herhangi bir uzak derlemeler ve etki alanına yüklenmiş derlemeleri yerleştireceğinizi hakkında bilgi konumu gibi yapılandırma ayarlarını sağlar.</span><span class="sxs-lookup"><span data-stu-id="2a152-148">In other words, the application domain provides configuration settings such as application version policies, the location of any remote assemblies it accesses, and information about where to locate assemblies that are loaded into the domain.</span></span>  
  
-   <span data-ttu-id="2a152-149">Kod için izinler kodu çalıştığı uygulama etki alanı tarafından denetlenebilir.</span><span class="sxs-lookup"><span data-stu-id="2a152-149">Permissions granted to code can be controlled by the application domain in which the code is running.</span></span>  
  
  
## <a name="application-domains-and-assemblies"></a><span data-ttu-id="2a152-150">Uygulama Etki Alanları ve Derlemeler</span><span class="sxs-lookup"><span data-stu-id="2a152-150">Application Domains and Assemblies</span></span>  
 <span data-ttu-id="2a152-151">Bu konuda uygulama etki alanları ve derlemeler arasındaki ilişki açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="2a152-151">This topic describes the relationship between application domains and assemblies.</span></span> <span data-ttu-id="2a152-152">Bir derlemenin içerdiği kodu yürütmeden önce derlemeyi bir uygulama etki alanına yüklemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="2a152-152">You must load an assembly into an application domain before you can execute the code it contains.</span></span> <span data-ttu-id="2a152-153">Tipik bir uygulamayı çalıştırmak, bir uygulama etki alanına birkaç derlemenin yüklenmesine neden olur.</span><span class="sxs-lookup"><span data-stu-id="2a152-153">Running a typical application causes several assemblies to be loaded into an application domain.</span></span>  
  
 <span data-ttu-id="2a152-154">Bir derlemenin yüklenme şekli, onun işlemdeki birden çok uygulama etki alanı ile paylaşılabilen anlık (JIT) derlenmiş kod olup olmadığını ve derlemenin işlemden kaldırılabilip kaldırılamayacağını belirler.</span><span class="sxs-lookup"><span data-stu-id="2a152-154">The way an assembly is loaded determines whether its just-in-time (JIT) compiled code can be shared by multiple application domains in the process, and whether the assembly can be unloaded from the process.</span></span>  
  
-   <span data-ttu-id="2a152-155">Eğer bir derleme etki alanından bağımsız olarak yüklenirse, aynı güvenlik izni kümesine sahip olan tüm uygulama etki alanları aynı JIT olarak derlenmiş kodunu paylaşabilir ve bu da uygulamanın gerektirdiği belleği azaltır.</span><span class="sxs-lookup"><span data-stu-id="2a152-155">If an assembly is loaded domain-neutral, all application domains that share the same security grant set can share the same JIT-compiled code, which reduces the memory required by the application.</span></span> <span data-ttu-id="2a152-156">Ancak, derleme işlemden asla kaldırılamaz.</span><span class="sxs-lookup"><span data-stu-id="2a152-156">However, the assembly can never be unloaded from the process.</span></span>  
  
-   <span data-ttu-id="2a152-157">Eğer bir derleme etki alanından bağımsız olarak yüklenmezse, yüklendiği tüm uygulama etki alanlarında JIT olarak derlenmelidir.</span><span class="sxs-lookup"><span data-stu-id="2a152-157">If an assembly is not loaded domain-neutral, it must be JIT-compiled in every application domain in which it is loaded.</span></span> <span data-ttu-id="2a152-158">Ancak derleme, yüklü olduğu tüm uygulama etki alanları kaldırılarak işlemden kaldırılabilir.</span><span class="sxs-lookup"><span data-stu-id="2a152-158">However, the assembly can be unloaded from the process by unloading all the application domains in which it is loaded.</span></span>  
  
 <span data-ttu-id="2a152-159">Çalışma zamanı konak ortamı, çalışma zamanını bir işleme yüklerken derlemeleri etki alanından bağımsız olarak yükleyip yüklemeyeceğini belirler.</span><span class="sxs-lookup"><span data-stu-id="2a152-159">The runtime host determines whether to load assemblies as domain-neutral when it loads the runtime into a process.</span></span> <span data-ttu-id="2a152-160">Yönetilen uygulamalar için, <xref:System.LoaderOptimizationAttribute> özniteliğini işlem için giriş noktası metoduna uygulayın ve ilişkili <xref:System.LoaderOptimization> sabit listesinden bir değer belirtin.</span><span class="sxs-lookup"><span data-stu-id="2a152-160">For managed applications, apply the <xref:System.LoaderOptimizationAttribute> attribute to the entry-point method for the process, and specify a value from the associated <xref:System.LoaderOptimization> enumeration.</span></span> <span data-ttu-id="2a152-161">Ortak dil çalışma zamanı ana bilgisayar yönetilmeyen uygulamaları belirtmek için uygun bayrağı çağırdığınızda [CorBindToRuntimeEx işlevi](../../../docs/framework/unmanaged-api/hosting/corbindtoruntimeex-function.md) yöntemi.</span><span class="sxs-lookup"><span data-stu-id="2a152-161">For unmanaged applications that host the common language runtime, specify the appropriate flag when you call the [CorBindToRuntimeEx Function](../../../docs/framework/unmanaged-api/hosting/corbindtoruntimeex-function.md) method.</span></span>  
  
 <span data-ttu-id="2a152-162">Etki alanından bağımsız derlemeleri yüklemek için üç seçenek vardır:</span><span class="sxs-lookup"><span data-stu-id="2a152-162">There are three options for loading domain-neutral assemblies:</span></span>  
  
-   <span data-ttu-id="2a152-163"><xref:System.LoaderOptimization>, her zaman etki alanından bağımsız olarak yüklenen Mscorlib dışındaki hiçbir derlemeyi etki alanından bağımsız olarak yüklemez.</span><span class="sxs-lookup"><span data-stu-id="2a152-163"><xref:System.LoaderOptimization> loads no assemblies as domain-neutral, except Mscorlib, which is always loaded domain-neutral.</span></span> <span data-ttu-id="2a152-164">Ana bilgisayar işleminde yalnızca tek bir uygulama çalışırken sık kullanıldığı için bu ayar tek etki alanı adı verilir.</span><span class="sxs-lookup"><span data-stu-id="2a152-164">This setting is called single domain because it is commonly used when the host is running only a single application in the process.</span></span>  
  
-   <span data-ttu-id="2a152-165"><xref:System.LoaderOptimization>, tüm derlemeleri etki alanından bağımsız yükler.</span><span class="sxs-lookup"><span data-stu-id="2a152-165"><xref:System.LoaderOptimization> loads all assemblies as domain-neutral.</span></span> <span data-ttu-id="2a152-166">İşlemde tamamı aynı kodu çalıştıran birden çok uygulama etki alanı olduğunda bu ayarı kullanın.</span><span class="sxs-lookup"><span data-stu-id="2a152-166">Use this setting when there are multiple application domains in the process, all of which run the same code.</span></span>  
  
-   <span data-ttu-id="2a152-167"><xref:System.LoaderOptimization>, tanımlayıcı ada sahip olan derlemeleri, kendileri ve tüm bağımlılıkları genel bütünleştirilmiş kod önbelleğinde yüklü ise, etki alanından bağımsız olarak yükler.</span><span class="sxs-lookup"><span data-stu-id="2a152-167"><xref:System.LoaderOptimization> loads strong-named assemblies as domain-neutral, if they and all their dependencies have been installed in the global assembly cache.</span></span> <span data-ttu-id="2a152-168">Diğer derlemeler yüklü oldukları her uygulama etki alanı için ayrı olarak yüklenip JIT olarak derlenirler ve bu nedenle işlemden kaldırılabilirler.</span><span class="sxs-lookup"><span data-stu-id="2a152-168">Other assemblies are loaded and JIT-compiled separately for each application domain in which they are loaded, and thus can be unloaded from the process.</span></span> <span data-ttu-id="2a152-169">Aynı işlemde birden çok uygulama çalıştırırken veya işlemden kaldırılması gereken birden çok uygulama etki alanı ve derleme tarafından paylaşılan bir derleme karışımına sahipseniz bu ayarı kullanın.</span><span class="sxs-lookup"><span data-stu-id="2a152-169">Use this setting when running more than one application in the same process, or if you have a mixture of assemblies that are shared by many application domains and assemblies that need to be unloaded from the process.</span></span>  
  
 <span data-ttu-id="2a152-170">JIT olarak derlenmiş kod, <xref:System.Reflection.Assembly.LoadFrom%2A> sınıfının <xref:System.Reflection.Assembly> yöntemi kullanarak load-from bağlamı içine yüklenen derlemeler için ya da <xref:System.Reflection.Assembly.Load%2A> yönteminin bayt dizilerini belirten aşırı yüklemeleri kullanılarak görüntülerden yüklenen derlemeler için paylaşılamaz.</span><span class="sxs-lookup"><span data-stu-id="2a152-170">JIT-compiled code cannot be shared for assemblies loaded into the load-from context, using the <xref:System.Reflection.Assembly.LoadFrom%2A> method of the <xref:System.Reflection.Assembly> class, or loaded from images using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify byte arrays.</span></span>  
  
 <span data-ttu-id="2a152-171">Yerel kod kullanılarak derlenmiştir derlemeleri [Ngen.exe (yerel Görüntü Oluşturucu)](../../../docs/framework/tools/ngen-exe-native-image-generator.md) oldukları süreç içine yüklenen ilk etki alanı Tarafsız yüklerse, uygulama etki alanları arasında paylaşılabilir.</span><span class="sxs-lookup"><span data-stu-id="2a152-171">Assemblies that have been compiled to native code by using the [Ngen.exe (Native Image Generator)](../../../docs/framework/tools/ngen-exe-native-image-generator.md) can be shared between application domains, if they are loaded domain-neutral the first time they are loaded into a process.</span></span>  
  
 <span data-ttu-id="2a152-172">Uygulama giriş noktasını içeren derleme için JIT olarak derlenmiş kod, yalnızca tüm bağımlılıkları paylaşılabiliyorsa paylaşılır.</span><span class="sxs-lookup"><span data-stu-id="2a152-172">JIT-compiled code for the assembly that contains the application entry point is shared only if all its dependencies can be shared.</span></span>  
  
 <span data-ttu-id="2a152-173">Etki alanından bağımsız bir derleme JIT olarak birden çok kez derlenebilir.</span><span class="sxs-lookup"><span data-stu-id="2a152-173">A domain-neutral assembly can be JIT-compiled more than once.</span></span> <span data-ttu-id="2a152-174">Örneğin, iki uygulama etki alanının güvenlik izni kümeleri farklıysa, aynı JIT olarak derlenmiş kodu paylaşamazlar.</span><span class="sxs-lookup"><span data-stu-id="2a152-174">For example, when the security grant sets of two application domains are different, they cannot share the same JIT-compiled code.</span></span> <span data-ttu-id="2a152-175">Ancak, JIT olarak derlenmiş derlemenin her kopyası, aynı izin kümesine sahip olan diğer uygulama etki alanlarıyla paylaşılabilir.</span><span class="sxs-lookup"><span data-stu-id="2a152-175">However, each copy of the JIT-compiled assembly can be shared with other application domains that have the same grant set.</span></span>  
  
 <span data-ttu-id="2a152-176">Derlemeleri etki alanından bağımsız olarak yükleyip yüklemeyeceğinize karar verdiğinizde, bellek kullanımı ve diğer performans etmenleri arasında bir takas yapmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="2a152-176">When you decide whether to load assemblies as domain-neutral, you must make a tradeoff between reducing memory use and other performance factors.</span></span>  
  
-   <span data-ttu-id="2a152-177">Etki alanından bağımsız derlemeler için statik verilere ve yöntemlere olan erişim, derlemeleri yalıtmak gerektiği için daha yavaştır.</span><span class="sxs-lookup"><span data-stu-id="2a152-177">Access to static data and methods is slower for domain-neutral assemblies because of the need to isolate assemblies.</span></span> <span data-ttu-id="2a152-178">Statik alanlardaki nesnelere olan başvuruların etki alanı sınırlarını geçmesini engellemek için derlemeye erişen tüm uygulama etki alanlarının, statik verinin ayrı kopyalarına sahip olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="2a152-178">Each application domain that accesses the assembly must have a separate copy of the static data, to prevent references to objects in static fields from crossing domain boundaries.</span></span> <span data-ttu-id="2a152-179">Sonuç olarak, çalışma zamanı bir çağıranı statik veri veya yöntemin uygun kopyasına yönlendirmek için ek mantık içerir.</span><span class="sxs-lookup"><span data-stu-id="2a152-179">As a result, the runtime contains additional logic to direct a caller to the appropriate copy of the static data or method.</span></span> <span data-ttu-id="2a152-180">Bu ek mantık, çağrıyı yavaşlatır.</span><span class="sxs-lookup"><span data-stu-id="2a152-180">This extra logic slows down the call.</span></span>  
  
-   <span data-ttu-id="2a152-181">Derleme etki alanından bağımsız olarak yüklendiğinde, derlemenin tüm bağımlılıkları konumlandırılıp yüklenmelidir çünkü etki alanından bağımsız olarak yüklenemeyen bir bağımlılık, derlemenin etki alanından bağımsız olarak yüklenmesini engeller.</span><span class="sxs-lookup"><span data-stu-id="2a152-181">All the dependencies of an assembly must be located and loaded when the assembly is loaded domain-neutral, because a dependency that cannot be loaded domain-neutral prevents the assembly from being loaded domain-neutral.</span></span>  
  
## <a name="application-domains-and-threads"></a><span data-ttu-id="2a152-182">Uygulama Etki Alanları ve İş Parçacıkları</span><span class="sxs-lookup"><span data-stu-id="2a152-182">Application Domains and Threads</span></span>  
 <span data-ttu-id="2a152-183">Uygulama etki alanı güvenlik, sürüm, güvenilirlik ve yönetilen kodu kaldırılması için bir yalıtım sınırı oluşturur.</span><span class="sxs-lookup"><span data-stu-id="2a152-183">An application domain forms an isolation boundary for security, versioning, reliability, and unloading of managed code.</span></span> <span data-ttu-id="2a152-184">Bir iş parçacığı kod yürütmek için ortak dil çalışma zamanı tarafından kullanılan işletim sistemi yapıdır.</span><span class="sxs-lookup"><span data-stu-id="2a152-184">A thread is the operating system construct used by the common language runtime to execute code.</span></span> <span data-ttu-id="2a152-185">Çalışma zamanında, tüm yönetilen kod uygulama etki alanına yüklenir ve bir veya daha fazla yönetilen iş parçacığı tarafından çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="2a152-185">At run time, all managed code is loaded into an application domain and is run by one or more managed threads.</span></span>  
  
 <span data-ttu-id="2a152-186">Uygulama etki alanları ve iş parçacıkları arasında bire bir bağıntı değil.</span><span class="sxs-lookup"><span data-stu-id="2a152-186">There is not a one-to-one correlation between application domains and threads.</span></span> <span data-ttu-id="2a152-187">Birkaç iş parçacığı bir tek bir uygulama etki alanındaki herhangi bir zamanda çalıştırabilirsiniz ve belirli bir iş parçacığı tek bir uygulama etki alanı için sınırlı değildir.</span><span class="sxs-lookup"><span data-stu-id="2a152-187">Several threads can execute in a single application domain at any given time, and a particular thread is not confined to a single application domain.</span></span> <span data-ttu-id="2a152-188">Diğer bir deyişle, iş parçacığı uygulama etki alanı sınırları arası boş; Yeni bir iş parçacığı her uygulama etki alanı için oluşturulmamış.</span><span class="sxs-lookup"><span data-stu-id="2a152-188">That is, threads are free to cross application domain boundaries; a new thread is not created for each application domain.</span></span>  
  
 <span data-ttu-id="2a152-189">Belirli bir zamanda, her iş parçacığı bir uygulama etki alanında yürütür.</span><span class="sxs-lookup"><span data-stu-id="2a152-189">At any given time, every thread executes in an application domain.</span></span> <span data-ttu-id="2a152-190">Sıfır, bir veya birden çok iş parçacığı herhangi belirli uygulama etki alanında yürütülüyor.</span><span class="sxs-lookup"><span data-stu-id="2a152-190">Zero, one, or multiple threads might be executing in any given application domain.</span></span> <span data-ttu-id="2a152-191">Çalışma zamanında hangi uygulama etki alanında çalışan hangi iş parçacığı izler.</span><span class="sxs-lookup"><span data-stu-id="2a152-191">The run time keeps track of which threads are running in which application domains.</span></span> <span data-ttu-id="2a152-192">Etki alanı içinde bir iş parçacığı Yürütülüyor herhangi bir zamanda çağırarak bulabilir <xref:System.Threading.Thread.GetDomain%2A?displayProperty=nameWithType> yöntemi.</span><span class="sxs-lookup"><span data-stu-id="2a152-192">You can locate the domain in which a thread is executing at any time by calling the <xref:System.Threading.Thread.GetDomain%2A?displayProperty=nameWithType> method.</span></span>  
  
### <a name="application-domains-and-cultures"></a><span data-ttu-id="2a152-193">Uygulama etki alanları ve kültürler</span><span class="sxs-lookup"><span data-stu-id="2a152-193">Application Domains and Cultures</span></span>  
 <span data-ttu-id="2a152-194">Tarafından temsil edilen kültür bir <xref:System.Globalization.CultureInfo> nesnesi, iş parçacığı ile ilişkilidir.</span><span class="sxs-lookup"><span data-stu-id="2a152-194">Culture, which is represented by a <xref:System.Globalization.CultureInfo> object, is associated with threads.</span></span> <span data-ttu-id="2a152-195">Kullanarak şu anda yürütülen iş parçacığı ile ilişkilendirilen kültür alabilirsiniz <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> özelliği ve almak veya ayarlamak kullanarak şu anda yürütülen iş parçacığı ile ilişkilendirilen kültür <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> özelliği.</span><span class="sxs-lookup"><span data-stu-id="2a152-195">You can get the culture that is associated with the currently executing thread by using the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property, and you can get or set the culture that is associated with the currently executing thread by using the <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="2a152-196">İş parçacığı ile ilişkili kültürü kullanarak açıkça ayarlanmış <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> özelliği, devam iş parçacığı uygulama etki alanı sınırları kestiği zaman bu iş parçacığı ile ilişkilendirilecek.</span><span class="sxs-lookup"><span data-stu-id="2a152-196">If the culture that is associated with a thread has been explicitly set by using the <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> property, it continues to be associated with that thread when the thread crosses application domain boundaries.</span></span> <span data-ttu-id="2a152-197">Aksi takdirde, herhangi bir zamanda iş parçacığı ile ilişkilendirilen kültür değeri olarak belirlenir <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> iş parçacığı Yürütülüyor uygulama etki alanındaki özelliğin:</span><span class="sxs-lookup"><span data-stu-id="2a152-197">Otherwise, the culture that is associated with the thread at any given time is determined by the value of the <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> property in the application domain in which the thread is executing:</span></span>  
  
-   <span data-ttu-id="2a152-198">Özelliğinin değeri değilse `null`, özellik tarafından döndürülen iş parçacığı ile ilişkili kültürdür (ve bu nedenle tarafından döndürülen <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> ve <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> özellikleri).</span><span class="sxs-lookup"><span data-stu-id="2a152-198">If the value of the property is not `null`, the culture that is returned by the property is associated with the thread (and therefore returned by the <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> properties).</span></span>  
  
-   <span data-ttu-id="2a152-199">Özelliğinin değeri ise `null`, geçerli sistem kültürü iş parçacığı ile ilişkilidir.</span><span class="sxs-lookup"><span data-stu-id="2a152-199">If the value of the property is `null`, the current system culture is associated with the thread.</span></span>  
  
## <a name="programming-with-application-domains"></a><span data-ttu-id="2a152-200">Uygulama Etki Alanlarıyla Programlama</span><span class="sxs-lookup"><span data-stu-id="2a152-200">Programming with Application Domains</span></span>  
 <span data-ttu-id="2a152-201">Uygulama etki alanları genellikle programlı olarak çalışma zamanı ana bilgisayarları tarafından oluşturulur ve değiştirilir.</span><span class="sxs-lookup"><span data-stu-id="2a152-201">Application domains are usually created and manipulated programmatically by runtime hosts.</span></span> <span data-ttu-id="2a152-202">Ancak, bazen bir uygulama programı da uygulama etki alanları ile birlikte çalışmak isteyebilir.</span><span class="sxs-lookup"><span data-stu-id="2a152-202">However, sometimes an application program might also want to work with application domains.</span></span> <span data-ttu-id="2a152-203">Örneğin, bir uygulama programı, tüm uygulamayı durdurmasına gerek kalmadan etki alanını (ve bileşeni) kaldırabilmek için bir etki alanına bir uygulama bileşeni yükleyebilir.</span><span class="sxs-lookup"><span data-stu-id="2a152-203">For example, an application program could load an application component into a domain to be able to unload the domain (and the component) without having to stop the entire application.</span></span>  
  
 <span data-ttu-id="2a152-204"><xref:System.AppDomain> Uygulama etki alanları için programlama arabirimidir.</span><span class="sxs-lookup"><span data-stu-id="2a152-204">The <xref:System.AppDomain> is the programmatic interface to application domains.</span></span> <span data-ttu-id="2a152-205">Bu sınıf, etki alanları oluşturmak ve kaldırmak, etki alanlarında türlerin örneklerini oluşturmak ve uygulama etki alanı kaldırma gibi belirli bildirimlere kaydolmak için metotlar içerir.</span><span class="sxs-lookup"><span data-stu-id="2a152-205">This class includes methods to create and unload domains, to create instances of types in domains, and to register for various notifications such as application domain unloading.</span></span> <span data-ttu-id="2a152-206">Aşağıdaki tabloda yaygın olarak kullanılan <xref:System.AppDomain> yöntemleri.</span><span class="sxs-lookup"><span data-stu-id="2a152-206">The following table lists commonly used <xref:System.AppDomain> methods.</span></span>  
  
|<span data-ttu-id="2a152-207">AppDomain Yöntemi</span><span class="sxs-lookup"><span data-stu-id="2a152-207">AppDomain Method</span></span>|<span data-ttu-id="2a152-208">Açıklama</span><span class="sxs-lookup"><span data-stu-id="2a152-208">Description</span></span>|  
|----------------------|-----------------|  
|<xref:System.AppDomain.CreateDomain%2A>|<span data-ttu-id="2a152-209">Yeni bir uygulama etki alanı oluşturur.</span><span class="sxs-lookup"><span data-stu-id="2a152-209">Creates a new application domain.</span></span> <span data-ttu-id="2a152-210">Bu yöntemin bir <xref:System.AppDomainSetup> nesnesi belirten bir aşırı yüklemesini kullanmanız önerilir.</span><span class="sxs-lookup"><span data-stu-id="2a152-210">It is recommended that you use an overload of this method that specifies an <xref:System.AppDomainSetup> object.</span></span> <span data-ttu-id="2a152-211">Bu; yeni bir etki alanının uygulama temel dizini veya uygulamanın kök dizini, etki alanı için yapılandırma dosyasının konumu ve ortak dil çalışma zamanının etki alanına yeni derlemeler yüklemek için kullanacağı arama yolu gibi özelliklerini ayarlamak için tercih edilen yöntemdir.</span><span class="sxs-lookup"><span data-stu-id="2a152-211">This is the preferred way to set the properties of a new domain, such as the application base, or root directory for the application; the location of the configuration file for the domain; and the search path that the common language runtime is to use to load assemblies into the domain.</span></span>|  
|<span data-ttu-id="2a152-212"><xref:System.AppDomain.ExecuteAssembly%2A> Ve <xref:System.AppDomain.ExecuteAssemblyByName%2A></span><span class="sxs-lookup"><span data-stu-id="2a152-212"><xref:System.AppDomain.ExecuteAssembly%2A> and <xref:System.AppDomain.ExecuteAssemblyByName%2A></span></span>|<span data-ttu-id="2a152-213">Uygulama etki alanındaki bir derlemeyi yürütür.</span><span class="sxs-lookup"><span data-stu-id="2a152-213">Executes an assembly in the application domain.</span></span> <span data-ttu-id="2a152-214">Bu bir örnek yöntemi olduğundan, atıfta bulunduğunuz başka bir uygulama etki alanındaki kodu yürütmek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="2a152-214">This is an instance method, so it can be used to execute code in another application domain to which you have a reference.</span></span>|  
|<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>|<span data-ttu-id="2a152-215">Uygulama etki alanında belirtilen bir türün bir örneğini oluşturur ve bir proxy döndürür.</span><span class="sxs-lookup"><span data-stu-id="2a152-215">Creates an instance of a specified type in the application domain, and returns a proxy.</span></span> <span data-ttu-id="2a152-216">Oluşturulan türü içeren derlemenin, bu derlemeyi çağıran derlemeye yüklenmesini engellemek için kullanın.</span><span class="sxs-lookup"><span data-stu-id="2a152-216">Use this method to avoid loading the assembly containing the created type into the calling assembly.</span></span>|  
|<xref:System.AppDomain.Unload%2A>|<span data-ttu-id="2a152-217">Etki alanının düzgün bir şekilde kapatılmasını gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="2a152-217">Performs a graceful shutdown of the domain.</span></span> <span data-ttu-id="2a152-218">Uygulama etki alanı, etki alanındaki tüm iş parçacıkları durmadan veya etki alanının dışında olmadan kaldırılmaz.</span><span class="sxs-lookup"><span data-stu-id="2a152-218">The application domain is not unloaded until all threads running in the domain have either stopped or are no longer in the domain.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="2a152-219">Ortak dil çalışma zamanı, genel yöntemlerin serileştirilmesini desteklemediğinden, temsilciler kullanılarak diğer uygulama etki alanlarındaki genel yöntemler yürütülemez.</span><span class="sxs-lookup"><span data-stu-id="2a152-219">The common language runtime does not support serialization of global methods, so delegates cannot be used to execute global methods in other application domains.</span></span>  
  
 <span data-ttu-id="2a152-220">Ortak dil çalışma zamanı Ana Bilgisayarları Arabirimleri Bildirimi'nde açıklanan yönetilmeyen arabirimler de uygulama etki alanlarına erişim sağlar.</span><span class="sxs-lookup"><span data-stu-id="2a152-220">The unmanaged interfaces described in the common language runtime Hosting Interfaces Specification also provide access to application domains.</span></span> <span data-ttu-id="2a152-221">Çalışma zamanı ana bilgisayarları, yönetilmeyen koddan arabirimler kullanarak bir işlem içinde uygulama etki alanları oluşturabilir veya onlara erişebilir.</span><span class="sxs-lookup"><span data-stu-id="2a152-221">Runtime hosts can use interfaces from unmanaged code to create and gain access to the application domains within a process.</span></span>  
  
## <a name="complusloaderoptimization-environment-variable"></a><span data-ttu-id="2a152-222">COMPLUS_LoaderOptimization Ortam Değişkeni</span><span class="sxs-lookup"><span data-stu-id="2a152-222">COMPLUS_LoaderOptimization Environment Variable</span></span>  
 <span data-ttu-id="2a152-223">Yürütülebilir uygulamanın varsayılan yükleyicisi iyileştirme ilkesini ayarlar bir ortam değişkeni.</span><span class="sxs-lookup"><span data-stu-id="2a152-223">An environment variable that sets the default loader optimization policy of an executable application.</span></span>  
  
### <a name="syntax"></a><span data-ttu-id="2a152-224">Sözdizimi</span><span class="sxs-lookup"><span data-stu-id="2a152-224">Syntax</span></span>  
  
```  
COMPLUS_LoaderOptimization = 1  
```  
  
### <a name="remarks"></a><span data-ttu-id="2a152-225">Açıklamalar</span><span class="sxs-lookup"><span data-stu-id="2a152-225">Remarks</span></span>  
 <span data-ttu-id="2a152-226">Tipik bir uygulama içerdikleri kod yürütülebilmesi birkaç derlemeleri uygulama etki alanına yükler.</span><span class="sxs-lookup"><span data-stu-id="2a152-226">A typical application loads several assemblies into an application domain before the code they contain can be executed.</span></span>  
  
 <span data-ttu-id="2a152-227">Derleme yüklenmiş şekilde kendi tam zamanında (JIT) derlenmiş kod olup olmadığını belirler işlemde birden çok uygulama etki alanları tarafından paylaşılabilir.</span><span class="sxs-lookup"><span data-stu-id="2a152-227">The way the assembly is loaded determines whether its just-in-time (JIT) compiled code can be shared by multiple application domains in the process.</span></span>  
  
-   <span data-ttu-id="2a152-228">Bir derlemeyi yüklenen etki alanı neutral ise, aynı güvenlik verme kümesi paylaşan tüm uygulama etki alanları aynı JIT derlenmiş kod paylaşabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2a152-228">If an assembly is loaded domain-neutral, all application domains that share the same security grant set can share the same JIT-compiled code.</span></span> <span data-ttu-id="2a152-229">Bu uygulama tarafından gerekli bellek azaltır.</span><span class="sxs-lookup"><span data-stu-id="2a152-229">This reduces the memory required by the application.</span></span>  
  
-   <span data-ttu-id="2a152-230">Bir derlemeyi yüklenen etki alanı Tarafsız değilse, bu yüklendiği ve yükleyicisi uygulama etki alanları arasında iç kaynaklara paylaşmamalıdır her uygulama etki alanındaki JIT derlenmiş olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="2a152-230">If an assembly is not loaded domain-neutral, it must be JIT-compiled in every application domain in which it is loaded and the loader must not share internal resources across application domains.</span></span>  
  
 <span data-ttu-id="2a152-231">1 olarak ayarlandığında, çalışma zamanı ana bilgisayarı etki alanından bağımsız şekilde SingleDomain bilinen tüm derlemeleri yüklemeye COMPLUS_LoaderOptimization ortamı bayrak zorlar.</span><span class="sxs-lookup"><span data-stu-id="2a152-231">When set to 1, the COMPLUS_LoaderOptimization environment flag forces the runtime host to load all assemblies in non-domain-neutral way known as SingleDomain.</span></span> <span data-ttu-id="2a152-232">SingleDomain hiçbir derlemeleri her zaman etki alanı Tarafsız yüklenen Mscorlib dışında etki alanı Tarafsız olarak yükler.</span><span class="sxs-lookup"><span data-stu-id="2a152-232">SingleDomain loads no assemblies as domain-neutral, except Mscorlib, which is always loaded domain-neutral.</span></span> <span data-ttu-id="2a152-233">Ana bilgisayar işleminde yalnızca tek bir uygulama çalışırken sık kullanıldığı için bu ayar tek etki alanı adı verilir.</span><span class="sxs-lookup"><span data-stu-id="2a152-233">This setting is called single domain because it is commonly used when the host is running only a single application in the process.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="2a152-234">COMPLUS_LoaderOptimization ortam bayrağı tanı kullanılmak üzere tasarlanmış ve test senaryoları.</span><span class="sxs-lookup"><span data-stu-id="2a152-234">The COMPLUS_LoaderOptimization environment flag was designed to be used in diagnostic and test scenarios.</span></span> <span data-ttu-id="2a152-235">Açık bayrağı sahip Ciddi konumlanır neden ve bellek kullanımını artırır.</span><span class="sxs-lookup"><span data-stu-id="2a152-235">Having the flag turned on can cause severe slow-down and increase in memory usage.</span></span>  
  
### <a name="code-example"></a><span data-ttu-id="2a152-236">Kod Örneği</span><span class="sxs-lookup"><span data-stu-id="2a152-236">Code Example</span></span>  
 <span data-ttu-id="2a152-237">Yüklenmeyeceğini tüm derlemeler için IISADMİN olarak etki alanı Tarafsız zorlamak için hizmet eklenerek elde edilebilir `COMPLUS_LoaderOptimization=1` HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\IISADMIN anahtarında ortamı çok dizeli değer.</span><span class="sxs-lookup"><span data-stu-id="2a152-237">To force all assemblies not to be loaded as domain-neutral for the IISADMIN service can be achieved by appending `COMPLUS_LoaderOptimization=1` to the Environment’s Multi-String Value in the HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\IISADMIN key.</span></span>  
  
```  
Key = HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\IISADMIN  
Name = Environment  
Type = REG_MULTI_SZ  
Value (to append) = COMPLUS_LoaderOptimization=1  
```  
  
<a name="reference"></a>   
## <a name="reference"></a><span data-ttu-id="2a152-238">Başvuru</span><span class="sxs-lookup"><span data-stu-id="2a152-238">Reference</span></span>  
 <xref:System.MarshalByRefObject?displayProperty=nameWithType>
