---
title: loaderLock MDA
ms.date: 03/30/2017
helpviewer_keywords:
- deadlocks [.NET Framework]
- LoaderLock MDA
- MDAs (managed debugging assistants), loader locks
- managed debugging assistants (MDAs), loader locks
- operating system loader locks
- loader locks
- locks, threads
ms.assetid: 8c10fa02-1b9c-4be5-ab03-451d943ac1ee
author: mairaw
ms.author: mairaw
ms.openlocfilehash: c3e8769ec972ec76d04d2f22368fdde99de9c6de
ms.sourcegitcommit: 289e06e904b72f34ac717dbcc5074239b977e707
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 09/17/2019
ms.locfileid: "71052541"
---
# <a name="loaderlock-mda"></a><span data-ttu-id="a7a70-102">loaderLock MDA</span><span class="sxs-lookup"><span data-stu-id="a7a70-102">loaderLock MDA</span></span>
<span data-ttu-id="a7a70-103">Yönetilen `loaderLock` hata ayıklama Yardımcısı (MDA), Microsoft Windows işletim sistemi yükleyicisi kilidini tutan bir iş parçacığında yönetilen kodu yürütme girişimlerini algılar.</span><span class="sxs-lookup"><span data-stu-id="a7a70-103">The `loaderLock` managed debugging assistant (MDA) detects attempts to execute managed code on a thread that holds the Microsoft Windows operating system loader lock.</span></span>  <span data-ttu-id="a7a70-104">Bu tür bir yürütme kilitlenmeyle sonuçlanabileceğinden ve DLL 'lerin işletim sistemi yükleyicisi tarafından başlatılmadan önce kullanabilmesi nedeniyle geçersizdir.</span><span class="sxs-lookup"><span data-stu-id="a7a70-104">Any such execution is illegal because it can lead to deadlocks and to use of DLLs before they have been initialized by the operating system's loader.</span></span>  
  
## <a name="symptoms"></a><span data-ttu-id="a7a70-105">Belirtiler</span><span class="sxs-lookup"><span data-stu-id="a7a70-105">Symptoms</span></span>  
 <span data-ttu-id="a7a70-106">İşletim sisteminin yükleyici kilidi içinde kod yürütürken en yaygın hata, aynı zamanda yükleyici kilidi gerektiren diğer Win32 işlevlerini çağırmaya çalışırken iş parçacıklarının kilitlenmeleridir.</span><span class="sxs-lookup"><span data-stu-id="a7a70-106">The most common failure when executing code inside the operating system's loader lock is that threads will deadlock when attempting to call other Win32 functions that also require the loader lock.</span></span>  <span data-ttu-id="a7a70-107">`LoadLibrary`Bu işlevlere `GetProcAddress` örnekler,`GetModuleHandle`, ve. `FreeLibrary`</span><span class="sxs-lookup"><span data-stu-id="a7a70-107">Examples of such functions are `LoadLibrary`, `GetProcAddress`, `FreeLibrary`, and `GetModuleHandle`.</span></span>  <span data-ttu-id="a7a70-108">Uygulama bu işlevleri doğrudan çağırmayabilir; ortak dil çalışma zamanı (CLR), daha üst düzey bir çağrının <xref:System.Reflection.Assembly.Load%2A> veya platform çağırma yöntemine yapılan ilk çağrının sonucu olarak bu işlevleri çağırabilir.</span><span class="sxs-lookup"><span data-stu-id="a7a70-108">The application might not directly call these functions; the common language runtime (CLR) might call these functions as the result of a higher level call like <xref:System.Reflection.Assembly.Load%2A> or the first call to a platform invoke method.</span></span>  
  
 <span data-ttu-id="a7a70-109">Kilitlenmeler Ayrıca bir iş parçacığının başlamasını veya bitmesini bekliyorsa meydana gelebilir.</span><span class="sxs-lookup"><span data-stu-id="a7a70-109">Deadlocks can also occur if a thread is waiting for another thread to start or finish.</span></span>  <span data-ttu-id="a7a70-110">Bir iş parçacığı başladığında veya yürütmeyi bitirdiğinde, etkilenen dll 'lere olay göndermek için işletim sisteminin yükleyici kilidini almalıdır.</span><span class="sxs-lookup"><span data-stu-id="a7a70-110">When a thread starts or finishes executing, it must acquire the operating system's loader lock to deliver events to affected DLLs.</span></span>  
  
 <span data-ttu-id="a7a70-111">Son olarak, dll 'lere yapılan çağrıların işletim sisteminin yükleyicisi tarafından düzgün bir şekilde başlatılmadan önce gerçekleşebileceği durumlar vardır.</span><span class="sxs-lookup"><span data-stu-id="a7a70-111">Finally, there are cases where calls into DLLs can occur before those DLLs have been properly initialized by the operating system's loader.</span></span>  <span data-ttu-id="a7a70-112">Kilitlenmede yer alan tüm iş parçacıklarının yığınlarını inceleyerek tanılanabilir kilitlenme hatalarından farklı olarak, bu MDA ' ı kullanmadan başlatılmamış dll 'lerin kullanımını tanılamak çok zordur.</span><span class="sxs-lookup"><span data-stu-id="a7a70-112">Unlike the deadlock failures, which can be diagnosed by examining the stacks of all the threads involved in the deadlock, it is very difficult to diagnose the use of uninitialized DLLs without using this MDA.</span></span>  
  
## <a name="cause"></a><span data-ttu-id="a7a70-113">Sebep</span><span class="sxs-lookup"><span data-stu-id="a7a70-113">Cause</span></span>  
 <span data-ttu-id="a7a70-114">1,0 veya 1,1 sürümleri C++ .NET Framework için oluşturulan karma yönetilen/yönetilmeyen derlemeler genellikle özel bir bakım yapılmadığı takdirde (örneğin, **/NOENTRY**ile bağlantı kurarak), yükleyici kilidi içinde yönetilen kodu yürütmeye çalışır.</span><span class="sxs-lookup"><span data-stu-id="a7a70-114">Mixed managed/unmanaged C++ assemblies built for .NET Framework versions 1.0 or 1.1 generally attempt to execute managed code inside the loader lock unless special care has been taken, for example, linking with **/NOENTRY**.</span></span>
  
 <span data-ttu-id="a7a70-115">.NET Framework sürüm 2,0 için C++ derlenmiş, karışık yönetilen/yönetilmeyen derlemeler bu sorunlara açıktır ve bu sorunlar, işletim sisteminin kurallarını ihlal eden yönetilmeyen DLL 'leri kullanan uygulamalarla aynı risk azalmasına sahip olacak şekilde daha düşüktür.</span><span class="sxs-lookup"><span data-stu-id="a7a70-115">Mixed managed/unmanaged C++ assemblies built for .NET Framework version 2.0 are less susceptible to these problems, having the same reduced risk as applications using unmanaged DLLs that violate the operating system's rules.</span></span>  <span data-ttu-id="a7a70-116">Örneğin, yönetilmeyen bir dll 'nin `DllMain` giriş noktası com 'a sunulan yönetilen bir nesne almak için çağırırsa `CoCreateInstance` , bu, yükleyici kilidi içinde yönetilen kodu yürütmeye çalışır.</span><span class="sxs-lookup"><span data-stu-id="a7a70-116">For example, if an unmanaged DLL's `DllMain` entry point calls `CoCreateInstance` to obtain a managed object that has been exposed to COM, the result is an attempt to execute managed code inside the loader lock.</span></span> <span data-ttu-id="a7a70-117">.NET Framework sürüm 2,0 ve sonraki sürümlerde yükleyici kilit sorunları hakkında daha fazla bilgi için bkz. [karışık derlemeleri başlatma](/cpp/dotnet/initialization-of-mixed-assemblies).</span><span class="sxs-lookup"><span data-stu-id="a7a70-117">For more information about loader lock issues in the .NET Framework version 2.0 and later, see [Initialization of Mixed Assemblies](/cpp/dotnet/initialization-of-mixed-assemblies).</span></span>  
  
## <a name="resolution"></a><span data-ttu-id="a7a70-118">Çözüm</span><span class="sxs-lookup"><span data-stu-id="a7a70-118">Resolution</span></span>  
 <span data-ttu-id="a7a70-119">Visual C++ .NET 2002 ve Visual C++ .NET 2003 ' de, `/clr` derleyici seçeneği ile derlenen dll 'ler yüklendiğinde belirleyici olmayan biçimde kilitlenmeye neden olabilir; bu sorun, karışık dll yükleme veya yükleyici kilit sorunu olarak adlandırılmıştı.</span><span class="sxs-lookup"><span data-stu-id="a7a70-119">In Visual C++ .NET 2002 and Visual C++ .NET 2003, DLLs compiled with the `/clr` compiler option could non-deterministically deadlock when loaded; this issue was called the mixed DLL loading or loader lock issue.</span></span> <span data-ttu-id="a7a70-120">Visual C++ 2005 ve üzeri sürümlerde, neredeyse tüm belirleyici olmayan ISM, karışık dll yükleme işleminden kaldırılmıştır.</span><span class="sxs-lookup"><span data-stu-id="a7a70-120">In Visual C++ 2005 and later, almost all non-determinism has been removed from the mixed DLL loading process.</span></span> <span data-ttu-id="a7a70-121">Ancak, yükleyici kilidinin (belirleyici) meydana olabileceği birkaç senaryo vardır.</span><span class="sxs-lookup"><span data-stu-id="a7a70-121">However, there are a few remaining scenarios for which loader lock can (deterministically) occur.</span></span> <span data-ttu-id="a7a70-122">Kalan yükleyici kilidi sorunları için nedenler ve çözümlerin ayrıntılı bir hesabı için bkz. [karışık derlemeler başlatma](/cpp/dotnet/initialization-of-mixed-assemblies).</span><span class="sxs-lookup"><span data-stu-id="a7a70-122">For a detailed account of the causes and resolutions for the remaining loader lock issues, see [Initialization of Mixed Assemblies](/cpp/dotnet/initialization-of-mixed-assemblies).</span></span> <span data-ttu-id="a7a70-123">Bu konu, yükleyici kilit sorununuzu tanımlamadığı takdirde, yükleyici kilidinin neden gerçekleştiğini ve sorunu nasıl düzelteceğini belirlemek için iş parçacığının yığınını incelemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="a7a70-123">If that topic does not identify your loader lock problem, you have to examine the thread's stack to determine why the loader lock is occurring and how to correct the problem.</span></span> <span data-ttu-id="a7a70-124">Bu MDA ' i etkinleştiren iş parçacığı için yığın izlemesine bakın.</span><span class="sxs-lookup"><span data-stu-id="a7a70-124">Look at the stack trace for the thread that has activated this MDA.</span></span>  <span data-ttu-id="a7a70-125">İş parçacığı, işletim sisteminin yükleyici kilidini tutarken yönetilen koda geçersiz şekilde çağrı yapmaya çalışıyor.</span><span class="sxs-lookup"><span data-stu-id="a7a70-125">The thread is attempting to illegally call into managed code while holding the operating system's loader lock.</span></span>  <span data-ttu-id="a7a70-126">Büyük olasılıkla yığında bir dll `DllMain` veya denk giriş noktası görürsünüz.</span><span class="sxs-lookup"><span data-stu-id="a7a70-126">You will probably see a DLL's `DllMain` or equivalent entry point on the stack.</span></span>  <span data-ttu-id="a7a70-127">Bu tür bir giriş noktasının içinden yasal olarak yapabilecekleri, işletim sisteminin kuralları sınırlı değildir.</span><span class="sxs-lookup"><span data-stu-id="a7a70-127">The operating system's rules for what you can legally do from inside such an entry point are quite limited.</span></span>  <span data-ttu-id="a7a70-128">Bu kurallar, yönetilen yürütmeyi de halden daha fazla.</span><span class="sxs-lookup"><span data-stu-id="a7a70-128">These rules preclude any managed execution.</span></span>  
  
## <a name="effect-on-the-runtime"></a><span data-ttu-id="a7a70-129">Çalışma zamanında etki</span><span class="sxs-lookup"><span data-stu-id="a7a70-129">Effect on the Runtime</span></span>  
 <span data-ttu-id="a7a70-130">Genellikle, işlem içindeki birkaç iş parçacığı kilitlenir.</span><span class="sxs-lookup"><span data-stu-id="a7a70-130">Typically, several threads inside the process will deadlock.</span></span>  <span data-ttu-id="a7a70-131">Bu iş parçacıklarından biri, çöp toplama gerçekleştirmekten sorumlu bir iş parçacığı olabilir, bu nedenle bu kilitlenme işlemin tamamına büyük bir etkiye sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="a7a70-131">One of those threads is likely to be a thread responsible for performing a garbage collection, so this deadlock can have a major impact on the entire process.</span></span>  <span data-ttu-id="a7a70-132">Ayrıca, derleme ve DLL 'Leri yükleme ve kaldırma, iş parçacıklarını başlatma veya durdurma gibi işletim sisteminin yükleyici kilidi gerektiren ek işlemleri de engeller.</span><span class="sxs-lookup"><span data-stu-id="a7a70-132">Furthermore, it will prevent any additional operations that require the operating system's loader lock, like loading and unloading assemblies or DLLs and starting or stopping threads.</span></span>  
  
 <span data-ttu-id="a7a70-133">Bazı Olağandışı durumlarda, erişim ihlalleri veya benzer sorunların, başlatılmadan önce çağrılan dll 'lerde tetiklenmesi de mümkündür.</span><span class="sxs-lookup"><span data-stu-id="a7a70-133">In some unusual cases, it is also possible for access violations or similar problems to be triggered in DLLs which are called before they have been initialized.</span></span>  
  
## <a name="output"></a><span data-ttu-id="a7a70-134">Çıkış</span><span class="sxs-lookup"><span data-stu-id="a7a70-134">Output</span></span>  
 <span data-ttu-id="a7a70-135">Bu MDA geçersiz bir yönetilen yürütmenin denenmekte olduğunu bildirir.</span><span class="sxs-lookup"><span data-stu-id="a7a70-135">This MDA reports that an illegal managed execution is being attempted.</span></span>  <span data-ttu-id="a7a70-136">Yükleyici kilidinin neden gerçekleştiğini ve sorunu nasıl düzelteceğini öğrenmek için iş parçacığının yığınını incelemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="a7a70-136">You need to examine the thread's stack to determine why the loader lock is occurring and how to correct the problem.</span></span>  
  
## <a name="configuration"></a><span data-ttu-id="a7a70-137">Yapılandırma</span><span class="sxs-lookup"><span data-stu-id="a7a70-137">Configuration</span></span>  
  
```xml  
<mdaConfig>  
  <assistants>  
    <loaderLock/>  
  </assistants>  
</mdaConfig>  
```  
  
## <a name="see-also"></a><span data-ttu-id="a7a70-138">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="a7a70-138">See also</span></span>

- [<span data-ttu-id="a7a70-139">Yönetilen Hata Ayıklama Yardımcıları ile Hataları Tanılama</span><span class="sxs-lookup"><span data-stu-id="a7a70-139">Diagnosing Errors with Managed Debugging Assistants</span></span>](diagnosing-errors-with-managed-debugging-assistants.md)
