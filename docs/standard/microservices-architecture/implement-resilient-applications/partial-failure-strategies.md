---
title: Kısmi hata işleme stratejileri
description: Kısmi hataları düzgün bir şekilde işlemek için çeşitli stratejileri tanışın.
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/16/2018
ms.openlocfilehash: ad45e357c1656b9346b7bdb5f324bde5fa76eaba
ms.sourcegitcommit: 542aa405b295955eb055765f33723cb8b588d0d0
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 01/17/2019
ms.locfileid: "54362775"
---
# <a name="strategies-to-handle-partial-failure"></a><span data-ttu-id="f6616-103">Kısmi hata işleme stratejileri</span><span class="sxs-lookup"><span data-stu-id="f6616-103">Strategies to handle partial failure</span></span>

<span data-ttu-id="f6616-104">Kısmi hatalarıyla ilgili stratejiler aşağıda verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="f6616-104">Strategies for dealing with partial failures include the following.</span></span>

<span data-ttu-id="f6616-105">**İç mikro hizmetler arasında zaman uyumsuz iletişim (örneğin, ileti tabanlı iletişim) kullanan**.</span><span class="sxs-lookup"><span data-stu-id="f6616-105">**Use asynchronous communication (for example, message-based communication) across internal microservices**.</span></span> <span data-ttu-id="f6616-106">Bu yanlış tasarım sonunda hatalı kesintiler ana nedenini olur çünkü zaman uyumlu HTTP çağrıları için uzun zincirleri iç mikro hizmetler arasında oluşturmamayı yüksek oranda önerilir.</span><span class="sxs-lookup"><span data-stu-id="f6616-106">It's highly advisable not to create long chains of synchronous HTTP calls across the internal microservices because that incorrect design will eventually become the main cause of bad outages.</span></span> <span data-ttu-id="f6616-107">Tam, istemci uygulamalar ve mikro hizmetler veya ayrıntılı API ağ geçitleri ilk düzeyi arasında ön uç iletişim dışında (yalnızca zaman uyumsuz ileti tabanlı) iletişim ilk istek son kez kullanılması önerilir / İç mikro hizmetler arasında yanıt döngüsü.</span><span class="sxs-lookup"><span data-stu-id="f6616-107">On the contrary, except for the front-end communications between the client applications and the first level of microservices or fine-grained API Gateways, it's recommended to use only asynchronous (message-based) communication once past the initial request/response cycle, across the internal microservices.</span></span> <span data-ttu-id="f6616-108">Son tutarlılık ve olaya dayalı mimariler ripple etkileri en aza indirmek için yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="f6616-108">Eventual consistency and event-driven architectures will help to minimize ripple effects.</span></span> <span data-ttu-id="f6616-109">Bu yaklaşımların mikro hizmet bağımsız çalışma sınırı daha yüksek bir düzeyde uygulamak ve bu nedenle burada bahsedilen sorun karşı önleme.</span><span class="sxs-lookup"><span data-stu-id="f6616-109">These approaches enforce a higher level of microservice autonomy and therefore prevent against the problem noted here.</span></span>

<span data-ttu-id="f6616-110">**Üstel geri alma ile yeniden denemeleri kullanma**.</span><span class="sxs-lookup"><span data-stu-id="f6616-110">**Use retries with exponential backoff**.</span></span> <span data-ttu-id="f6616-111">Bu teknik kısa kaçınmaya yardımcı olur ve çağrı yaparak aralıklı hatalar yalnızca kısa bir süre için hizmet kullanılamıyor durumunda belirli sayıda bir kez yeniden dener.</span><span class="sxs-lookup"><span data-stu-id="f6616-111">This technique helps to avoid short and intermittent failures by performing call retries a certain number of times, in case the service was not available only for a short time.</span></span> <span data-ttu-id="f6616-112">Bu, aralıklı ağ sorunlarından kaynaklanan veya bir mikro hizmet/kapsayıcı farklı bir düğüme bir küme içinde taşındığında ortaya çıkabilir.</span><span class="sxs-lookup"><span data-stu-id="f6616-112">This might occur due to intermittent network issues or when a microservice/container is moved to a different node in a cluster.</span></span> <span data-ttu-id="f6616-113">Bu yeniden deneme devre Kesiciler ile düzgün şekilde tasarlanmamıştır, ancak bunu ripple etkileri aggravate sonuçta bile neden olan bir [hizmet reddi (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span><span class="sxs-lookup"><span data-stu-id="f6616-113">However, if these retries are not designed properly with circuit breakers, it can aggravate the ripple effects, ultimately even causing a [Denial of Service (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span></span>

<span data-ttu-id="f6616-114">**Ağ zaman aşımı geçici**.</span><span class="sxs-lookup"><span data-stu-id="f6616-114">**Work around network timeouts**.</span></span> <span data-ttu-id="f6616-115">Genel olarak, istemciler süresiz olarak Engellemesi değil ve her zaman bir yanıtı beklenirken zaman aşımı kullanacak şekilde tasarlanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="f6616-115">In general, clients should be designed not to block indefinitely and to always use timeouts when waiting for a response.</span></span> <span data-ttu-id="f6616-116">Zaman aşımı kullanarak kaynakları hiçbir zaman süresiz olarak bağlı olduğunu sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6616-116">Using timeouts ensures that resources are never tied up indefinitely.</span></span>

<span data-ttu-id="f6616-117">**Devre kesici düzeni kullanmak**.</span><span class="sxs-lookup"><span data-stu-id="f6616-117">**Use the Circuit Breaker pattern**.</span></span> <span data-ttu-id="f6616-118">Bu yaklaşımda, istemci işlemi başarısız istek sayısını izler.</span><span class="sxs-lookup"><span data-stu-id="f6616-118">In this approach, the client process tracks the number of failed requests.</span></span> <span data-ttu-id="f6616-119">Daha fazla denemeleri hemen başarısız olduğunu hata oranı "devre kesici" gelişlerin yapılandırılmış bir sınır aşarsa.</span><span class="sxs-lookup"><span data-stu-id="f6616-119">If the error rate exceeds a configured limit, a “circuit breaker” trips so that further attempts fail immediately.</span></span> <span data-ttu-id="f6616-120">(Çok sayıda istek başarısız oluyorsa, hizmet kullanılamıyor ve istekleri gönderirken anlamsız olduğunu önerir.) Bir zaman aşımı süresinden sonra istemci yeniden deneyin ve gerekir, yeni istekler başarılı olursa, devre kesici kapatılır.</span><span class="sxs-lookup"><span data-stu-id="f6616-120">(If a large number of requests are failing, that suggests the service is unavailable and that sending requests is pointless.) After a timeout period, the client should try again and, if the new requests are successful, close the circuit breaker.</span></span>

<span data-ttu-id="f6616-121">**Geri dönüşleri sağlamak**.</span><span class="sxs-lookup"><span data-stu-id="f6616-121">**Provide fallbacks**.</span></span> <span data-ttu-id="f6616-122">Önbelleğe alınmış verileri veya varsayılan değeri döndürme gibi bir istek başarısız olduğunda bu yaklaşımda, geri dönüş mantığı istemci işlemini gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="f6616-122">In this approach, the client process performs fallback logic when a request fails, such as returning cached data or a default value.</span></span> <span data-ttu-id="f6616-123">Bu sorgular için uygun bir yaklaşım ve güncelleştirmeleri veya komutları için daha karmaşıktır.</span><span class="sxs-lookup"><span data-stu-id="f6616-123">This is an approach suitable for queries, and is more complex for updates or commands.</span></span>

<span data-ttu-id="f6616-124">**Kuyruğa alınan istekler sayısını sınırlayın**.</span><span class="sxs-lookup"><span data-stu-id="f6616-124">**Limit the number of queued requests**.</span></span> <span data-ttu-id="f6616-125">İstemciler ayrıca bir istemci bir mikro hizmet belirli bir hizmete gönderebilirsiniz bekleyen istek sayısı üst sınırı dayatır.</span><span class="sxs-lookup"><span data-stu-id="f6616-125">Clients should also impose an upper bound on the number of outstanding requests that a client microservice can send to a particular service.</span></span> <span data-ttu-id="f6616-126">Sınırına ulaşıldı, ek isteğinde bulunmak büyük olasılıkla anlamsız ve bu girişimler hemen başarısız olması.</span><span class="sxs-lookup"><span data-stu-id="f6616-126">If the limit has been reached, it's probably pointless to make additional requests, and those attempts should fail immediately.</span></span> <span data-ttu-id="f6616-127">Uygulama, Polly açısından [bölme perdesi yalıtım](https://github.com/App-vNext/Polly/wiki/Bulkhead) İlkesi, bu gereksinimi karşılamak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f6616-127">In terms of implementation, the Polly [Bulkhead Isolation](https://github.com/App-vNext/Polly/wiki/Bulkhead) policy can be used to fulfill this requirement.</span></span> <span data-ttu-id="f6616-128">Aslında bir paralelleştirme azaltma ile bu yaklaşım, <xref:System.Threading.SemaphoreSlim> uygulaması olarak.</span><span class="sxs-lookup"><span data-stu-id="f6616-128">This approach is essentially a parallelization throttle with <xref:System.Threading.SemaphoreSlim> as the implementation.</span></span> <span data-ttu-id="f6616-129">Bölme perdesi dışında bir "sıra" izin verir.</span><span class="sxs-lookup"><span data-stu-id="f6616-129">It also permits a "queue" outside the bulkhead.</span></span> <span data-ttu-id="f6616-130">(Örneğin, kapasite tam kabul edilir çünkü) aşırı yük yürütme önce proaktif olarak boşaltmaktır.</span><span class="sxs-lookup"><span data-stu-id="f6616-130">You can proactively shed excess load even before execution (for example, because capacity is deemed full).</span></span> <span data-ttu-id="f6616-131">Bu belirli hata senaryoları yanıtını hataları için devre kesici bekler olduğundan devre kesici, daha hızlı sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6616-131">This makes its response to certain failure scenarios faster than a circuit breaker would be, since the circuit breaker waits for the failures.</span></span> <span data-ttu-id="f6616-132">BulkheadPolicy nesnesinde [Polly](http://www.thepollyproject.org/) kullanıma sunan nasıl tam bölme perdesi ve sırası olduğu ve teklifler olayları taşmada bu nedenle de kullanılabilir sürücü otomatik yatay ölçekleme için.</span><span class="sxs-lookup"><span data-stu-id="f6616-132">The BulkheadPolicy object in [Polly](http://www.thepollyproject.org/) exposes how full the bulkhead and queue are, and offers events on overflow so can also be used to drive automated horizontal scaling.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="f6616-133">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="f6616-133">Additional resources</span></span>

- <span data-ttu-id="f6616-134">**Dayanıklılık desenleri**\\</span><span class="sxs-lookup"><span data-stu-id="f6616-134">**Resiliency patterns**\\</span></span>
  [*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](/azure/architecture/patterns/category/resiliency)

- <span data-ttu-id="f6616-135">**Dayanıklılık ekleme ve performansı en iyi duruma getirme**\\</span><span class="sxs-lookup"><span data-stu-id="f6616-135">**Adding Resilience and Optimizing Performance**\\</span></span>
  [*https://msdn.microsoft.com/library/jj591574.aspx*](https://msdn.microsoft.com/library/jj591574.aspx)

- <span data-ttu-id="f6616-136">**Bölme perdesi.**</span><span class="sxs-lookup"><span data-stu-id="f6616-136">**Bulkhead.**</span></span> <span data-ttu-id="f6616-137">GitHub deposu.</span><span class="sxs-lookup"><span data-stu-id="f6616-137">GitHub repo.</span></span> <span data-ttu-id="f6616-138">Polly ilke uygulamasıyla. \\</span><span class="sxs-lookup"><span data-stu-id="f6616-138">Implementation with Polly policy.\\</span></span>
  [*https://github.com/App-vNext/Polly/wiki/Bulkhead*](https://github.com/App-vNext/Polly/wiki/Bulkhead)

- <span data-ttu-id="f6616-139">**Azure için dayanıklı uygulamalar tasarlama**\\</span><span class="sxs-lookup"><span data-stu-id="f6616-139">**Designing resilient applications for Azure**\\</span></span>
  [*https://docs.microsoft.com/azure/architecture/resiliency/*](/azure/architecture/resiliency/)

- <span data-ttu-id="f6616-140">**Geçici hata işleme**\\</span><span class="sxs-lookup"><span data-stu-id="f6616-140">**Transient fault handling**\\</span></span>
  [*https://docs.microsoft.com/azure/architecture/best-practices/transient-faults*](/azure/architecture/best-practices/transient-faults)

>[!div class="step-by-step"]
><span data-ttu-id="f6616-141">[Önceki](handle-partial-failure.md)
>[İleri](implement-retries-exponential-backoff.md)</span><span class="sxs-lookup"><span data-stu-id="f6616-141">[Previous](handle-partial-failure.md)
[Next](implement-retries-exponential-backoff.md)</span></span>