---
title: Olay Tabanlı Zaman Uyumsuz Desen Uygulamak için En İyi Yöntemler
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- Event-based Asynchronous Pattern
- ProgressChangedEventArgs class
- BackgroundWorker component
- events [.NET Framework], asynchronous
- AsyncOperationManager class
- threading [.NET Framework], asynchronous features
- AsyncOperation class
- AsyncCompletedEventArgs class
ms.assetid: 4acd2094-4f46-4eff-9190-92d0d9ff47db
ms.openlocfilehash: 561d0759af4f7557bae39540cbb00f8038726ddc
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 08/22/2019
ms.locfileid: "69950802"
---
# <a name="best-practices-for-implementing-the-event-based-asynchronous-pattern"></a><span data-ttu-id="698d1-102">Olay Tabanlı Zaman Uyumsuz Desen Uygulamak için En İyi Yöntemler</span><span class="sxs-lookup"><span data-stu-id="698d1-102">Best Practices for Implementing the Event-based Asynchronous Pattern</span></span>
<span data-ttu-id="698d1-103">Olay tabanlı zaman uyumsuz model, tanıdık olay ve temsilci semantiğinin bulunduğu sınıflarda zaman uyumsuz davranışı açığa çıkarmak için etkili bir yol sağlar.</span><span class="sxs-lookup"><span data-stu-id="698d1-103">The Event-based Asynchronous Pattern provides you with an effective way to expose asynchronous behavior in classes, with familiar event and delegate semantics.</span></span> <span data-ttu-id="698d1-104">Olay tabanlı zaman uyumsuz model uygulamak için bazı belirli davranış gereksinimlerini izlemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="698d1-104">To implement Event-based Asynchronous Pattern, you need to follow some specific behavioral requirements.</span></span> <span data-ttu-id="698d1-105">Aşağıdaki bölümlerde, olay tabanlı zaman uyumsuz düzeniyle takip eden bir sınıfı uyguladığınızda göz önünde bulundurmanız gereken gereksinimler ve yönergeler açıklanır.</span><span class="sxs-lookup"><span data-stu-id="698d1-105">The following sections describe requirements and guidelines you should consider when you implement a class that follows the Event-based Asynchronous Pattern.</span></span>  
  
 <span data-ttu-id="698d1-106">Genel bakış için bkz. [olay tabanlı zaman uyumsuz model uygulama](../../../docs/standard/asynchronous-programming-patterns/implementing-the-event-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="698d1-106">For an overview, see [Implementing the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/implementing-the-event-based-asynchronous-pattern.md).</span></span>  
  
## <a name="required-behavioral-guarantees"></a><span data-ttu-id="698d1-107">Gerekli davranış garantisi</span><span class="sxs-lookup"><span data-stu-id="698d1-107">Required Behavioral Guarantees</span></span>  
 <span data-ttu-id="698d1-108">Olay tabanlı zaman uyumsuz model uygularsanız, sınıfınızın düzgün şekilde davrandığından ve sınıfınızın istemcilerinin bu davranışa güvendiğinden emin olmak için bir dizi garanti sağlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="698d1-108">If you implement the Event-based Asynchronous Pattern, you must provide a number of guarantees to ensure that your class will behave properly and clients of your class can rely on such behavior.</span></span>  
  
### <a name="completion"></a><span data-ttu-id="698d1-109">Tamamlama</span><span class="sxs-lookup"><span data-stu-id="698d1-109">Completion</span></span>  
 <span data-ttu-id="698d1-110">Başarılı bir tamamlama, hata veya iptal ettiğiniz durumlarda <em>MethodName</em>**tamamlandı** olay işleyicisini her zaman çağırın.</span><span class="sxs-lookup"><span data-stu-id="698d1-110">Always invoke the <em>MethodName</em>**Completed** event handler when you have successful completion, an error, or a cancellation.</span></span> <span data-ttu-id="698d1-111">Uygulamalar, boşta kaldığı ve tamamlanmanın asla gerçekleşmediği hiçbir durumda hiçbir şekilde karşılaşmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="698d1-111">Applications should never encounter a situation where they remain idle and completion never occurs.</span></span> <span data-ttu-id="698d1-112">Bu kural için bir özel durum, zaman uyumsuz işlemin kendisi tarafından tamamlanmaması için tasarlandıysa.</span><span class="sxs-lookup"><span data-stu-id="698d1-112">One exception to this rule is if the asynchronous operation itself is designed so that it never completes.</span></span>  
  
### <a name="completed-event-and-eventargs"></a><span data-ttu-id="698d1-113">Tamamlanan olay ve EventArgs</span><span class="sxs-lookup"><span data-stu-id="698d1-113">Completed Event and EventArgs</span></span>  
 <span data-ttu-id="698d1-114">Her ayrı <em>MethodName</em>**zaman uyumsuz** yöntemi için aşağıdaki tasarım gereksinimlerini uygulayın:</span><span class="sxs-lookup"><span data-stu-id="698d1-114">For each separate <em>MethodName</em>**Async** method, apply the following design requirements:</span></span>  
  
- <span data-ttu-id="698d1-115">Yöntemiyle aynı sınıfta <em>MethodName</em>**tamamlandı** olayını tanımlayın.</span><span class="sxs-lookup"><span data-stu-id="698d1-115">Define a <em>MethodName</em>**Completed** event on the same class as the method.</span></span>  
  
- <span data-ttu-id="698d1-116">Sınıfından türetilen <xref:System.EventArgs> MethodName tamamlandı olayı için bir sınıf ve eşlik eden temsilci tanımlayın. <xref:System.ComponentModel.AsyncCompletedEventArgs></span><span class="sxs-lookup"><span data-stu-id="698d1-116">Define an <xref:System.EventArgs> class and accompanying delegate for the <em>MethodName</em>**Completed** event that derives from the <xref:System.ComponentModel.AsyncCompletedEventArgs> class.</span></span> <span data-ttu-id="698d1-117">Varsayılan sınıf adı <em>MethodName</em>**CompletedEventArgs**biçiminde olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="698d1-117">The default class name should be of the form <em>MethodName</em>**CompletedEventArgs**.</span></span>  
  
- <span data-ttu-id="698d1-118">Sınıfın MethodName yönteminin dönüş değerlerine özgü olduğundan emin olun. <xref:System.EventArgs></span><span class="sxs-lookup"><span data-stu-id="698d1-118">Ensure that the <xref:System.EventArgs> class is specific to the return values of the <em>MethodName</em> method.</span></span> <span data-ttu-id="698d1-119"><xref:System.EventArgs> Sınıfını kullandığınızda, geliştiricilerin sonucu saçmasını asla gerektirmemelidir.</span><span class="sxs-lookup"><span data-stu-id="698d1-119">When you use the <xref:System.EventArgs> class, you should never require developers to cast the result.</span></span>  
  
     <span data-ttu-id="698d1-120">Aşağıdaki kod örneği, bu tasarım gereksiniminin sırasıyla iyi ve hatalı uygulanmasını gösterir.</span><span class="sxs-lookup"><span data-stu-id="698d1-120">The following code example shows good and bad implementation of this design requirement respectively.</span></span>  
  
```csharp  
// Good design  
private void Form1_MethodNameCompleted(object sender, xxxCompletedEventArgs e)   
{   
    DemoType result = e.Result;  
}  
  
// Bad design  
private void Form1_MethodNameCompleted(object sender, MethodNameCompletedEventArgs e)   
{   
    DemoType result = (DemoType)(e.Result);  
}  
```  
  
- <span data-ttu-id="698d1-121">Döndüren metotları <xref:System.EventArgs> `void`döndürmek için bir sınıf tanımlamayın.</span><span class="sxs-lookup"><span data-stu-id="698d1-121">Do not define an <xref:System.EventArgs> class for returning methods that return `void`.</span></span> <span data-ttu-id="698d1-122">Bunun yerine, <xref:System.ComponentModel.AsyncCompletedEventArgs> sınıfının bir örneğini kullanın.</span><span class="sxs-lookup"><span data-stu-id="698d1-122">Instead, use an instance of the <xref:System.ComponentModel.AsyncCompletedEventArgs> class.</span></span>  
  
- <span data-ttu-id="698d1-123"><em>MethodName</em>**tamamlandı** olayını her zaman yükseltdiğinizden emin olun.</span><span class="sxs-lookup"><span data-stu-id="698d1-123">Ensure that you always raise the <em>MethodName</em>**Completed** event.</span></span> <span data-ttu-id="698d1-124">Bu olay başarıyla tamamlandığında, bir hatada veya İptalde oluşturulmalıdır.</span><span class="sxs-lookup"><span data-stu-id="698d1-124">This event should be raised on successful completion, on an error, or on cancellation.</span></span> <span data-ttu-id="698d1-125">Uygulamalar, boşta kaldığı ve tamamlanmanın asla gerçekleşmediği hiçbir durumda hiçbir şekilde karşılaşmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="698d1-125">Applications should never encounter a situation where they remain idle and completion never occurs.</span></span>  
  
- <span data-ttu-id="698d1-126">Zaman uyumsuz işlemde oluşan tüm özel durumları yakatığınızdan ve yakalanan özel durumu <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> özelliğe atadığınızdan emin olun.</span><span class="sxs-lookup"><span data-stu-id="698d1-126">Ensure that you catch any exceptions that occur in the asynchronous operation and assign the caught exception to the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property.</span></span>  
  
- <span data-ttu-id="698d1-127">Görev tamamlanırken bir hata oluşursa, sonuçlara erişilememelidir.</span><span class="sxs-lookup"><span data-stu-id="698d1-127">If there was an error completing the task, the results should not be accessible.</span></span> <span data-ttu-id="698d1-128">Özelliği olmadığında `null`, <xref:System.EventArgs> yapıdaki herhangi bir özelliğe erişmenin bir özel durum harekete geçirdiğinden emin olun. <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A></span><span class="sxs-lookup"><span data-stu-id="698d1-128">When the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property is not `null`, ensure that accessing any property in the <xref:System.EventArgs> structure raises an exception.</span></span> <span data-ttu-id="698d1-129">Bu doğrulamayı gerçekleştirmek için yönteminikullanın.<xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A></span><span class="sxs-lookup"><span data-stu-id="698d1-129">Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> method to perform this verification.</span></span>  
  
- <span data-ttu-id="698d1-130">Bir hata olarak zaman aşımı modeli.</span><span class="sxs-lookup"><span data-stu-id="698d1-130">Model a time out as an error.</span></span> <span data-ttu-id="698d1-131">Zaman aşımı oluştuğunda, <em>MethodName</em>**tamamlandı** olayını yükseltin <xref:System.TimeoutException> ve <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> özelliğine atayın.</span><span class="sxs-lookup"><span data-stu-id="698d1-131">When a time out occurs, raise the <em>MethodName</em>**Completed** event and assign a <xref:System.TimeoutException> to the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property.</span></span>  
  
- <span data-ttu-id="698d1-132">Sınıfınız birden çok eşzamanlı çağırmaları destekliyorsa, <em>MethodName</em>**tamamlandı** olayının uygun `userSuppliedState` nesneyi içerdiğinden emin olun.</span><span class="sxs-lookup"><span data-stu-id="698d1-132">If your class supports multiple concurrent invocations, ensure that the <em>MethodName</em>**Completed** event contains the appropriate `userSuppliedState` object.</span></span>  
  
- <span data-ttu-id="698d1-133"><em>MethodName</em>**tamamlandı** olayının uygun iş parçacığında ve uygulama yaşam döngüsünde uygun zamanda yapıldığından emin olun.</span><span class="sxs-lookup"><span data-stu-id="698d1-133">Ensure that the <em>MethodName</em>**Completed** event is raised on the appropriate thread and at the appropriate time in the application lifecycle.</span></span> <span data-ttu-id="698d1-134">Daha fazla bilgi için bkz. Threading ve bağlamları bölümü.</span><span class="sxs-lookup"><span data-stu-id="698d1-134">For more information, see the Threading and Contexts section.</span></span>  
  
### <a name="simultaneously-executing-operations"></a><span data-ttu-id="698d1-135">Eşzamanlı olarak çalıştırılan Işlemler</span><span class="sxs-lookup"><span data-stu-id="698d1-135">Simultaneously Executing Operations</span></span>  
  
- <span data-ttu-id="698d1-136">Sınıfınız birden çok eş zamanlı çağrıyı destekliyorsa, bir nesne değerli durum parametresi ya da çağrılan `userSuppliedState`görev kimliği olan <em>MethodName</em>**zaman uyumsuz** aşırı yüklemeyi tanımlayarak her çağrıyı ayrı olarak izlemek için geliştiriciyi etkinleştirin.</span><span class="sxs-lookup"><span data-stu-id="698d1-136">If your class supports multiple concurrent invocations, enable the developer to track each invocation separately by defining the <em>MethodName</em>**Async** overload that takes an object-valued state parameter, or task ID, called `userSuppliedState`.</span></span> <span data-ttu-id="698d1-137">Bu parametrenin her zaman <em>MethodName</em>**zaman uyumsuz** yöntemin imzasında son parametre olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="698d1-137">This parameter should always be the last parameter in the <em>MethodName</em>**Async** method's signature.</span></span>  
  
- <span data-ttu-id="698d1-138">Sınıfınız, nesne değerli durum parametresi veya görev KIMLIĞI alan <em>MethodName</em>**zaman uyumsuz** aşırı yüklemesini TANıMLıYORSA, bu görev kimliğiyle birlikte işlemin ömrünü izlemediğinizden emin olun ve tamamlama işleyicisine geri sağladığınızdan emin olun.</span><span class="sxs-lookup"><span data-stu-id="698d1-138">If your class defines the <em>MethodName</em>**Async** overload that takes an object-valued state parameter, or task ID, be sure to track the lifetime of the operation with that task ID, and be sure to provide it back into the completion handler.</span></span> <span data-ttu-id="698d1-139">Yardım için kullanılabilen yardımcı sınıflar vardır.</span><span class="sxs-lookup"><span data-stu-id="698d1-139">There are helper classes available to assist.</span></span> <span data-ttu-id="698d1-140">Eşzamanlılık yönetimi hakkında daha fazla bilgi için bkz [. nasıl yapılır: Olay tabanlı zaman uyumsuz stili](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md)destekleyen bir bileşen uygulayın.</span><span class="sxs-lookup"><span data-stu-id="698d1-140">For more information on concurrency management, see [How to: Implement a Component That Supports the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md).</span></span>  
  
- <span data-ttu-id="698d1-141">Sınıfınız, durum parametresi olmadan <em>MethodName</em>**zaman uyumsuz** yöntemini tanımlıyorsa ve birden çok eşzamanlı çağırma 'Yı desteklemiyorsa, önceki MethodName parametresinden önce <em>MethodName</em>**zaman uyumsuz** çağırma denemelerinde emin olun **Zaman uyumsuz** çağrı tamamlandı bir <xref:System.InvalidOperationException>oluşturur.</span><span class="sxs-lookup"><span data-stu-id="698d1-141">If your class defines the <em>MethodName</em>**Async** method without the state parameter, and it does not support multiple concurrent invocations, ensure that any attempt to invoke <em>MethodName</em>**Async** before the prior <em>MethodName</em>**Async** invocation has completed raises an <xref:System.InvalidOperationException>.</span></span>  
  
- <span data-ttu-id="698d1-142">Genel olarak, `userSuppliedState` parametresi olmayan <em>MethodName</em>**zaman uyumsuz** yöntemi birden çok kez çağrıldığında, birden çok bekleyen işlem olması için bir özel durum oluşturmaz.</span><span class="sxs-lookup"><span data-stu-id="698d1-142">In general, do not raise an exception if the <em>MethodName</em>**Async** method without the `userSuppliedState` parameter is invoked multiple times so that there are multiple outstanding operations.</span></span> <span data-ttu-id="698d1-143">Sınıfınız açıkça bu durumu işleyemezse bir özel durum oluşturabilir, ancak geliştiricilerin bu birden fazla ayırt edilemeyen geri çağırmaları işleyebileceğini varsayabilirsiniz</span><span class="sxs-lookup"><span data-stu-id="698d1-143">You can raise an exception when your class explicitly cannot handle that situation, but assume that developers can handle these multiple indistinguishable callbacks</span></span>  
  
### <a name="accessing-results"></a><span data-ttu-id="698d1-144">Sonuçlara erişme</span><span class="sxs-lookup"><span data-stu-id="698d1-144">Accessing Results</span></span>  
  
- <span data-ttu-id="698d1-145">Zaman uyumsuz işlemin yürütülmesi sırasında bir hata oluşursa, sonuçlara erişilemeyebilir.</span><span class="sxs-lookup"><span data-stu-id="698d1-145">If there was an error during execution of the asynchronous operation, the results should not be accessible.</span></span> <span data-ttu-id="698d1-146"><xref:System.ComponentModel.AsyncCompletedEventArgs> ' Deki <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> herhangi bir özelliğe erişmenin, tarafından <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A>başvurulan özel `null` durumu harekete geçirmediğinden emin olun.</span><span class="sxs-lookup"><span data-stu-id="698d1-146">Ensure that accessing any property in the <xref:System.ComponentModel.AsyncCompletedEventArgs> when <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> is not `null` raises the exception referenced by <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A>.</span></span> <span data-ttu-id="698d1-147">Sınıfı bu amaçla <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> yöntemi sağlar. <xref:System.ComponentModel.AsyncCompletedEventArgs></span><span class="sxs-lookup"><span data-stu-id="698d1-147">The <xref:System.ComponentModel.AsyncCompletedEventArgs> class provides the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> method for this purpose.</span></span>  
  
- <span data-ttu-id="698d1-148">Sonuca erişim girişiminin işlemin iptal edildiğini belirten bir <xref:System.InvalidOperationException> sonuç aldığından emin olun.</span><span class="sxs-lookup"><span data-stu-id="698d1-148">Ensure that any attempt to access the result raises an <xref:System.InvalidOperationException> stating that the operation was canceled.</span></span> <span data-ttu-id="698d1-149">Bu doğrulamayı gerçekleştirmek için yönteminikullanın.<xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="698d1-149">Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> method to perform this verification.</span></span>  
  
### <a name="progress-reporting"></a><span data-ttu-id="698d1-150">İlerleme raporlaması</span><span class="sxs-lookup"><span data-stu-id="698d1-150">Progress Reporting</span></span>  
  
- <span data-ttu-id="698d1-151">Mümkünse ilerleme raporlamayı destekler.</span><span class="sxs-lookup"><span data-stu-id="698d1-151">Support progress reporting, if possible.</span></span> <span data-ttu-id="698d1-152">Bu, geliştiricilerin sınıfınızı kullandıklarında daha iyi bir uygulama kullanıcı deneyimi sağlamasına olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="698d1-152">This enables developers to provide a better application user experience when they use your class.</span></span>  
  
- <span data-ttu-id="698d1-153">Bir **ProgressChanged & lt** veya <em>MethodName</em>**ProgressChanged & lt** olayı uygularsanız, bu işlemin <em>MethodName</em> olayını tamamladıktan sonra belirli bir zaman uyumsuz işlem için oluşturulan bir olay olmadığından emin olun yükseltildi.</span><span class="sxs-lookup"><span data-stu-id="698d1-153">If you implement a **ProgressChanged** or <em>MethodName</em>**ProgressChanged** event, ensure that there are no such events raised for a particular asynchronous operation after that operation's <em>MethodName</em>**Completed** event has been raised.</span></span>  
  
- <span data-ttu-id="698d1-154">Standart <xref:System.ComponentModel.ProgressChangedEventArgs> Doldurulmakta ise, <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> her zaman yüzde olarak yorumlanabileceğinden emin olun.</span><span class="sxs-lookup"><span data-stu-id="698d1-154">If the standard <xref:System.ComponentModel.ProgressChangedEventArgs> is being populated, ensure that the <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> can always be interpreted as a percentage.</span></span> <span data-ttu-id="698d1-155">Yüzdenin doğru olması gerekmez, ancak bir yüzdeyi temsil etmelidir.</span><span class="sxs-lookup"><span data-stu-id="698d1-155">The percentage does not need to be accurate, but it should represent a percentage.</span></span> <span data-ttu-id="698d1-156">İlerleme raporlama ölçümünüzün bir yüzdeden başka bir şey olması gerekiyorsa, <xref:System.ComponentModel.ProgressChangedEventArgs> sınıftan bir sınıf türetirsiniz ve 0 ' dan ayrılın. <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A></span><span class="sxs-lookup"><span data-stu-id="698d1-156">If your progress reporting metric must be something other than a percentage, derive a class from the <xref:System.ComponentModel.ProgressChangedEventArgs> class and leave <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> at 0.</span></span> <span data-ttu-id="698d1-157">Yüzde dışında bir raporlama ölçümü kullanmaktan kaçının.</span><span class="sxs-lookup"><span data-stu-id="698d1-157">Avoid using a reporting metric other than a percentage.</span></span>  
  
- <span data-ttu-id="698d1-158">`ProgressChanged` Olayın uygun iş parçacığında ve uygulama yaşam döngüsünde uygun zamanda yapıldığından emin olun.</span><span class="sxs-lookup"><span data-stu-id="698d1-158">Ensure that the `ProgressChanged` event is raised on the appropriate thread and at the appropriate time in the application lifecycle.</span></span> <span data-ttu-id="698d1-159">Daha fazla bilgi için bkz. Threading ve bağlamları bölümü.</span><span class="sxs-lookup"><span data-stu-id="698d1-159">For more information, see the Threading and Contexts section.</span></span>  
  
### <a name="isbusy-implementation"></a><span data-ttu-id="698d1-160">Imeşgul uygulama</span><span class="sxs-lookup"><span data-stu-id="698d1-160">IsBusy Implementation</span></span>  
  
- <span data-ttu-id="698d1-161">Sınıfınız birden çok eşzamanlı `IsBusy` çağırmaları destekliyorsa, bir özelliği açığa çıkarın.</span><span class="sxs-lookup"><span data-stu-id="698d1-161">Do not expose an `IsBusy` property if your class supports multiple concurrent invocations.</span></span> <span data-ttu-id="698d1-162">Örneğin, XML Web hizmeti proxy 'leri, zaman uyumsuz yöntemlerin `IsBusy` birden çok eş zamanlı etkinleştirmeleri desteklediklerinden bir özelliği kullanıma sunmuyor.</span><span class="sxs-lookup"><span data-stu-id="698d1-162">For example, XML Web service proxies do not expose an `IsBusy` property because they support multiple concurrent invocations of asynchronous methods.</span></span>  
  
- <span data-ttu-id="698d1-163">`true` Özelliği, MethodName zaman uyumsuz yöntemi çağrıldıktan sonra ve MethodName Completed olayı oluşturulduktan önce döndürmelidir. `IsBusy`</span><span class="sxs-lookup"><span data-stu-id="698d1-163">The `IsBusy` property should return `true` after the <em>MethodName</em>**Async** method has been called and before the <em>MethodName</em>**Completed** event has been raised.</span></span> <span data-ttu-id="698d1-164">Aksi takdirde, döndürmelidir `false`.</span><span class="sxs-lookup"><span data-stu-id="698d1-164">Otherwise it should return `false`.</span></span> <span data-ttu-id="698d1-165">Ve <xref:System.ComponentModel.BackgroundWorker> `IsBusy` bileşenleri, bir özelliği kullanıma sunan sınıfların örnekleridir. <xref:System.Net.WebClient></span><span class="sxs-lookup"><span data-stu-id="698d1-165">The <xref:System.ComponentModel.BackgroundWorker> and <xref:System.Net.WebClient> components are examples of classes that expose an `IsBusy` property.</span></span>  
  
### <a name="cancellation"></a><span data-ttu-id="698d1-166">İptal Etme</span><span class="sxs-lookup"><span data-stu-id="698d1-166">Cancellation</span></span>  
  
- <span data-ttu-id="698d1-167">Mümkünse iptali destekler.</span><span class="sxs-lookup"><span data-stu-id="698d1-167">Support cancellation, if possible.</span></span> <span data-ttu-id="698d1-168">Bu, geliştiricilerin sınıfınızı kullandıklarında daha iyi bir uygulama kullanıcı deneyimi sağlamasına olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="698d1-168">This enables developers to provide a better application user experience when they use your class.</span></span>  
  
- <span data-ttu-id="698d1-169">İptal durumunda, <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> <xref:System.ComponentModel.AsyncCompletedEventArgs> nesnesinde bayrağını ayarlayın.</span><span class="sxs-lookup"><span data-stu-id="698d1-169">In the case of cancellation, set the <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> flag in the <xref:System.ComponentModel.AsyncCompletedEventArgs> object.</span></span>  
  
- <span data-ttu-id="698d1-170">Sonuca erişim girişiminin işlemin iptal edildiğini belirten bir <xref:System.InvalidOperationException> sonuç aldığından emin olun.</span><span class="sxs-lookup"><span data-stu-id="698d1-170">Ensure that any attempt to access the result raises an <xref:System.InvalidOperationException> stating that the operation was canceled.</span></span> <span data-ttu-id="698d1-171">Bu doğrulamayı gerçekleştirmek için yönteminikullanın.<xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="698d1-171">Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> method to perform this verification.</span></span>  
  
- <span data-ttu-id="698d1-172">Bir iptal yöntemine yapılan çağrıların her zaman başarıyla geri dönmesi ve hiçbir zaman özel durum geçirmeyeceğinden emin olun.</span><span class="sxs-lookup"><span data-stu-id="698d1-172">Ensure that calls to a cancellation method always return successfully, and never raise an exception.</span></span> <span data-ttu-id="698d1-173">Genel olarak, bir işlem belirli bir zamanda bir işlemin gerçekten iptal edilebilir olup olmadığı konusunda bilgilendirilmez ve daha önce verilen İptalin başarılı olup olmadığı bildirilmiyor.</span><span class="sxs-lookup"><span data-stu-id="698d1-173">In general, a client is not notified as to whether an operation is truly cancelable at any given time, and is not notified as to whether a previously issued cancellation has succeeded.</span></span> <span data-ttu-id="698d1-174">Ancak, uygulama tamamlanma durumunda bir parçası olduğundan, bir iptal işlemi başarılı olduğunda uygulamaya her zaman bildirim verilir.</span><span class="sxs-lookup"><span data-stu-id="698d1-174">However, the application will always be given notification when a cancellation succeeded, because the application takes part in the completion status.</span></span>  
  
- <span data-ttu-id="698d1-175">İşlem iptal edildiğinde <em>MethodName</em>**tamamlandı** olayını yükseltin.</span><span class="sxs-lookup"><span data-stu-id="698d1-175">Raise the <em>MethodName</em>**Completed** event when the operation is canceled.</span></span>  
  
### <a name="errors-and-exceptions"></a><span data-ttu-id="698d1-176">Hatalar ve özel durumlar</span><span class="sxs-lookup"><span data-stu-id="698d1-176">Errors and Exceptions</span></span>  
  
- <span data-ttu-id="698d1-177">Zaman uyumsuz işlemde oluşan tüm özel durumları yakalayın ve <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A?displayProperty=nameWithType> özelliğin değerini bu özel duruma ayarlayın.</span><span class="sxs-lookup"><span data-stu-id="698d1-177">Catch any exceptions that occur in the asynchronous operation and set the value of the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A?displayProperty=nameWithType> property to that exception.</span></span>  
  
### <a name="threading-and-contexts"></a><span data-ttu-id="698d1-178">İş parçacığı oluşturma ve bağlamlar</span><span class="sxs-lookup"><span data-stu-id="698d1-178">Threading and Contexts</span></span>  
 <span data-ttu-id="698d1-179">Sınıfınızın doğru çalışması için, istemcinin olay işleyicilerinin ASP.NET ve Windows Forms uygulamaları da dahil olmak üzere, belirtilen uygulama modeli için uygun iş parçacığında veya bağlamda çağrılması önemlidir.</span><span class="sxs-lookup"><span data-stu-id="698d1-179">For correct operation of your class, it is critical that the client's event handlers are invoked on the proper thread or context for the given application model, including ASP.NET and Windows Forms applications.</span></span> <span data-ttu-id="698d1-180">Zaman uyumsuz sınıfınızın herhangi bir uygulama modelinde doğru şekilde davrandığından emin olmak için iki önemli yardımcı sınıfı sağlanır <xref:System.ComponentModel.AsyncOperation> : <xref:System.ComponentModel.AsyncOperationManager>ve.</span><span class="sxs-lookup"><span data-stu-id="698d1-180">Two important helper classes are provided to ensure that your asynchronous class behaves correctly under any application model: <xref:System.ComponentModel.AsyncOperation> and <xref:System.ComponentModel.AsyncOperationManager>.</span></span>  
  
 <span data-ttu-id="698d1-181"><xref:System.ComponentModel.AsyncOperationManager><xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A>, döndüren bir yöntem sağlar. <xref:System.ComponentModel.AsyncOperation></span><span class="sxs-lookup"><span data-stu-id="698d1-181"><xref:System.ComponentModel.AsyncOperationManager> provides one method, <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A>, which returns an <xref:System.ComponentModel.AsyncOperation>.</span></span> <span data-ttu-id="698d1-182"><em>MethodName</em>**zaman uyumsuz** Yöntem çağrılarınız <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A> ve sınıfınız, zaman uyumsuz <xref:System.ComponentModel.AsyncOperation> görevin ömrünü izlemek için döndürülen öğesini kullanır.</span><span class="sxs-lookup"><span data-stu-id="698d1-182">Your <em>MethodName</em>**Async** method calls <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A> and your class uses the returned <xref:System.ComponentModel.AsyncOperation> to track the lifetime of the asynchronous task.</span></span>  
  
 <span data-ttu-id="698d1-183">İlerleme durumunu, artımlı sonuçları ve tamamlanmayı istemciye bildirmek için, <xref:System.ComponentModel.AsyncOperation.Post%2A> ve <xref:System.ComponentModel.AsyncOperation.OperationCompleted%2A> üzerindeki <xref:System.ComponentModel.AsyncOperation>yöntemlerini çağırın.</span><span class="sxs-lookup"><span data-stu-id="698d1-183">To report progress, incremental results, and completion to the client, call the <xref:System.ComponentModel.AsyncOperation.Post%2A> and <xref:System.ComponentModel.AsyncOperation.OperationCompleted%2A> methods on the <xref:System.ComponentModel.AsyncOperation>.</span></span> <span data-ttu-id="698d1-184"><xref:System.ComponentModel.AsyncOperation>, istemcinin olay işleyicilerinde yapılan çağrıların doğru iş parçacığına veya içeriğe sıralanmasından sorumludur.</span><span class="sxs-lookup"><span data-stu-id="698d1-184"><xref:System.ComponentModel.AsyncOperation> is responsible for marshaling calls to the client's event handlers to the proper thread or context.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="698d1-185">Uygulama modeli ilkesine karşı açıkça gitmek istiyorsanız bu kuralları atlayabilirsiniz, ancak hala olay tabanlı zaman uyumsuz model kullanmanın diğer avantajlarından faydalanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="698d1-185">You can circumvent these rules if you explicitly want to go against the policy of the application model, but still benefit from the other advantages of using the Event-based Asynchronous Pattern.</span></span> <span data-ttu-id="698d1-186">Örneğin, Windows Forms üzerinde çalışan bir sınıfın ücretsiz olarak iş parçacıklı olmasını isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="698d1-186">For example, you may want a class operating in Windows Forms to be free threaded.</span></span> <span data-ttu-id="698d1-187">Geliştiriciler kapsanan kısıtlamaları anlamış olduğu sürece, ücretsiz bir iş parçacıklı sınıf oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="698d1-187">You can create a free threaded class, as long as developers understand the implied restrictions.</span></span> <span data-ttu-id="698d1-188">Konsol uygulamaları <xref:System.ComponentModel.AsyncOperation.Post%2A> çağrıların yürütülmesini eşitlemez.</span><span class="sxs-lookup"><span data-stu-id="698d1-188">Console applications do not synchronize the execution of <xref:System.ComponentModel.AsyncOperation.Post%2A> calls.</span></span> <span data-ttu-id="698d1-189">Bu, olayların `ProgressChanged` sırada oluşturulmasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="698d1-189">This can cause `ProgressChanged` events to be raised out of order.</span></span> <span data-ttu-id="698d1-190"><xref:System.ComponentModel.AsyncOperation.Post%2A> Çağrıların serileştirilmiş yürütülmesini istiyorsanız, bir <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType> sınıfı uygulayın ve yükleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="698d1-190">If you wish to have serialized execution of <xref:System.ComponentModel.AsyncOperation.Post%2A> calls, implement and install a <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType> class.</span></span>  
  
 <span data-ttu-id="698d1-191">' I kullanma <xref:System.ComponentModel.AsyncOperation> ve <xref:System.ComponentModel.AsyncOperationManager> zaman uyumsuz işlemlerinizi etkinleştirme hakkında daha fazla bilgi için [bkz. nasıl yapılır: Olay tabanlı zaman uyumsuz stili](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md)destekleyen bir bileşen uygulayın.</span><span class="sxs-lookup"><span data-stu-id="698d1-191">For more information about using <xref:System.ComponentModel.AsyncOperation> and <xref:System.ComponentModel.AsyncOperationManager> to enable your asynchronous operations, see [How to: Implement a Component That Supports the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md).</span></span>  
  
## <a name="guidelines"></a><span data-ttu-id="698d1-192">Kuralları</span><span class="sxs-lookup"><span data-stu-id="698d1-192">Guidelines</span></span>  
  
- <span data-ttu-id="698d1-193">İdeal olarak, her yöntem çağrısı diğerlerinden bağımsız olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="698d1-193">Ideally, each method invocation should be independent of others.</span></span> <span data-ttu-id="698d1-194">Paylaşılan kaynaklarla ilgili bağlantısı önlemeyi kullanmaktan kaçının.</span><span class="sxs-lookup"><span data-stu-id="698d1-194">You should avoid coupling invocations with shared resources.</span></span> <span data-ttu-id="698d1-195">Kaynaklar, çağırmaları arasında paylaşılırsa, uygulamanızda uygun bir eşitleme mekanizması sağlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="698d1-195">If resources are to be shared among invocations, you will need to provide a proper synchronization mechanism in your implementation.</span></span>  
  
- <span data-ttu-id="698d1-196">İstemcinin eşitleme uygulaması için gerekli olan tasarımlar önerilmez.</span><span class="sxs-lookup"><span data-stu-id="698d1-196">Designs that require the client to implement synchronization are discouraged.</span></span> <span data-ttu-id="698d1-197">Örneğin, bir parametre olarak genel statik nesne alan zaman uyumsuz bir metoda sahip olabilirsiniz; Böyle bir yöntemin birden çok eş zamanlı çağırma verisi bozulmaya veya kilitlenmeleri oluşmasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="698d1-197">For example, you could have an asynchronous method that receives a global static object as a parameter; multiple concurrent invocations of such a method could result in data corruption or deadlocks.</span></span>  
  
- <span data-ttu-id="698d1-198">Birden çok çağırma aşırı yüklemesiyle (`userState` İmzada) bir yöntem uygularsanız, sınıfınızın Kullanıcı durumlarının veya görev kimliklerinin ve bunlara karşılık gelen bekleyen işlemlerin bir koleksiyonunu yönetmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="698d1-198">If you implement a method with the multiple-invocation overload (`userState` in the signature), your class will need to manage a collection of user states, or task IDs, and their corresponding pending operations.</span></span> <span data-ttu-id="698d1-199">Çeşitli etkinleştirmeleri koleksiyondaki nesneleri ekleyip kaldırmasına `lock` `userState` yönelik olan bu koleksiyonun bölgeleriyle korunması gerekir.</span><span class="sxs-lookup"><span data-stu-id="698d1-199">This collection should be protected with `lock` regions, because the various invocations add and remove `userState` objects in the collection.</span></span>  
  
- <span data-ttu-id="698d1-200">Uygun yerlerde `CompletedEventArgs` sınıfları yeniden kullanmayı düşünün.</span><span class="sxs-lookup"><span data-stu-id="698d1-200">Consider reusing `CompletedEventArgs` classes where feasible and appropriate.</span></span> <span data-ttu-id="698d1-201">Bu durumda, belirtilen bir temsilci ve <xref:System.EventArgs> tür tek bir yönteme bağlı olmadığından, adlandırma yöntem adı ile tutarlı değildir.</span><span class="sxs-lookup"><span data-stu-id="698d1-201">In this case, the naming is not consistent with the method name, because a given delegate and <xref:System.EventArgs> type are not tied to a single method.</span></span> <span data-ttu-id="698d1-202">Ancak, geliştiricilerin ' de <xref:System.EventArgs> bir özellikten alınan değeri dönüştürmeyi zorlamak hiç kabul edilebilir değildir.</span><span class="sxs-lookup"><span data-stu-id="698d1-202">However, forcing developers to cast the value retrieved from a property on the <xref:System.EventArgs> is never acceptable.</span></span>  
  
- <span data-ttu-id="698d1-203">Öğesinden <xref:System.ComponentModel.Component>türetilen bir sınıf yazıyorsanız kendi <xref:System.Threading.SynchronizationContext> sınıfınızı uygulamaz ve yüklemeyin.</span><span class="sxs-lookup"><span data-stu-id="698d1-203">If you are authoring a class that derives from <xref:System.ComponentModel.Component>, do not implement and install your own <xref:System.Threading.SynchronizationContext> class.</span></span> <span data-ttu-id="698d1-204">Uygulama modelleri, bileşen değil, kullanılan denetim <xref:System.Threading.SynchronizationContext> .</span><span class="sxs-lookup"><span data-stu-id="698d1-204">Application models, not components, control the <xref:System.Threading.SynchronizationContext> that is used.</span></span>  
  
- <span data-ttu-id="698d1-205">Herhangi bir sıralama için çoklu iş parçacığı kullandığınızda, kendinizi çok önemli ve karmaşık hatalara maruz kalırsınız.</span><span class="sxs-lookup"><span data-stu-id="698d1-205">When you use multithreading of any sort, you potentially expose yourself to very serious and complex bugs.</span></span> <span data-ttu-id="698d1-206">Çoklu iş parçacığı kullanan herhangi bir çözümü uygulamadan önce bkz. [yönetilen Iş parçacığı En Iyi yöntemleri](../../../docs/standard/threading/managed-threading-best-practices.md).</span><span class="sxs-lookup"><span data-stu-id="698d1-206">Before implementing any solution that uses multithreading, see [Managed Threading Best Practices](../../../docs/standard/threading/managed-threading-best-practices.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="698d1-207">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="698d1-207">See also</span></span>

- <xref:System.ComponentModel.AsyncOperation>
- <xref:System.ComponentModel.AsyncOperationManager>
- <xref:System.ComponentModel.AsyncCompletedEventArgs>
- <xref:System.ComponentModel.ProgressChangedEventArgs>
- <xref:System.ComponentModel.BackgroundWorker>
- [<span data-ttu-id="698d1-208">Olay Tabanlı Zaman Uyumsuz Deseni Uygulama</span><span class="sxs-lookup"><span data-stu-id="698d1-208">Implementing the Event-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/implementing-the-event-based-asynchronous-pattern.md)
- [<span data-ttu-id="698d1-209">Olay Tabanlı Zaman Uyumsuz Desen (EAP)</span><span class="sxs-lookup"><span data-stu-id="698d1-209">Event-based Asynchronous Pattern (EAP)</span></span>](../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-eap.md)
- [<span data-ttu-id="698d1-210">Olay Tabanlı Zaman Uyumsuz Desenin Ne Zaman Uygulanacağını Belirleme</span><span class="sxs-lookup"><span data-stu-id="698d1-210">Deciding When to Implement the Event-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/deciding-when-to-implement-the-event-based-asynchronous-pattern.md)
- [<span data-ttu-id="698d1-211">Olay Tabanlı Zaman Uyumsuz Desen Uygulamak için En İyi Yöntemler</span><span class="sxs-lookup"><span data-stu-id="698d1-211">Best Practices for Implementing the Event-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern.md)
- [<span data-ttu-id="698d1-212">Nasıl yapılır: Olay tabanlı zaman uyumsuz stili destekleyen bileşenleri kullanma</span><span class="sxs-lookup"><span data-stu-id="698d1-212">How to: Use Components That Support the Event-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/how-to-use-components-that-support-the-event-based-asynchronous-pattern.md)
- [<span data-ttu-id="698d1-213">Nasıl yapılır: Olay tabanlı zaman uyumsuz stili destekleyen bir bileşeni uygulama</span><span class="sxs-lookup"><span data-stu-id="698d1-213">How to: Implement a Component That Supports the Event-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md)
