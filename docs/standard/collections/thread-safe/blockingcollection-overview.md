---
title: BlockingCollection Genel Bakışı
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- BlockingCollection, overview
ms.assetid: 987ea3d7-0ad5-4238-8b64-331ce4eb3f0b
ms.openlocfilehash: 708ab9dc8df2ee3128036ffc71e9abc51a56e33b
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 06/02/2020
ms.locfileid: "84287919"
---
# <a name="blockingcollection-overview"></a><span data-ttu-id="006c2-102">BlockingCollection Genel Bakışı</span><span class="sxs-lookup"><span data-stu-id="006c2-102">BlockingCollection Overview</span></span>
<span data-ttu-id="006c2-103"><xref:System.Collections.Concurrent.BlockingCollection%601>, aşağıdaki özellikleri sağlayan iş parçacığı güvenli bir koleksiyon sınıfıdır:</span><span class="sxs-lookup"><span data-stu-id="006c2-103"><xref:System.Collections.Concurrent.BlockingCollection%601> is a thread-safe collection class that provides the following features:</span></span>  
  
- <span data-ttu-id="006c2-104">Üretici-tüketici deseninin bir uygulamasıdır.</span><span class="sxs-lookup"><span data-stu-id="006c2-104">An implementation of the Producer-Consumer pattern.</span></span>  
  
- <span data-ttu-id="006c2-105">Birden çok iş parçacığından öğe ekleme ve alma.</span><span class="sxs-lookup"><span data-stu-id="006c2-105">Concurrent adding and taking of items from multiple threads.</span></span>  
  
- <span data-ttu-id="006c2-106">İsteğe bağlı maksimum kapasite.</span><span class="sxs-lookup"><span data-stu-id="006c2-106">Optional maximum capacity.</span></span>  
  
- <span data-ttu-id="006c2-107">Koleksiyonun ne zaman boş veya tam olduğunu engelleyen ekleme ve kaldırma işlemleri.</span><span class="sxs-lookup"><span data-stu-id="006c2-107">Insertion and removal operations that block when collection is empty or full.</span></span>  
  
- <span data-ttu-id="006c2-108">Ekleme ve kaldırma "TRY" işlemleri, belirli bir süre içinde engellenmez veya engellenmiyor.</span><span class="sxs-lookup"><span data-stu-id="006c2-108">Insertion and removal "try" operations that do not block or that block up to a specified period of time.</span></span>  
  
- <span data-ttu-id="006c2-109">Uygulayan tüm koleksiyon türlerini Kapsüller<xref:System.Collections.Concurrent.IProducerConsumerCollection%601></span><span class="sxs-lookup"><span data-stu-id="006c2-109">Encapsulates any collection type that implements <xref:System.Collections.Concurrent.IProducerConsumerCollection%601></span></span>  
  
- <span data-ttu-id="006c2-110">İptal belirteçleriyle iptal.</span><span class="sxs-lookup"><span data-stu-id="006c2-110">Cancellation with cancellation tokens.</span></span>  
  
- <span data-ttu-id="006c2-111">İle iki tür numaralandırma `foreach` ( `For Each` Visual Basic):</span><span class="sxs-lookup"><span data-stu-id="006c2-111">Two kinds of enumeration with `foreach` (`For Each` in Visual Basic):</span></span>  
  
    1. <span data-ttu-id="006c2-112">Salt okuma numaralandırması.</span><span class="sxs-lookup"><span data-stu-id="006c2-112">Read-only enumeration.</span></span>  
  
    2. <span data-ttu-id="006c2-113">Öğeleri numaralandırıldıkları gibi kaldıran sabit listesi.</span><span class="sxs-lookup"><span data-stu-id="006c2-113">Enumeration that removes items as they are enumerated.</span></span>  
  
## <a name="bounding-and-blocking-support"></a><span data-ttu-id="006c2-114">Sınırlama ve engelleme desteği</span><span class="sxs-lookup"><span data-stu-id="006c2-114">Bounding and Blocking Support</span></span>  
 <span data-ttu-id="006c2-115"><xref:System.Collections.Concurrent.BlockingCollection%601>sınırlayıcı ve engellemeyi destekler.</span><span class="sxs-lookup"><span data-stu-id="006c2-115"><xref:System.Collections.Concurrent.BlockingCollection%601> supports bounding and blocking.</span></span> <span data-ttu-id="006c2-116">Sınırlayıcı, koleksiyonun maksimum kapasitesini ayarlayabilmeniz anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="006c2-116">Bounding means you can set the maximum capacity of the collection.</span></span> <span data-ttu-id="006c2-117">Belirli senaryolarda sınırlayıcı önemlidir çünkü koleksiyonun en büyük boyutunu bellekte denetlemenizi sağlar ve üreten iş parçacıklarının, tüketen iş parçacıklarından çok daha önce ilerlemenize engel olur.</span><span class="sxs-lookup"><span data-stu-id="006c2-117">Bounding is important in certain scenarios because it enables you to control the maximum size of the collection in memory, and it prevents the producing threads from moving too far ahead of the consuming threads.</span></span>  
  
 <span data-ttu-id="006c2-118">Birden çok iş parçacığı veya görev koleksiyona aynı anda öğe ekleyebilir ve koleksiyon belirtilen en büyük kapasiteye ulaşırsa, bir öğe kaldırılana kadar, üreten iş parçacıkları engeller.</span><span class="sxs-lookup"><span data-stu-id="006c2-118">Multiple threads or tasks can add items to the collection concurrently, and if the collection reaches its specified maximum capacity, the producing threads will block until an item is removed.</span></span> <span data-ttu-id="006c2-119">Birden çok tüketici aynı anda öğeleri kaldırabilir ve koleksiyon boşsa, bir üretici bir öğe eklemeene kadar tüketim iş parçacıkları engeller.</span><span class="sxs-lookup"><span data-stu-id="006c2-119">Multiple consumers can remove items concurrently, and if the collection becomes empty, the consuming threads will block until a producer adds an item.</span></span> <span data-ttu-id="006c2-120">Bir üreten iş parçacığı, <xref:System.Collections.Concurrent.BlockingCollection%601.CompleteAdding%2A> daha fazla öğe eklenmeyeceğini belirtmek için çağırabilir.</span><span class="sxs-lookup"><span data-stu-id="006c2-120">A producing thread can call <xref:System.Collections.Concurrent.BlockingCollection%601.CompleteAdding%2A> to indicate that no more items will be added.</span></span> <span data-ttu-id="006c2-121">Tüketiciler, <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> koleksiyonun ne zaman boş olduğunu ve daha fazla öğenin eklenmediğini bilen özelliği izler.</span><span class="sxs-lookup"><span data-stu-id="006c2-121">Consumers monitor the <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> property to know when the collection is empty and no more items will be added.</span></span> <span data-ttu-id="006c2-122">Aşağıdaki örnekte, 100 sınırlı kapasitesi olan basit bir BlockingCollection gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="006c2-122">The following example shows a simple BlockingCollection with a bounded capacity of 100.</span></span> <span data-ttu-id="006c2-123">Bir üretici görevi, bazı dış koşullar doğru olduğu sürece koleksiyona öğe ekler ve ardından çağırır <xref:System.Collections.Concurrent.BlockingCollection%601.CompleteAdding%2A> .</span><span class="sxs-lookup"><span data-stu-id="006c2-123">A producer task adds items to the collection as long as some external condition is true, and then calls <xref:System.Collections.Concurrent.BlockingCollection%601.CompleteAdding%2A>.</span></span> <span data-ttu-id="006c2-124">Tüketici görevi, özelliği true olana kadar öğeleri alır <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> .</span><span class="sxs-lookup"><span data-stu-id="006c2-124">The consumer task takes items until the <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> property is true.</span></span>  
  
 [!code-csharp[CDS_BlockingCollection#04](../../../../samples/snippets/csharp/VS_Snippets_Misc/cds_blockingcollection/cs/blockingcollection.cs#04)]
 [!code-vb[CDS_BlockingCollection#04](../../../../samples/snippets/visualbasic/VS_Snippets_Misc/cds_blockingcollection/vb/introsnippetsbc.vb#04)]  
  
 <span data-ttu-id="006c2-125">Tüm bir örnek için bkz. [nasıl yapılır: öğeleri bir BlockingCollection 'Dan ayrı olarak ekleme ve alma](how-to-add-and-take-items.md).</span><span class="sxs-lookup"><span data-stu-id="006c2-125">For a complete example, see [How to: Add and Take Items Individually from a BlockingCollection](how-to-add-and-take-items.md).</span></span>  
  
## <a name="timed-blocking-operations"></a><span data-ttu-id="006c2-126">Zamanlanmış engelleyici Işlemler</span><span class="sxs-lookup"><span data-stu-id="006c2-126">Timed Blocking Operations</span></span>  
 <span data-ttu-id="006c2-127">Sınırlanmış koleksiyonlar üzerinde zaman aşımına uğramaya <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> ve <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A> işlemlere, yöntemi ekleme veya bir öğe almaya çalışır.</span><span class="sxs-lookup"><span data-stu-id="006c2-127">In timed blocking <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> and <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A> operations on bounded collections, the method tries to add or take an item.</span></span> <span data-ttu-id="006c2-128">Bir öğe varsa, başvuruya göre geçirilen değişkene yerleştirilir ve yöntemi true değerini döndürür.</span><span class="sxs-lookup"><span data-stu-id="006c2-128">If an item is available it is placed into the variable that was passed in by reference, and the method returns true.</span></span> <span data-ttu-id="006c2-129">Belirtilen bir zaman aşımı süresinden sonra hiçbir öğe alınmamışsa, yöntem false döndürür.</span><span class="sxs-lookup"><span data-stu-id="006c2-129">If no item is retrieved after a specified time-out period the method returns false.</span></span> <span data-ttu-id="006c2-130">Daha sonra iş parçacığı, koleksiyona erişmeyi yeniden denemeden önce başka bir faydalı iş yapmak için ücretsizdir.</span><span class="sxs-lookup"><span data-stu-id="006c2-130">The thread is then free to do some other useful work before trying again to access the collection.</span></span> <span data-ttu-id="006c2-131">Erişimin zaman aşımına uğraması hakkında bir örnek için bkz. [nasıl yapılır: öğeleri bir BlockingCollection 'Dan tek tek ekleme ve alma](how-to-add-and-take-items.md).</span><span class="sxs-lookup"><span data-stu-id="006c2-131">For an example of timed blocking access, see the second example in [How to: Add and Take Items Individually from a BlockingCollection](how-to-add-and-take-items.md).</span></span>  
  
## <a name="cancelling-add-and-take-operations"></a><span data-ttu-id="006c2-132">Ekleme ve alma Işlemleri iptal ediliyor</span><span class="sxs-lookup"><span data-stu-id="006c2-132">Cancelling Add and Take Operations</span></span>  
 <span data-ttu-id="006c2-133">Ekleme ve alma işlemleri genellikle bir döngüde gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="006c2-133">Add and Take operations are typically performed in a loop.</span></span> <span data-ttu-id="006c2-134">Bir döngüyü <xref:System.Threading.CancellationToken> <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> veya <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A> yöntemine geçirerek ve sonra her yinelemede belirtecin özelliğinin değerini denetleyerek iptal edebilirsiniz <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> .</span><span class="sxs-lookup"><span data-stu-id="006c2-134">You can cancel a loop by passing in a <xref:System.Threading.CancellationToken> to the <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> or <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A> method, and then checking the value of the token's <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property on each iteration.</span></span> <span data-ttu-id="006c2-135">Değer true ise, herhangi bir kaynağı temizleyip döngüden çıkarken iptal isteğine yanıt vermek sizin için olur.</span><span class="sxs-lookup"><span data-stu-id="006c2-135">If the value is true, then it is up to you to respond the cancellation request by cleaning up any resources and exiting the loop.</span></span> <span data-ttu-id="006c2-136">Aşağıdaki örnek, <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> bir iptal belirteci ve onu kullanan kodu alan aşırı yüklemesini gösterir:</span><span class="sxs-lookup"><span data-stu-id="006c2-136">The following example shows an overload of <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> that takes a cancellation token, and the code that uses it:</span></span>  
  
 [!code-csharp[CDS_BlockingCollection#05](../../../../samples/snippets/csharp/VS_Snippets_Misc/cds_blockingcollection/cs/blockingcollection.cs#05)]
 [!code-vb[CDS_BlockingCollection#05](../../../../samples/snippets/visualbasic/VS_Snippets_Misc/cds_blockingcollection/vb/introsnippetsbc.vb#05)]  
  
 <span data-ttu-id="006c2-137">İptal desteğinin nasıl ekleneceği hakkında bir örnek için bkz. [nasıl yapılır: öğeleri bir BlockingCollection 'Dan tek tek ekleme ve alma](how-to-add-and-take-items.md).</span><span class="sxs-lookup"><span data-stu-id="006c2-137">For an example of how to add cancellation support, see the second example in [How to: Add and Take Items Individually from a BlockingCollection](how-to-add-and-take-items.md).</span></span>  
  
## <a name="specifying-the-collection-type"></a><span data-ttu-id="006c2-138">Koleksiyon türünü belirtme</span><span class="sxs-lookup"><span data-stu-id="006c2-138">Specifying the Collection Type</span></span>  
 <span data-ttu-id="006c2-139">Bir oluşturduğunuzda <xref:System.Collections.Concurrent.BlockingCollection%601> , yalnızca sınırlanmış kapasiteyi değil, kullanılacak koleksiyon türünü de belirtebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="006c2-139">When you create a <xref:System.Collections.Concurrent.BlockingCollection%601>, you can specify not only the bounded capacity but also the type of collection to use.</span></span> <span data-ttu-id="006c2-140">Örneğin, ilk <xref:System.Collections.Concurrent.ConcurrentQueue%601> çıkar (FIFO) davranışını veya <xref:System.Collections.Concurrent.ConcurrentStack%601> en son bir for-Out (LIFO) davranışını belirtebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="006c2-140">For example, you could specify a <xref:System.Collections.Concurrent.ConcurrentQueue%601> for first in-first out (FIFO) behavior, or a <xref:System.Collections.Concurrent.ConcurrentStack%601> for last in-first out (LIFO) behavior.</span></span> <span data-ttu-id="006c2-141">Arabirimini uygulayan herhangi bir koleksiyon sınıfını kullanabilirsiniz <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> .</span><span class="sxs-lookup"><span data-stu-id="006c2-141">You can use any collection class that implements the <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> interface.</span></span> <span data-ttu-id="006c2-142">İçin varsayılan koleksiyon türü <xref:System.Collections.Concurrent.BlockingCollection%601> <xref:System.Collections.Concurrent.ConcurrentQueue%601> .</span><span class="sxs-lookup"><span data-stu-id="006c2-142">The default collection type for <xref:System.Collections.Concurrent.BlockingCollection%601> is <xref:System.Collections.Concurrent.ConcurrentQueue%601>.</span></span> <span data-ttu-id="006c2-143">Aşağıdaki kod örneği, <xref:System.Collections.Concurrent.BlockingCollection%601> 1000 kapasiteye sahip dizelerin nasıl oluşturulacağını gösterir ve şunu kullanır <xref:System.Collections.Concurrent.ConcurrentBag%601> :</span><span class="sxs-lookup"><span data-stu-id="006c2-143">The following code example shows how to create a <xref:System.Collections.Concurrent.BlockingCollection%601> of strings that has a capacity of 1000 and uses a <xref:System.Collections.Concurrent.ConcurrentBag%601>:</span></span>  
  
```vb  
Dim bc = New BlockingCollection(Of String)(New ConcurrentBag(Of String()), 1000)  
```  
  
```csharp  
BlockingCollection<string> bc = new BlockingCollection<string>(new ConcurrentBag<string>(), 1000 );  
```  
  
 <span data-ttu-id="006c2-144">Daha fazla bilgi için bkz. [nasıl yapılır: koleksiyona sınırlama ve engelleme Işlevi ekleme](how-to-add-bounding-and-blocking.md).</span><span class="sxs-lookup"><span data-stu-id="006c2-144">For more information, see [How to: Add Bounding and Blocking Functionality to a Collection](how-to-add-bounding-and-blocking.md).</span></span>  
  
## <a name="ienumerable-support"></a><span data-ttu-id="006c2-145">IEnumerable desteği</span><span class="sxs-lookup"><span data-stu-id="006c2-145">IEnumerable Support</span></span>  
 <span data-ttu-id="006c2-146"><xref:System.Collections.Concurrent.BlockingCollection%601>, bir <xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A> `foreach` `For Each` koleksiyon tamamlanana kadar öğeleri kaldırmak için (Visual Basic olarak), boş olduğu ve daha fazla öğe eklenecek bir yöntem sağlar.</span><span class="sxs-lookup"><span data-stu-id="006c2-146"><xref:System.Collections.Concurrent.BlockingCollection%601> provides a <xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A> method that enables consumers to use `foreach` (`For Each` in Visual Basic) to remove items until the collection is completed, which means it is empty and no more items will be added.</span></span> <span data-ttu-id="006c2-147">Daha fazla bilgi için bkz. [nasıl yapılır: bir BlockingCollection Içindeki öğeleri kaldırmak Için foreach kullanma](how-to-use-foreach-to-remove.md).</span><span class="sxs-lookup"><span data-stu-id="006c2-147">For more information, see [How to: Use ForEach to Remove Items in a BlockingCollection](how-to-use-foreach-to-remove.md).</span></span>  
  
## <a name="using-many-blockingcollections-as-one"></a><span data-ttu-id="006c2-148">Birçok BlockingCollections 'ı tek tek kullanma</span><span class="sxs-lookup"><span data-stu-id="006c2-148">Using Many BlockingCollections As One</span></span>  
 <span data-ttu-id="006c2-149">Bir tüketicinin birden çok koleksiyondan öğe eşzamanlı olarak üstlenilmesi gereken senaryolarda, diziler oluşturabilir <xref:System.Collections.Concurrent.BlockingCollection%601> ve <xref:System.Collections.Concurrent.BlockingCollection%601.TakeFromAny%2A> <xref:System.Collections.Concurrent.BlockingCollection%601.AddToAny%2A> dizideki koleksiyonlara eklenecek ya da bu koleksiyondan alma yapılacak statik yöntemleri kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="006c2-149">For scenarios in which a consumer needs to take items from multiple collections simultaneously, you can create arrays of <xref:System.Collections.Concurrent.BlockingCollection%601> and use the static methods such as <xref:System.Collections.Concurrent.BlockingCollection%601.TakeFromAny%2A> and <xref:System.Collections.Concurrent.BlockingCollection%601.AddToAny%2A> that will add to or take from any of the collections in the array.</span></span> <span data-ttu-id="006c2-150">Bir koleksiyon engelliyorsa, yöntemi, işlemi gerçekleştirebilecek bir tane bulana kadar hemen başka bir yöntem dener.</span><span class="sxs-lookup"><span data-stu-id="006c2-150">If one collection is blocking, the method immediately tries another until it finds one that can perform the operation.</span></span> <span data-ttu-id="006c2-151">Daha fazla bilgi için bkz. [nasıl yapılır: bir işlem hattında engelleme koleksiyonlarının dizilerini kullanma](how-to-use-arrays-of-blockingcollections.md).</span><span class="sxs-lookup"><span data-stu-id="006c2-151">For more information, see [How to: Use Arrays of Blocking Collections in a Pipeline](how-to-use-arrays-of-blockingcollections.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="006c2-152">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="006c2-152">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- [<span data-ttu-id="006c2-153">Koleksiyonlar ve veri yapıları</span><span class="sxs-lookup"><span data-stu-id="006c2-153">Collections and Data Structures</span></span>](../index.md)
- [<span data-ttu-id="006c2-154">İş parçacığı güvenli Koleksiyonlar</span><span class="sxs-lookup"><span data-stu-id="006c2-154">Thread-Safe Collections</span></span>](index.md)
