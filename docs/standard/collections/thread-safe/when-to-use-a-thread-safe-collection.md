---
title: Bir İş Parçacığı Koleksiyonunun Ne Zaman Kullanılacağı
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- thread-safe collections, when to upgrade
ms.assetid: a9babe97-e457-4ff3-b528-a1bc940d5320
author: mairaw
ms.author: mairaw
ms.openlocfilehash: eefa1b52907525059b3403e7eb20542d3b5a5c73
ms.sourcegitcommit: 64f4baed249341e5bf64d1385bf48e3f2e1a0211
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 09/07/2018
ms.locfileid: "44131704"
---
# <a name="when-to-use-a-thread-safe-collection"></a><span data-ttu-id="c8363-102">Bir İş Parçacığı Koleksiyonunun Ne Zaman Kullanılacağı</span><span class="sxs-lookup"><span data-stu-id="c8363-102">When to Use a Thread-Safe Collection</span></span>
<span data-ttu-id="c8363-103">[!INCLUDE[net_v40_long](../../../../includes/net-v40-long-md.md)] Desteklemek için özel olarak tasarlanan beş yeni koleksiyon türlerini tanıtır çok iş parçacıklı ekleme ve kaldırma işlemleri.</span><span class="sxs-lookup"><span data-stu-id="c8363-103">The [!INCLUDE[net_v40_long](../../../../includes/net-v40-long-md.md)] introduces five new collection types that are specially designed to support multi-threaded add and remove operations.</span></span> <span data-ttu-id="c8363-104">İş parçacığı güvenliği sağlamak için bu yeni türleri çeşitli verimli kilitleme ve kilitsiz eşitleme mekanizmaları kullanın.</span><span class="sxs-lookup"><span data-stu-id="c8363-104">To achieve thread-safety, these new types use various kinds of efficient locking and lock-free synchronization mechanisms.</span></span> <span data-ttu-id="c8363-105">Eşitleme için bir işlem yükü ekler.</span><span class="sxs-lookup"><span data-stu-id="c8363-105">Synchronization adds overhead to an operation.</span></span> <span data-ttu-id="c8363-106">Ek yük miktarı kullanılan eşitleme türü ve gerçekleştirilen işlemleri türünü eşzamanlı koleksiyon erişmeye çalıştığınız iş parçacığı sayısı gibi diğer faktörlere bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="c8363-106">The amount of overhead depends on the kind of synchronization that is used, the kind of operations that are performed, and other factors such as the number of threads that are trying to concurrently access the collection.</span></span>  
  
 <span data-ttu-id="c8363-107">Bazı senaryolarda, eşitleme ek yükü göz ardı edilebilir ve çok iş parçacıklı türü önemli ölçüde daha hızlı gerçekleştirin ve dış bir kilit tarafından Korumalı iş parçacığı güvenli olmayan karşılığını daha çok daha iyi ölçeklendirme sağlar.</span><span class="sxs-lookup"><span data-stu-id="c8363-107">In some scenarios, synchronization overhead is negligible and enables the multi-threaded type to perform significantly faster and scale far better than its non-thread-safe equivalent when protected by an external lock.</span></span> <span data-ttu-id="c8363-108">Diğer senaryolarda, yükü gerçekleştirmek ve aynı hakkında veya türün dışarıdan kilitli, iş parçacığı güvenli olmayan sürümü daha yavaş ölçeklendirmek iş parçacığı türü neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="c8363-108">In other scenarios, the overhead can cause the thread-safe type to perform and scale about the same or even more slowly than the externally-locked, non-thread-safe version of the type.</span></span>  
  
 <span data-ttu-id="c8363-109">Aşağıdaki bölümlerde, okuma etrafında bir kullanıcı tarafından sağlanan kilit sahip iş parçacığı güvenli olmayan karşılığını karşı bir iş parçacığı güvenli koleksiyonu kullanmanız ve yazma işlemlerinin ne zaman hakkında genel rehberlik sağlar.</span><span class="sxs-lookup"><span data-stu-id="c8363-109">The following sections provide general guidance about when to use a thread-safe collection versus its non-thread-safe equivalent that has a user-provided lock around its read and write operations.</span></span> <span data-ttu-id="c8363-110">Performans çok sayıda etkene bağlı olarak farklılık gösterebileceğinden, rehberlik belirli değil ve her koşulda mutlaka geçerli değil.</span><span class="sxs-lookup"><span data-stu-id="c8363-110">Because performance may vary depending on many factors, the guidance is not specific and is not necessarily valid in all circumstances.</span></span> <span data-ttu-id="c8363-111">Performans çok önemli ise, hangi koleksiyon türünün kullanılacağını belirlemek için en iyi yolu temsil eden bilgisayar yapılandırmalarını ve yükleri göre performansını ölçmek için ise.</span><span class="sxs-lookup"><span data-stu-id="c8363-111">If performance is very important, then the best way to determine which collection type to use is to measure performance based on representative computer configurations and loads.</span></span> <span data-ttu-id="c8363-112">Bu belge aşağıdaki terimler kullanılmaktadır:</span><span class="sxs-lookup"><span data-stu-id="c8363-112">This document uses the following terms:</span></span>  
  
 <span data-ttu-id="c8363-113">*Saf üretici-tüketici senaryosu*</span><span class="sxs-lookup"><span data-stu-id="c8363-113">*Pure producer-consumer scenario*</span></span>  
 <span data-ttu-id="c8363-114">Verilen herhangi bir iş parçacığı ekleme veya öğeleri, ancak ikisini birden kaldırılıyor.</span><span class="sxs-lookup"><span data-stu-id="c8363-114">Any given thread is either adding or removing elements, but not both.</span></span>  
  
 <span data-ttu-id="c8363-115">*Üretici-tüketici karışık senaryo*</span><span class="sxs-lookup"><span data-stu-id="c8363-115">*Mixed producer-consumer scenario*</span></span>  
 <span data-ttu-id="c8363-116">Verilen herhangi bir iş parçacığı hem ekleme ve öğelerin kaldırılması.</span><span class="sxs-lookup"><span data-stu-id="c8363-116">Any given thread is both adding and removing elements.</span></span>  
  
 <span data-ttu-id="c8363-117">*Hızlandırmayı*</span><span class="sxs-lookup"><span data-stu-id="c8363-117">*Speedup*</span></span>  
 <span data-ttu-id="c8363-118">Algoritmik performans aynı senaryosunda başka bir türüne göre daha hızlı.</span><span class="sxs-lookup"><span data-stu-id="c8363-118">Faster algorithmic performance relative to another type in the same scenario.</span></span>  
  
 <span data-ttu-id="c8363-119">*Ölçeklenebilirlik*</span><span class="sxs-lookup"><span data-stu-id="c8363-119">*Scalability*</span></span>  
 <span data-ttu-id="c8363-120">Çekirdek bilgisayarda orantılıdır performansın artış.</span><span class="sxs-lookup"><span data-stu-id="c8363-120">The increase in performance that is proportional to the number of cores on the computer.</span></span> <span data-ttu-id="c8363-121">İki çekirdek üzerinde gösterilenden ölçeklenen bir algoritma sekiz çekirdeği daha hızlı gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="c8363-121">An algorithm that scales performs faster on eight cores than it does on two cores.</span></span>  
  
## <a name="concurrentqueuet-vs-queuet"></a><span data-ttu-id="c8363-122">ConcurrentQueue(T) vs. Queue(T)</span><span class="sxs-lookup"><span data-stu-id="c8363-122">ConcurrentQueue(T) vs. Queue(T)</span></span>  
 <span data-ttu-id="c8363-123">Saf üretici-tüketici senaryolarında, işleme süresinin her öğe için olduğu çok küçük (bazı yönergeler), ardından <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> büyüklükteki performans avantajlarının üzerinden sunabilir bir <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType> dış bir kilit sahip.</span><span class="sxs-lookup"><span data-stu-id="c8363-123">In pure producer-consumer scenarios, where the processing time for each element is very small (a few instructions), then <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> can offer modest performance benefits over a <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType> that has an external lock.</span></span> <span data-ttu-id="c8363-124">Bu senaryoda, <xref:System.Collections.Concurrent.ConcurrentQueue%601> tek bir adanmış iş parçacığı queuing ve tek bir adanmış iş parçacığı kuyruktan çıkarılması olduğunda en iyi şekilde çalışır.</span><span class="sxs-lookup"><span data-stu-id="c8363-124">In this scenario, <xref:System.Collections.Concurrent.ConcurrentQueue%601> performs best when one dedicated thread is queuing and one dedicated thread is de-queuing.</span></span> <span data-ttu-id="c8363-125">Bu kural, ardından zorlama, <xref:System.Collections.Generic.Queue%601> bile gerçekleştirebileceği kıyasla biraz daha hızlı <xref:System.Collections.Concurrent.ConcurrentQueue%601> birden çok çekirdeğe sahip bilgisayarlarda.</span><span class="sxs-lookup"><span data-stu-id="c8363-125">If you do not enforce this rule, then <xref:System.Collections.Generic.Queue%601> might even perform slightly faster than <xref:System.Collections.Concurrent.ConcurrentQueue%601> on computers that have multiple cores.</span></span>  
  
 <span data-ttu-id="c8363-126">Ne zaman işlem süresi yaklaşık 500 FLOPS (kayan nokta işlemleri) veya daha sonra iki iş parçacığı kuralı uygulanmaz <xref:System.Collections.Concurrent.ConcurrentQueue%601>, daha sonra çok iyi bir ölçeklendirilebilirliğe sahip.</span><span class="sxs-lookup"><span data-stu-id="c8363-126">When processing time is around 500 FLOPS (floating point operations) or more, then the two-thread rule does not apply to <xref:System.Collections.Concurrent.ConcurrentQueue%601>, which then has very good scalability.</span></span> <span data-ttu-id="c8363-127"><xref:System.Collections.Generic.Queue%601> Bu senaryoda iyi ölçeklenmez.</span><span class="sxs-lookup"><span data-stu-id="c8363-127"><xref:System.Collections.Generic.Queue%601> does not scale well in this scenario.</span></span>  
  
 <span data-ttu-id="c8363-128">İşlem süresi çok küçük olduğunda, üretici-tüketici senaryoları, karma bir <xref:System.Collections.Generic.Queue%601> dış olan kilit ölçeklenen daha iyi <xref:System.Collections.Concurrent.ConcurrentQueue%601> yapar.</span><span class="sxs-lookup"><span data-stu-id="c8363-128">In mixed producer-consumer scenarios, when the processing time is very small, a <xref:System.Collections.Generic.Queue%601> that has an external lock scales better than <xref:System.Collections.Concurrent.ConcurrentQueue%601> does.</span></span> <span data-ttu-id="c8363-129">Ancak, işleme süresi olduğunda yaklaşık 500 FLOPS veya daha sonra <xref:System.Collections.Concurrent.ConcurrentQueue%601> daha iyi ölçeklenir.</span><span class="sxs-lookup"><span data-stu-id="c8363-129">However, when processing time is around 500 FLOPS or more, then the <xref:System.Collections.Concurrent.ConcurrentQueue%601> scales better.</span></span>  
  
## <a name="concurrentstack-vs-stack"></a><span data-ttu-id="c8363-130">ConcurrentStack vs. Yığın</span><span class="sxs-lookup"><span data-stu-id="c8363-130">ConcurrentStack vs. Stack</span></span>  
 <span data-ttu-id="c8363-131">Saf üretici-tüketici senaryolarında, işleme süresinin ardından çok küçük olduğunda <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> ve <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> dış olan kilit hakkında bir adanmış gönderme iş parçacığı ve adanmış bir yığından kaldırılıyor iş parçacığı ile aynı büyük olasılıkla gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="c8363-131">In pure producer-consumer scenarios, when processing time is very small, then <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> and <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> that has an external lock will probably perform about the same with one dedicated pushing thread and one dedicated popping thread.</span></span> <span data-ttu-id="c8363-132">Ancak, sayısı arttıkça iş parçacığı, iki türü de artan Çekişme nedeniyle yavaşlamasına ve <xref:System.Collections.Generic.Stack%601> gerçekleştirebileceğiniz daha iyi <xref:System.Collections.Concurrent.ConcurrentStack%601>.</span><span class="sxs-lookup"><span data-stu-id="c8363-132">However, as the number of threads increases, both types slow down because of increased contention, and <xref:System.Collections.Generic.Stack%601> might perform better than <xref:System.Collections.Concurrent.ConcurrentStack%601>.</span></span> <span data-ttu-id="c8363-133">İşlem süresi yaklaşık 500 FLOPS olduğunda veya daha fazla ve ardından her iki tür ölçekli olarak aynı fiyat hakkında.</span><span class="sxs-lookup"><span data-stu-id="c8363-133">When processing time is around 500 FLOPS or more, then both types scale at about the same rate.</span></span>  
  
 <span data-ttu-id="c8363-134">Üretici-tüketici senaryoları, karma olarak <xref:System.Collections.Concurrent.ConcurrentStack%601> küçük ve büyük iş yükleri için daha hızlıdır.</span><span class="sxs-lookup"><span data-stu-id="c8363-134">In mixed producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentStack%601> is faster for both small and large workloads.</span></span>  
  
 <span data-ttu-id="c8363-135">Kullanımını <xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> ve <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> erişim sürelerini önemli ölçüde hızlandırmak.</span><span class="sxs-lookup"><span data-stu-id="c8363-135">The use of the <xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> and <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> may greatly speed up access times.</span></span>  
  
## <a name="concurrentdictionary-vs-dictionary"></a><span data-ttu-id="c8363-136">ConcurrentDictionary vs. Sözlük</span><span class="sxs-lookup"><span data-stu-id="c8363-136">ConcurrentDictionary vs. Dictionary</span></span>  
 <span data-ttu-id="c8363-137">Genel olarak, bir <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> hiçbir senaryoda Burada, ekleme ve anahtarlar veya değerler aynı anda birden çok iş parçacığından güncelleştiriliyor.</span><span class="sxs-lookup"><span data-stu-id="c8363-137">In general, use a <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> in any scenario where you are adding and updating keys or values concurrently from multiple threads.</span></span> <span data-ttu-id="c8363-138">Sık güncelleştirmeler ve nispeten az okuma içeren senaryolarda <xref:System.Collections.Concurrent.ConcurrentDictionary%602> genellikle büyüklükteki avantaj sunar.</span><span class="sxs-lookup"><span data-stu-id="c8363-138">In scenarios that involve frequent updates and relatively few reads, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> generally offers modest benefits.</span></span> <span data-ttu-id="c8363-139">Birçok okuma ve çok sayıda güncelleştirme içeren senaryolarda <xref:System.Collections.Concurrent.ConcurrentDictionary%602> genel olarak, herhangi bir sayıda çekirdek bilgisayarlarda önemli ölçüde daha hızlı gerçekleşir.</span><span class="sxs-lookup"><span data-stu-id="c8363-139">In scenarios that involve many reads and many updates, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> generally is significantly faster on computers that have any number of cores.</span></span>  
  
 <span data-ttu-id="c8363-140">Sık güncelleştirmeler içeren senaryolarda eşzamanlılık derecesini artırabilirsiniz <xref:System.Collections.Concurrent.ConcurrentDictionary%602> ve performansı daha fazla çekirdeğe sahip bilgisayarlarda artırır olup olmadığını görmek için ardından ölçün.</span><span class="sxs-lookup"><span data-stu-id="c8363-140">In scenarios that involve frequent updates, you can increase the degree of concurrency in the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> and then measure to see whether performance increases on computers that have more cores.</span></span> <span data-ttu-id="c8363-141">Eşzamanlılık düzeyi değiştirme, genel işlemlerini mümkün olduğunca kaçının.</span><span class="sxs-lookup"><span data-stu-id="c8363-141">If you change the concurrency level, avoid global operations as much as possible.</span></span>  
  
 <span data-ttu-id="c8363-142">Anahtar ya da değerler yalnızca okuma yapıyorsanız <xref:System.Collections.Generic.Dictionary%602> sözlük tüm iş parçacıklarının engellemelerinden değiştirilmeyen eşitleme gereklidir çünkü daha hızlıdır.</span><span class="sxs-lookup"><span data-stu-id="c8363-142">If you are only reading key or values, the <xref:System.Collections.Generic.Dictionary%602> is faster because no synchronization is required if the dictionary is not being modified by any threads.</span></span>  
  
## <a name="concurrentbag"></a><span data-ttu-id="c8363-143">ConcurrentBag</span><span class="sxs-lookup"><span data-stu-id="c8363-143">ConcurrentBag</span></span>  
 <span data-ttu-id="c8363-144">Saf üretici-tüketici senaryolarda <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> büyük olasılıkla diğer eşzamanlı koleksiyon türleri daha yavaş gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="c8363-144">In pure producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> will probably perform more slowly than the other concurrent collection types.</span></span>  
  
 <span data-ttu-id="c8363-145">Üretici-tüketici senaryoları, karma olarak <xref:System.Collections.Concurrent.ConcurrentBag%601> genellikle çok daha hızlı ve daha ölçeklenebilir daha küçük ve büyük ölçekli iş yükleri için başka bir eşzamanlı koleksiyon türü.</span><span class="sxs-lookup"><span data-stu-id="c8363-145">In mixed producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentBag%601> is generally much faster and more scalable than any other concurrent collection type for both large and small workloads.</span></span>  
  
## <a name="blockingcollection"></a><span data-ttu-id="c8363-146">BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="c8363-146">BlockingCollection</span></span>  
 <span data-ttu-id="c8363-147">Sınırlama ve engelleme semantiği gerekli olduğunda <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> büyük olasılıkla herhangi bir özel uygulama daha hızlı gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="c8363-147">When bounding and blocking semantics are required, <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> will probably perform faster than any custom implementation.</span></span> <span data-ttu-id="c8363-148">Ayrıca, zengin iptal, numaralandırma ve özel durum işleme de destekler.</span><span class="sxs-lookup"><span data-stu-id="c8363-148">It also supports rich cancellation, enumeration, and exception handling.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c8363-149">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="c8363-149">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>  
- [<span data-ttu-id="c8363-150">İş Parçacığı Güvenli Koleksiyonları</span><span class="sxs-lookup"><span data-stu-id="c8363-150">Thread-Safe Collections</span></span>](../../../../docs/standard/collections/thread-safe/index.md)  
- [<span data-ttu-id="c8363-151">Paralel Programlama</span><span class="sxs-lookup"><span data-stu-id="c8363-151">Parallel Programming</span></span>](../../../../docs/standard/parallel-programming/index.md)
