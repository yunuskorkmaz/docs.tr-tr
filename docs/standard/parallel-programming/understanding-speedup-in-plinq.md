---
title: PLINQ'te Hızlandırmayı Anlama
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- PLINQ queries, performance tuning
ms.assetid: 53706c7e-397d-467a-98cd-c0d1fd63ba5e
ms.openlocfilehash: 07b5027d560a4caccc6c0a516c3f70c11df6be83
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/30/2019
ms.locfileid: "73139912"
---
# <a name="understanding-speedup-in-plinq"></a><span data-ttu-id="e3297-102">PLINQ'te Hızlandırmayı Anlama</span><span class="sxs-lookup"><span data-stu-id="e3297-102">Understanding Speedup in PLINQ</span></span>
<span data-ttu-id="e3297-103">PLıNQ 'in birincil amacı, çok çekirdekli bilgisayarlarda sorgu temsilcilerini paralel olarak yürüterek LINQ to Objects sorgularının yürütülmesini hızlandırmaya yönelik olur.</span><span class="sxs-lookup"><span data-stu-id="e3297-103">The primary purpose of PLINQ is to speed up the execution of LINQ to Objects queries by executing the query delegates in parallel on multi-core computers.</span></span> <span data-ttu-id="e3297-104">PLıNQ, bir kaynak koleksiyondaki her öğenin işlenmesi bağımsız temsilciler arasında herhangi bir paylaşılan durum olmadan bağımsız olduğunda en iyi şekilde çalışır.</span><span class="sxs-lookup"><span data-stu-id="e3297-104">PLINQ performs best when the processing of each element in a source collection is independent, with no shared state involved among the individual delegates.</span></span> <span data-ttu-id="e3297-105">Bu gibi işlemler LINQ to Objects ve PLıNQ ' de ortaktır ve genellikle birden çok iş parçacığında zamanlamaya göre kolayca bir şekilde çalıştıkları için "*delightfully Parallel*" olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="e3297-105">Such operations are common in LINQ to Objects and PLINQ, and are often called "*delightfully parallel*" because they lend themselves easily to scheduling on multiple threads.</span></span> <span data-ttu-id="e3297-106">Ancak, tüm sorgular tamamen eş dışı paralel işlemlerden oluşamaz; Çoğu durumda, bir sorgu paralelleştirilmedi veya paralel yürütmeyi yavaşlatabilecek bazı işleçleri içerir.</span><span class="sxs-lookup"><span data-stu-id="e3297-106">However, not all queries consist entirely of delightfully parallel operations; in most cases, a query involves some operators that either cannot be parallelized, or that slow down parallel execution.</span></span> <span data-ttu-id="e3297-107">Tamamen de tamamen paralel olan sorgularda, PLıNQ hala veri kaynağını bölümleyip iş parçacıkları üzerinde işi zamanlamaya ve genellikle sorgu tamamlandığında sonuçları birleştirmelidir.</span><span class="sxs-lookup"><span data-stu-id="e3297-107">And even with queries that are entirely delightfully parallel, PLINQ must still partition the data source and schedule the work on the threads, and usually merge the results when the query completes.</span></span> <span data-ttu-id="e3297-108">Tüm bu işlemler paralelleştirme hesaplama maliyetine ekler; paralel hale getirme ekleme maliyetlerine *ek yük*denir.</span><span class="sxs-lookup"><span data-stu-id="e3297-108">All these operations add to the computational cost of parallelization; these costs of adding parallelization are called *overhead*.</span></span> <span data-ttu-id="e3297-109">Bir PLıNQ sorgusunda en iyi performansı elde etmek için, amaç paralel olan parçaları en üst düzeye çıkarmaktır ve ek yük gerektiren parçaları en aza indirmektir.</span><span class="sxs-lookup"><span data-stu-id="e3297-109">To achieve optimum performance in a PLINQ query, the goal is to maximize the parts that are delightfully parallel and minimize the parts that require overhead.</span></span> <span data-ttu-id="e3297-110">Bu makalede, doğru sonuçları sunarken mümkün olduğunca verimli olan PLıNQ sorgularını yazmanıza yardımcı olacak bilgiler sağlanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="e3297-110">This article provides information that will help you write PLINQ queries that are as efficient as possible while still yielding correct results.</span></span>  
  
## <a name="factors-that-impact-plinq-query-performance"></a><span data-ttu-id="e3297-111">PLıNQ sorgu performansını etkileyen faktörler</span><span class="sxs-lookup"><span data-stu-id="e3297-111">Factors that Impact PLINQ Query Performance</span></span>  
 <span data-ttu-id="e3297-112">Aşağıdaki bölümlerde, paralel sorgu performansını etkileyen en önemli faktörlerin bazıları listelenmiştir.</span><span class="sxs-lookup"><span data-stu-id="e3297-112">The following sections lists some of the most important factors that impact parallel query performance.</span></span> <span data-ttu-id="e3297-113">Bunlar, her durumda sorgu performansını tahmin etmek için yeterli olmayan genel deyimlerdir.</span><span class="sxs-lookup"><span data-stu-id="e3297-113">These are general statements that by themselves are not sufficient to predict query performance in all cases.</span></span> <span data-ttu-id="e3297-114">Her zaman olduğu gibi, bilgisayarlardaki belirli sorguların gerçek performansını, bir dizi temsili yapılandırması ve yükleri ile ölçmek önemlidir.</span><span class="sxs-lookup"><span data-stu-id="e3297-114">As always, it is important to measure actual performance of specific queries on computers with a range of representative configurations and loads.</span></span>  
  
1. <span data-ttu-id="e3297-115">Genel çalışmanın hesaplama maliyeti.</span><span class="sxs-lookup"><span data-stu-id="e3297-115">Computational cost of the overall work.</span></span>  
  
     <span data-ttu-id="e3297-116">Bir PLıNQ sorgusunun daha hızlı bir şekilde elde edilebilmesi için, ek yükü kaydırarak çok fazla sayıda paralel iş olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="e3297-116">To achieve speedup, a PLINQ query must have enough delightfully parallel work to offset the overhead.</span></span> <span data-ttu-id="e3297-117">İş, her temsilcinin hesaplama maliyeti olarak kaynak koleksiyondaki öğelerin sayısıyla çarpılarak ifade edilebilir.</span><span class="sxs-lookup"><span data-stu-id="e3297-117">The work can be expressed as the computational cost of each delegate multiplied by the number of elements in the source collection.</span></span> <span data-ttu-id="e3297-118">Bir işlemin paralelleştirilmesine ne olduğunu varsayarsak, daha fazla hesaplama, daha iyi hale getirilmiş bir fırsattır.</span><span class="sxs-lookup"><span data-stu-id="e3297-118">Assuming that an operation can be parallelized, the more computationally expensive it is, the greater the opportunity for speedup.</span></span> <span data-ttu-id="e3297-119">Örneğin, bir işlevin yürütülmesi için bir milisaniyelik sürerse 1000 öğeden oluşan sıralı bir sorgu bu işlemi gerçekleştirmek için bir saniye sürer, ancak dört çekirdekli bir bilgisayardaki paralel sorgu yalnızca 250 milisaniyeye sahip olur.</span><span class="sxs-lookup"><span data-stu-id="e3297-119">For example, if a function takes one millisecond to execute, a sequential query over 1000 elements will take one second to perform that operation, whereas a parallel query on a computer with four cores might take only 250 milliseconds.</span></span> <span data-ttu-id="e3297-120">Bu, 750 milisaniyeden daha hızlı bir hızlandırın verir.</span><span class="sxs-lookup"><span data-stu-id="e3297-120">This yields a speedup of 750 milliseconds.</span></span> <span data-ttu-id="e3297-121">İşlevin her öğe için bir saniyede yürütülmesi gerekiyorsa, bu durumda hızlı bir süre 750 saniye olur.</span><span class="sxs-lookup"><span data-stu-id="e3297-121">If the function required one second to execute for each element, then the speedup would be 750 seconds.</span></span> <span data-ttu-id="e3297-122">Temsilci çok pahalıdır, PLıNQ, kaynak koleksiyondaki yalnızca birkaç öğeyle önemli bir hızlı işlem sunabilir.</span><span class="sxs-lookup"><span data-stu-id="e3297-122">If the delegate is very expensive, then PLINQ might offer significant speedup with only a few items in the source collection.</span></span> <span data-ttu-id="e3297-123">Buna karşılık, önemsiz temsilcilerle küçük kaynak koleksiyonları genellikle PLıNQ için iyi adaylardır.</span><span class="sxs-lookup"><span data-stu-id="e3297-123">Conversely, small source collections with trivial delegates are generally not good candidates for PLINQ.</span></span>  
  
     <span data-ttu-id="e3297-124">Aşağıdaki örnekte, select işlevinin çok sayıda iş içerdiği varsayılarak, queryA PLıNQ için iyi bir adaydır.</span><span class="sxs-lookup"><span data-stu-id="e3297-124">In the following example, queryA is probably a good candidate for PLINQ, assuming that its Select function involves a lot of work.</span></span> <span data-ttu-id="e3297-125">Select ifadesinde yeterli iş olmadığından ve paralelleştirme yükünün en fazla ya da tüm hızlı bir şekilde kaydırılacağı için queryB büyük olasılıkla iyi bir aday değildir.</span><span class="sxs-lookup"><span data-stu-id="e3297-125">queryB is probably not a good candidate because there is not enough work in the Select statement, and the overhead of parallelization will offset most or all of the speedup.</span></span>  
  
    ```vb  
    Dim queryA = From num In numberList.AsParallel()  
                 Select ExpensiveFunction(num); 'good for PLINQ  
  
    Dim queryB = From num In numberList.AsParallel()  
                 Where num Mod 2 > 0  
                 Select num; 'not as good for PLINQ  
    ```  
  
    ```csharp  
    var queryA = from num in numberList.AsParallel()  
                 select ExpensiveFunction(num); //good for PLINQ  
  
    var queryB = from num in numberList.AsParallel()  
                 where num % 2 > 0  
                 select num; //not as good for PLINQ  
    ```  
  
2. <span data-ttu-id="e3297-126">Sistemdeki mantıksal çekirdek sayısı (paralellik derecesi).</span><span class="sxs-lookup"><span data-stu-id="e3297-126">The number of logical cores on the system (degree of parallelism).</span></span>  
  
     <span data-ttu-id="e3297-127">Bu nokta, önceki bölümde yer alan ve daha fazla çekirdeğe sahip makinelerde daha hızlı bir şekilde paralel şekilde çalışan sorgular daha fazla eş zamanlı iş parçacığı arasında ayrılamadığından, daha fazla çekirdeğe sahip olan çok daha açık bir eş olabilir.</span><span class="sxs-lookup"><span data-stu-id="e3297-127">This point is an obvious corollary to the previous section, queries that are delightfully parallel run faster on machines with more cores because the work can be divided among more concurrent threads.</span></span> <span data-ttu-id="e3297-128">Toplam hızlı çalışma miktarı, sorgunun genel işinin toplam yüzdesine paralelleştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="e3297-128">The overall amount of speedup depends on what percentage of the overall work of the query is parallelizable.</span></span> <span data-ttu-id="e3297-129">Ancak, tüm sorguların dört çekirdekli bilgisayar olarak sekiz çekirdekli bir bilgisayarda hızlı bir şekilde çalışacağını varsaymayın.</span><span class="sxs-lookup"><span data-stu-id="e3297-129">However, do not assume that all queries will run twice as fast on an eight core computer as a four core computer.</span></span> <span data-ttu-id="e3297-130">En iyi performans için sorguları ayarlamaya çalışırken, gerçek sonuçların çeşitli çekirdekler içeren bilgisayarlarda ölçülmesi önemlidir.</span><span class="sxs-lookup"><span data-stu-id="e3297-130">When tuning queries for optimal performance, it is important to measure actual results on computers with various numbers of cores.</span></span> <span data-ttu-id="e3297-131">Bu nokta #1 nokta ile ilgilidir: daha büyük bilgi işlem kaynaklarından yararlanmak için daha büyük veri kümeleri gereklidir.</span><span class="sxs-lookup"><span data-stu-id="e3297-131">This point is related to point #1: larger datasets are required to take advantage of greater computing resources.</span></span>  
  
3. <span data-ttu-id="e3297-132">İşlem sayısı ve türü.</span><span class="sxs-lookup"><span data-stu-id="e3297-132">The number and kind of operations.</span></span>  
  
     <span data-ttu-id="e3297-133">PLıNQ, kaynak dizideki öğelerin sırasını korumak için gerekli olduğu durumlar için Asorimli işleci sağlar.</span><span class="sxs-lookup"><span data-stu-id="e3297-133">PLINQ provides the AsOrdered operator for situations in which it is necessary to maintain the order of elements in the source sequence.</span></span> <span data-ttu-id="e3297-134">Sıralamaya ilişkin bir maliyet vardır, ancak bu maliyet genellikle Modest 'dir.</span><span class="sxs-lookup"><span data-stu-id="e3297-134">There is a cost associated with ordering, but this cost is usually modest.</span></span> <span data-ttu-id="e3297-135">GroupBy ve JOIN işlemleri aynı şekilde ek yüke neden olur.</span><span class="sxs-lookup"><span data-stu-id="e3297-135">GroupBy and Join operations likewise incur overhead.</span></span> <span data-ttu-id="e3297-136">PLıNQ, kaynak koleksiyondaki öğeleri herhangi bir sırada işlemeye izin verildiğinde en iyi şekilde çalışır ve bunları bir sonraki işleçle uygun hale gelir.</span><span class="sxs-lookup"><span data-stu-id="e3297-136">PLINQ performs best when it is allowed to process elements in the source collection in any order, and pass them to the next operator as soon as they are ready.</span></span> <span data-ttu-id="e3297-137">Daha fazla bilgi için bkz. [PLıNQ 'Te sıra koruma](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="e3297-137">For more information, see [Order Preservation in PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span></span>  
  
4. <span data-ttu-id="e3297-138">Sorgu yürütme biçimi.</span><span class="sxs-lookup"><span data-stu-id="e3297-138">The form of query execution.</span></span>  
  
     <span data-ttu-id="e3297-139">ToArray veya ToList çağırarak bir sorgunun sonuçlarını depoluyorsanız, tüm paralel iş parçacıklarından elde edilen sonuçlar tek veri yapısına birleştirilmelidir.</span><span class="sxs-lookup"><span data-stu-id="e3297-139">If you are storing the results of a query by calling ToArray or ToList, then the results from all parallel threads must be merged into the single data structure.</span></span> <span data-ttu-id="e3297-140">Bu, kaçınılmaz bir hesaplama maliyeti içerir.</span><span class="sxs-lookup"><span data-stu-id="e3297-140">This involves an unavoidable computational cost.</span></span> <span data-ttu-id="e3297-141">Benzer şekilde, bir foreach (her biri Visual Basic) döngüsünde sonuçları yinelemek istiyorsanız, çalışan iş parçacıklarının sonuçlarının Numaralandırıcı iş parçacığı üzerinde serileştirilmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="e3297-141">Likewise, if you iterate the results by using a foreach (For Each in Visual Basic) loop, the results from the worker threads need to be serialized onto the enumerator thread.</span></span> <span data-ttu-id="e3297-142">Ancak, her iş parçacığının sonucunu temel alan bazı eylemler gerçekleştirmek istiyorsanız, bu işi birden çok iş parçacığı üzerinde gerçekleştirmek için ForAll metodunu kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e3297-142">But if you just want to perform some action based on the result from each thread, you can use the ForAll method to perform this work on multiple threads.</span></span>  
  
5. <span data-ttu-id="e3297-143">Birleştirme seçeneklerinin türü.</span><span class="sxs-lookup"><span data-stu-id="e3297-143">The type of merge options.</span></span>  
  
     <span data-ttu-id="e3297-144">PLıNQ, çıktısını arabelleğe almak için yapılandırılabilir ve tüm sonuç kümesi üretildikten sonra tek seferde veya her seferinde bir kez oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="e3297-144">PLINQ can be configured to either buffer its output, and produce it in chunks or all at once after the entire result set is produced, or else to stream individual results as they are produced.</span></span> <span data-ttu-id="e3297-145">Daha önce, genel yürütme süresi azalır ve ikinci sonuçlar, diğer bir deyişle, diğer bir deyişle, sonuçlandırılan öğeler arasında</span><span class="sxs-lookup"><span data-stu-id="e3297-145">The former results in decreased overall execution time and the latter results in decreased latency between yielded elements.</span></span>  <span data-ttu-id="e3297-146">Birleştirme seçenekleri her zaman genel sorgu performansı üzerinde önemli bir etkiye sahip olmasa da, bir kullanıcının sonuçları görmeyi beklemesi gereken süreyi denetlemediğinden, algılanan performansı etkileyebilir.</span><span class="sxs-lookup"><span data-stu-id="e3297-146">While the merge options do not always have a major impact on overall query performance, they can impact perceived performance because they control how long a user must wait to see results.</span></span> <span data-ttu-id="e3297-147">Daha fazla bilgi için bkz. [PLıNQ 'Te birleştirme seçenekleri](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="e3297-147">For more information, see [Merge Options in PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span></span>  
  
6. <span data-ttu-id="e3297-148">Bölümleme türü.</span><span class="sxs-lookup"><span data-stu-id="e3297-148">The kind of partitioning.</span></span>  
  
     <span data-ttu-id="e3297-149">Bazı durumlarda, Dizin oluşturamayacak bir kaynak koleksiyonu üzerinde PLıNQ sorgusu, dengesiz bir iş yüküne neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="e3297-149">In some cases, a PLINQ query over an indexable source collection may result in an unbalanced work load.</span></span> <span data-ttu-id="e3297-150">Bu gerçekleştiğinde, özel bir bölümleyici oluşturarak sorgu performansını artırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e3297-150">When this occurs, you might be able to increase the query performance by creating a custom partitioner.</span></span> <span data-ttu-id="e3297-151">Daha fazla bilgi için bkz. [PLıNQ ve TPL Için Özel Bölümleyiciler](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span><span class="sxs-lookup"><span data-stu-id="e3297-151">For more information, see [Custom Partitioners for PLINQ and TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span></span>  
  
## <a name="when-plinq-chooses-sequential-mode"></a><span data-ttu-id="e3297-152">PLıNQ sıralı modu seçtiğinde</span><span class="sxs-lookup"><span data-stu-id="e3297-152">When PLINQ Chooses Sequential Mode</span></span>  
 <span data-ttu-id="e3297-153">PLıNQ, sorgu sırayla çalışır şekilde her zaman bir sorguyu en az hızlı bir şekilde yürütmeye çalışır.</span><span class="sxs-lookup"><span data-stu-id="e3297-153">PLINQ will always attempt to execute a query at least as fast as the query would run sequentially.</span></span> <span data-ttu-id="e3297-154">PLıNQ, Kullanıcı temsilcilerinin ne kadar pahalı olduğunu veya giriş kaynağının ne kadar büyük olduğunu fark etmez, bazı sorgu "şekillerini" arar.</span><span class="sxs-lookup"><span data-stu-id="e3297-154">Although PLINQ does not look at how computationally expensive the user delegates are, or how big the input source is, it does look for certain query "shapes."</span></span> <span data-ttu-id="e3297-155">Özellikle, genellikle bir sorgunun paralel modda daha yavaş yürütülmesine neden olan sorgu işleçlerini veya işleç birleşimlerini arar.</span><span class="sxs-lookup"><span data-stu-id="e3297-155">Specifically, it looks for query operators or combinations of operators that typically cause a query to execute more slowly in parallel mode.</span></span> <span data-ttu-id="e3297-156">Böyle bir şekil bulduğunda, PLıNQ varsayılan olarak sıralı moda geri döner.</span><span class="sxs-lookup"><span data-stu-id="e3297-156">When it finds such shapes, PLINQ by default falls back to sequential mode.</span></span>  
  
 <span data-ttu-id="e3297-157">Ancak, belirli bir sorgunun performansını ölçdikten sonra, aslında paralel modda daha hızlı çalıştığını belirleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e3297-157">However, after measuring a specific query's performance, you may determine that it actually runs faster in parallel mode.</span></span> <span data-ttu-id="e3297-158">Böyle durumlarda, paralel hale getirmek yöntemi <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> aracılığıyla <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> bayrağını kullanarak PLıNQ to sorgusunu kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e3297-158">In such cases you can use the <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> flag via the <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> method to instruct PLINQ to parallelize the query.</span></span> <span data-ttu-id="e3297-159">Daha fazla bilgi için bkz. [nasıl yapılır: PLıNQ 'Te yürütme modunu belirtme](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="e3297-159">For more information, see [How to: Specify the Execution Mode in PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span></span>  
  
 <span data-ttu-id="e3297-160">Aşağıdaki listede, PLıNQ 'ın varsayılan olarak sıralı modda yürütüleceği sorgu şekilleri açıklanmaktadır:</span><span class="sxs-lookup"><span data-stu-id="e3297-160">The following list describes the query shapes that PLINQ by default will execute in sequential mode:</span></span>  
  
- <span data-ttu-id="e3297-161">Bir SELECT, Indexed WHERE, Indexed SelectMany veya ElementAt yan tümcesi içeren sorgular, özgün dizinleri kaldırmış veya yeniden düzenlenmiş bir sıralama veya filtreleme işlecinden sonra.</span><span class="sxs-lookup"><span data-stu-id="e3297-161">Queries that contain a Select, indexed Where, indexed SelectMany, or ElementAt clause after an ordering or filtering operator that has removed or rearranged original indices.</span></span>  
  
- <span data-ttu-id="e3297-162">Al, TakeWhile, Skip, SkipWhile operatörü ve kaynak dizideki dizinlerin özgün sırada olmadığı sorgular.</span><span class="sxs-lookup"><span data-stu-id="e3297-162">Queries that contain a Take, TakeWhile, Skip, SkipWhile operator and where indices in the source sequence are not in the original order.</span></span>  
  
- <span data-ttu-id="e3297-163">ZIP veya SequenceEquals içeren sorgular, veri kaynaklarından biri özgün olarak sıralanmış bir dizine sahip olmadığı ve diğer veri kaynağı dizinlenebilir (yani bir dizi veya IList (T)).</span><span class="sxs-lookup"><span data-stu-id="e3297-163">Queries that contain Zip or SequenceEquals, unless one of the data sources has an originally ordered index and the other data source is indexable (i.e. an array or IList(T)).</span></span>  
  
- <span data-ttu-id="e3297-164">Dizine eklenebilir veri kaynaklarına uygulanmadığı takdirde Concat içeren sorgular.</span><span class="sxs-lookup"><span data-stu-id="e3297-164">Queries that contain Concat, unless it is applied to indexable data sources.</span></span>  
  
- <span data-ttu-id="e3297-165">Dizine eklenebilir bir veri kaynağına uygulanmadıysa ters içeren sorgular.</span><span class="sxs-lookup"><span data-stu-id="e3297-165">Queries that contain Reverse, unless applied to an indexable data source.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e3297-166">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="e3297-166">See also</span></span>

- [<span data-ttu-id="e3297-167">Paralel LINQ (PLINQ)</span><span class="sxs-lookup"><span data-stu-id="e3297-167">Parallel LINQ (PLINQ)</span></span>](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)
