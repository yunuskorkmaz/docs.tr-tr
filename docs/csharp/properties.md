---
title: Özellikler
description: Hakkında bilgi edinin C# hesaplanan değerler, geç değerlendirme doğrulama özellikleri içeren, özellikler, ve özellik bildirimleri değiştirildi.
ms.date: 04/25/2018
ms.openlocfilehash: e8b6955da1f36673962339785b0bfb012343acf8
ms.sourcegitcommit: c4e9d05644c9cb89de5ce6002723de107ea2e2c4
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 05/19/2019
ms.locfileid: "65878275"
---
# <a name="properties"></a><span data-ttu-id="8332d-103">Özellikler</span><span class="sxs-lookup"><span data-stu-id="8332d-103">Properties</span></span>

<span data-ttu-id="8332d-104">Birinci sınıf vatandaşlar özelliklerdir C#.</span><span class="sxs-lookup"><span data-stu-id="8332d-104">Properties are first class citizens in C#.</span></span> <span data-ttu-id="8332d-105">Geliştiricilerin, bunların tasarım amacı doğru bir şekilde ifade kod yazmanızı sağlayan sözdizimi dil tanımlar.</span><span class="sxs-lookup"><span data-stu-id="8332d-105">The language defines syntax that enables developers to write code that accurately expresses their design intent.</span></span>

<span data-ttu-id="8332d-106">Bunlar erişildiğinde özellikleri alanlar gibi davranır.</span><span class="sxs-lookup"><span data-stu-id="8332d-106">Properties behave like fields when they are accessed.</span></span>
<span data-ttu-id="8332d-107">Ancak, alanları özellikleri bir özellik erişilen veya atandığında, yürütülen deyimleri tanımlayan erişimcileri ile uygulanır.</span><span class="sxs-lookup"><span data-stu-id="8332d-107">However, unlike fields, properties are implemented with accessors that define the statements executed when a property is accessed or assigned.</span></span>

## <a name="property-syntax"></a><span data-ttu-id="8332d-108">Özellik sözdizimi</span><span class="sxs-lookup"><span data-stu-id="8332d-108">Property syntax</span></span>

<span data-ttu-id="8332d-109">Özelliklerinin sözdizimi, alanlar için doğal bir uzantısıdır.</span><span class="sxs-lookup"><span data-stu-id="8332d-109">The syntax for properties is a natural extension to fields.</span></span> <span data-ttu-id="8332d-110">Bir alan bir depolama konumu tanımlar:</span><span class="sxs-lookup"><span data-stu-id="8332d-110">A field defines a storage location:</span></span>

[!code-csharp[Person class with public fields](../../samples/snippets/csharp/properties/Person.cs#1)]

<span data-ttu-id="8332d-111">Bir özellik tanımı bildirimlerini içeren bir `get` ve `set` erişimci alır ve bu özelliğin değeri atar:</span><span class="sxs-lookup"><span data-stu-id="8332d-111">A property definition contains declarations for a `get` and `set` accessor that retrieves and assigns the value of that property:</span></span>

[!code-csharp[Person class with public properties](../../samples/snippets/csharp/properties/Person.cs#2)]

<span data-ttu-id="8332d-112">Yukarıda gösterilen sözdizimi *otomatik özellik* söz dizimi.</span><span class="sxs-lookup"><span data-stu-id="8332d-112">The syntax shown above is the *auto property* syntax.</span></span> <span data-ttu-id="8332d-113">Derleyici özelliği yedekleyen alanı için depolama konumu oluşturur.</span><span class="sxs-lookup"><span data-stu-id="8332d-113">The compiler generates the storage location for the field that backs up the property.</span></span> <span data-ttu-id="8332d-114">Derleyici ayrıca gövdesinin uygulayan `get` ve `set` erişimcileri.</span><span class="sxs-lookup"><span data-stu-id="8332d-114">The compiler also implements the body of the `get` and `set` accessors.</span></span>

<span data-ttu-id="8332d-115">Bazen, bir tür için varsayılan dışında bir değer özelliğini başlatmak gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="8332d-115">Sometimes, you need to initialize a property to a value other than the default for its type.</span></span>  <span data-ttu-id="8332d-116">C#Bu özellik için kapatma küme ayracından sonra bir değer ayarlayarak sağlar.</span><span class="sxs-lookup"><span data-stu-id="8332d-116">C# enables that by setting a value after the closing brace for the property.</span></span> <span data-ttu-id="8332d-117">İlk değeri tercih edebilirsiniz `FirstName` boş bir dize özelliğini yerine `null`.</span><span class="sxs-lookup"><span data-stu-id="8332d-117">You may prefer the initial value for the `FirstName` property to be the empty string rather than `null`.</span></span> <span data-ttu-id="8332d-118">Aşağıda gösterildiği gibi belirtmeniz gerekir:</span><span class="sxs-lookup"><span data-stu-id="8332d-118">You would specify that as shown below:</span></span>

[!code-csharp[Person class with properties and initializer](../../samples/snippets/csharp/properties/Person.cs#3)]

<span data-ttu-id="8332d-119">Bu makalenin sonraki bölümlerinde anlatıldığı gibi belirli başlatma salt okunur özellikler için en kullanışlıdır.</span><span class="sxs-lookup"><span data-stu-id="8332d-119">Specific initialization is most useful for read-only properties, as you'll see later in this article.</span></span>

<span data-ttu-id="8332d-120">Aşağıda gösterildiği gibi depolama kendiniz de tanımlayabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="8332d-120">You can also define the storage yourself, as shown below:</span></span>

[!code-csharp[Person class with properties and backing field](../../samples/snippets/csharp/properties/Person.cs#4)]

<span data-ttu-id="8332d-121">Bir özellik uygulama tek bir ifade olduğunda kullanabileceğiniz *ifade gövdeli üyeler* alıcı veya ayarlayıcı için:</span><span class="sxs-lookup"><span data-stu-id="8332d-121">When a property implementation is a single expression, you can use *expression-bodied members* for the getter or setter:</span></span>

[!code-csharp[Person class with properties and expression bodied getters and setters](../../samples/snippets/csharp/properties/Person.cs#5)]

<span data-ttu-id="8332d-122">Bu Basitleştirilmiş söz dizimi, bu makalenin tamamında uygun olduğunda kullanılır.</span><span class="sxs-lookup"><span data-stu-id="8332d-122">This simplified syntax will be used where applicable throughout this article.</span></span>

<span data-ttu-id="8332d-123">Yukarıda gösterilen özellik tanımı, bir okuma-yazma özelliğidir.</span><span class="sxs-lookup"><span data-stu-id="8332d-123">The property definition shown above is a read-write property.</span></span> <span data-ttu-id="8332d-124">Anahtar sözcüğü fark `value` set erişimcisine içinde.</span><span class="sxs-lookup"><span data-stu-id="8332d-124">Notice the keyword `value` in the set accessor.</span></span> <span data-ttu-id="8332d-125">`set` Erişimci her zaman adlı tek bir parametreye sahip `value`.</span><span class="sxs-lookup"><span data-stu-id="8332d-125">The `set` accessor always has a single parameter named `value`.</span></span> <span data-ttu-id="8332d-126">`get` Erişimci özelliğin türüne dönüştürülebilen bir değer döndürmesi gerekir (`string` Bu örnekte).</span><span class="sxs-lookup"><span data-stu-id="8332d-126">The `get` accessor must return a value that is convertible to the type of the property (`string` in this example).</span></span>

<span data-ttu-id="8332d-127">Söz dizimi temelleri olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="8332d-127">That's the basics of the syntax.</span></span> <span data-ttu-id="8332d-128">Farklı tasarım deyimleri çeşitli destek pek çok farklı Çeşitleme vardır.</span><span class="sxs-lookup"><span data-stu-id="8332d-128">There are many different variations that support a variety of different design idioms.</span></span> <span data-ttu-id="8332d-129">Şimdi keşfedin ve her söz dizimi seçenek öğrenin.</span><span class="sxs-lookup"><span data-stu-id="8332d-129">Let's explore, and learn the syntax options for each.</span></span>

## <a name="scenarios"></a><span data-ttu-id="8332d-130">Senaryolar</span><span class="sxs-lookup"><span data-stu-id="8332d-130">Scenarios</span></span>

<span data-ttu-id="8332d-131">Yukarıdaki örneklerde gösterilen özellik tanımının en basit durumlarından biri: doğrulama bir okuma-yazma özelliği.</span><span class="sxs-lookup"><span data-stu-id="8332d-131">The examples above showed one of the simplest cases of property definition: a read-write property with no validation.</span></span> <span data-ttu-id="8332d-132">Kod yazarak istediğiniz `get` ve `set` erişimcileri, birçok farklı senaryo oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8332d-132">By writing the code you want in the `get` and `set` accessors, you can create many different scenarios.</span></span>

### <a name="validation"></a><span data-ttu-id="8332d-133">Doğrulama</span><span class="sxs-lookup"><span data-stu-id="8332d-133">Validation</span></span>

<span data-ttu-id="8332d-134">Kod yazabileceğiniz `set` erişimci özelliği tarafından temsil edilen değerler her zaman geçerli olduğundan emin olmak için.</span><span class="sxs-lookup"><span data-stu-id="8332d-134">You can write code in the `set` accessor to ensure that the values represented by a property are always valid.</span></span> <span data-ttu-id="8332d-135">Örneğin, bir kural için varsayalım `Person` sınıfı, adı boş veya boşluk olamaz.</span><span class="sxs-lookup"><span data-stu-id="8332d-135">For example, suppose one rule for the `Person` class is that the name cannot be blank or white space.</span></span> <span data-ttu-id="8332d-136">Aşağıdaki gibi yazmalısınız:</span><span class="sxs-lookup"><span data-stu-id="8332d-136">You would write that as follows:</span></span>

[!code-csharp[Validating property setters](../../samples/snippets/csharp/properties/Person.cs#6)]

<span data-ttu-id="8332d-137">Önceki örnekte kullanarak basit hale getirilebilir bir`throw` özellik ayarlayıcı doğrulama bir parçası olarak ifade:</span><span class="sxs-lookup"><span data-stu-id="8332d-137">The preceding example can be simplified by using a`throw` expression as part of the property setter validation:</span></span>

[!code-csharp[Validating property setters](../../samples/snippets/csharp/properties/Person.cs#7)]

<span data-ttu-id="8332d-138">Yukarıdaki örnekte kural adı boş olmamalı veya boşluk zorlar.</span><span class="sxs-lookup"><span data-stu-id="8332d-138">The example above enforces the rule that the first name must not be blank or white space.</span></span> <span data-ttu-id="8332d-139">Bir geliştirici yazma</span><span class="sxs-lookup"><span data-stu-id="8332d-139">If a developer writes</span></span>

```csharp
hero.FirstName = "";
```

<span data-ttu-id="8332d-140">Bu atamayı oluşturur bir `ArgumentException`.</span><span class="sxs-lookup"><span data-stu-id="8332d-140">That assignment throws an `ArgumentException`.</span></span> <span data-ttu-id="8332d-141">Bir özellik kümesi erişimcisi, dönüş türü void olmalıdır çünkü bir özel durum tarafından set erişimcisine hataları bildirin.</span><span class="sxs-lookup"><span data-stu-id="8332d-141">Because a property set accessor must have a void return type, you report errors in the set accessor by throwing an exception.</span></span>

<span data-ttu-id="8332d-142">Senaryonuzda gereken her şeyi aynı bu söz dizimini genişletebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8332d-142">You can extend this same syntax to anything needed in your scenario.</span></span> <span data-ttu-id="8332d-143">Farklı özellikler arasındaki ilişkileri denetleyin veya dış koşulları karşı doğrulayın.</span><span class="sxs-lookup"><span data-stu-id="8332d-143">You can check the relationships between different properties, or validate against any external conditions.</span></span> <span data-ttu-id="8332d-144">Herhangi bir geçerli C# deyimleri bir özellik erişimcisi geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="8332d-144">Any valid C# statements are valid in a property accessor.</span></span>

### <a name="read-only"></a><span data-ttu-id="8332d-145">salt okunur</span><span class="sxs-lookup"><span data-stu-id="8332d-145">Read-only</span></span>

<span data-ttu-id="8332d-146">Bu noktaya kadar açtığınız tüm özellik tanımları ile ortak erişimciler okuma/yazma özellikleri ' dir.</span><span class="sxs-lookup"><span data-stu-id="8332d-146">Up to this point, all the property definitions you have seen are read/write properties with public accessors.</span></span> <span data-ttu-id="8332d-147">Yalnızca geçerli erişilebilirlik özellikleri için değil.</span><span class="sxs-lookup"><span data-stu-id="8332d-147">That's not the only valid accessibility for properties.</span></span>
<span data-ttu-id="8332d-148">Salt okunur özelliklerini oluşturun veya farklı erişilebilirliğe kümesine vermek ve get erişimcileri.</span><span class="sxs-lookup"><span data-stu-id="8332d-148">You can create read-only properties, or give different accessibility to the set and get accessors.</span></span> <span data-ttu-id="8332d-149">Varsayın, `Person` sınıfı, değerinin değiştirilmesi yalnızca etkinleştirmelisiniz `FirstName` o sınıftaki diğer yöntemleri özelliği.</span><span class="sxs-lookup"><span data-stu-id="8332d-149">Suppose that your `Person` class should only enable changing the value of the `FirstName` property from other methods in that class.</span></span> <span data-ttu-id="8332d-150">Set erişimcisine müdürün `private` erişilebilirlik yerine `public`:</span><span class="sxs-lookup"><span data-stu-id="8332d-150">You could give the set accessor `private` accessibility instead of `public`:</span></span>

[!code-csharp[Using a private setter for a publicly readonly property](../../samples/snippets/csharp/properties/Person.cs#8)]

<span data-ttu-id="8332d-151">Şimdi, `FirstName` özelliği herhangi bir koddan erişilebilir, ancak diğer koddan yalnızca atanabilir `Person` sınıfı.</span><span class="sxs-lookup"><span data-stu-id="8332d-151">Now, the `FirstName` property can be accessed from any code, but it can only be assigned from other code in the `Person` class.</span></span>

<span data-ttu-id="8332d-152">Herhangi bir kısıtlayıcı erişim değiştiricisi kümesi ya da ekleyebilir veya get erişimcileri.</span><span class="sxs-lookup"><span data-stu-id="8332d-152">You can add any restrictive access modifier to either the set or get accessors.</span></span> <span data-ttu-id="8332d-153">Tek tek erişimcisine yerleştirdiğiniz herhangi erişim değiştiricisi özellik tanımı erişim değiştiricisi daha sınırlı olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="8332d-153">Any access modifier you place on the individual accessor must be more limited than the access modifier on the property definition.</span></span> <span data-ttu-id="8332d-154">Yukarıdaki yasal çünkü `FirstName` özelliği `public`, ancak set erişimcisine `private`.</span><span class="sxs-lookup"><span data-stu-id="8332d-154">The above is legal because the `FirstName` property is `public`, but the set accessor is `private`.</span></span> <span data-ttu-id="8332d-155">Değil bildirip bir `private` özelliğiyle bir `public` erişimcisi.</span><span class="sxs-lookup"><span data-stu-id="8332d-155">You could not declare a `private` property with a `public` accessor.</span></span> <span data-ttu-id="8332d-156">Özellik bildirimleri de bildirilebilir `protected`, `internal`, `protected internal`, veya hatta `private`.</span><span class="sxs-lookup"><span data-stu-id="8332d-156">Property declarations can also be declared `protected`, `internal`, `protected internal`, or, even `private`.</span></span>

<span data-ttu-id="8332d-157">Ayrıca daha kısıtlayıcı değiştiricisi yerleştirmek için yasal `get` erişimcisi.</span><span class="sxs-lookup"><span data-stu-id="8332d-157">It is also legal to place the more restrictive modifier on the `get` accessor.</span></span> <span data-ttu-id="8332d-158">Örneğin, olabilir bir `public` özelliği, ancak kısıtlama `get` için erişimci `private`.</span><span class="sxs-lookup"><span data-stu-id="8332d-158">For example, you could have a `public` property, but restrict the `get` accessor to `private`.</span></span> <span data-ttu-id="8332d-159">Bu senaryo, uygulamada nadiren gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="8332d-159">That scenario is rarely done in practice.</span></span>

<span data-ttu-id="8332d-160">Böylece bir oluşturucu veya bir özellik başlatıcısının içinde yalnızca ayarlanabilir da bir özellik değişiklikleri kısıtlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8332d-160">You can also restrict modifications to a property so that it can only be set in a constructor or a property initializer.</span></span> <span data-ttu-id="8332d-161">Değiştirebileceğiniz `Person` bunu aşağıdaki gibi sınıf:</span><span class="sxs-lookup"><span data-stu-id="8332d-161">You can modify the `Person` class so as follows:</span></span>

[!code-csharp[A readonly auto implemented property](../../samples/snippets/csharp/properties/Person.cs#9)]

<span data-ttu-id="8332d-162">Bu özellik salt okunur özellikler olarak sunulan koleksiyonlar başlatmak için en yaygın olarak kullanılır:</span><span class="sxs-lookup"><span data-stu-id="8332d-162">This feature is most commonly used for initializing collections that are exposed as read-only properties:</span></span>

```csharp
public class Measurements
{
    public ICollection<DataPoint> points { get; } = new List<DataPoint>();
}
```

### <a name="computed-properties"></a><span data-ttu-id="8332d-163">Hesaplanan Özellikler</span><span class="sxs-lookup"><span data-stu-id="8332d-163">Computed properties</span></span>

<span data-ttu-id="8332d-164">Yalnızca bir üye alanın değerini döndürmek bir özellik gerekmez.</span><span class="sxs-lookup"><span data-stu-id="8332d-164">A property does not need to simply return the value of a member field.</span></span> <span data-ttu-id="8332d-165">Hesaplanan değeri döndüren özellikler oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8332d-165">You can create properties that return a computed value.</span></span> <span data-ttu-id="8332d-166">Şimdi genişletin `Person` ilk ve son adları birleştirerek hesaplanan tam adı döndürülecek nesne:</span><span class="sxs-lookup"><span data-stu-id="8332d-166">Let's expand the `Person` object to return the full name, computed by concatenating the first and last names:</span></span>

[!code-csharp[A computed property](../../samples/snippets/csharp/properties/Person.cs#10)]

<span data-ttu-id="8332d-167">Kullanan yukarıdaki örnekte [dize ilişkilendirme](../csharp/language-reference/tokens/interpolated.md) tam adı için biçimlendirilmiş dize oluşturmak için özellik.</span><span class="sxs-lookup"><span data-stu-id="8332d-167">The example above uses the [string interpolation](../csharp/language-reference/tokens/interpolated.md) feature to create the formatted string for the full name.</span></span>

<span data-ttu-id="8332d-168">Ayrıca bir *ifade gövdeli üye*, hesaplanan oluşturmak için daha birleştiren bir yöntem sunan `FullName` özelliği:</span><span class="sxs-lookup"><span data-stu-id="8332d-168">You can also use an *expression-bodied member*, which provides a more succinct way to create the computed `FullName` property:</span></span>

[!code-csharp[A computed property using an expression bodied member](../../samples/snippets/csharp/properties/Person.cs#11)]

<span data-ttu-id="8332d-169">*İfade gövdeli üyeler* kullanın *lambda ifadesi* tek bir ifade içeren yöntemleri tanımlamak için söz dizimi.</span><span class="sxs-lookup"><span data-stu-id="8332d-169">*Expression-bodied members* use the *lambda expression* syntax to define methods that contain a single expression.</span></span> <span data-ttu-id="8332d-170">Burada, bu ifade, kişi nesnesinin tam adını döndürür.</span><span class="sxs-lookup"><span data-stu-id="8332d-170">Here, that expression returns the full name for the person object.</span></span>

### <a name="cached-evaluated-properties"></a><span data-ttu-id="8332d-171">Önbelleğe alınan değerlendirilen Özellikler</span><span class="sxs-lookup"><span data-stu-id="8332d-171">Cached evaluated properties</span></span>

<span data-ttu-id="8332d-172">Hesaplanan bir özellik kavramını depolama ile karışık ve oluşturma bir *hesaplanan özellik önbelleğe*.</span><span class="sxs-lookup"><span data-stu-id="8332d-172">You can mix the concept of a computed property with storage and create a *cached evaluated property*.</span></span>  <span data-ttu-id="8332d-173">Örneğin, güncelleştiremedi `FullName` özelliği böylece biçimlendirme dizesi yalnızca ilk kez erişildi, oldu:</span><span class="sxs-lookup"><span data-stu-id="8332d-173">For example, you could update the `FullName` property so that the string formatting only happened the first time it was accessed:</span></span>

[!code-csharp[Caching the value of a computed property](../../samples/snippets/csharp/properties/Person.cs#12)]

<span data-ttu-id="8332d-174">Yukarıdaki kod, ancak bir hata içeriyor.</span><span class="sxs-lookup"><span data-stu-id="8332d-174">The above code contains a bug though.</span></span> <span data-ttu-id="8332d-175">Kod ya da değerini güncelleştiriyorsa `FirstName` veya `LastName` özelliği, daha önce değerlendirilmesini `fullName` alanı geçersiz.</span><span class="sxs-lookup"><span data-stu-id="8332d-175">If code updates the value of either the `FirstName` or `LastName` property, the previously evaluated `fullName` field is invalid.</span></span> <span data-ttu-id="8332d-176">Değişiklik `set` erişicilerini `FirstName` ve `LastName` özelliği böylece `fullName` alan yeniden hesaplanır:</span><span class="sxs-lookup"><span data-stu-id="8332d-176">You modify the `set` accessors of the `FirstName` and `LastName` property so that the `fullName` field is calculated again:</span></span>

[!code-csharp[Invalidating the cache correctly](../../samples/snippets/csharp/properties/Person.cs#13)]

<span data-ttu-id="8332d-177">Bu son sürümü değerlendirir `FullName` yalnızca gerektiğinde özelliği.</span><span class="sxs-lookup"><span data-stu-id="8332d-177">This final version evaluates the `FullName` property only when needed.</span></span>
<span data-ttu-id="8332d-178">Önceden hesaplanmış sürüm geçerli ise kullanılır.</span><span class="sxs-lookup"><span data-stu-id="8332d-178">If the previously calculated version is valid, it's used.</span></span> <span data-ttu-id="8332d-179">Önceden hesaplanmış sürüm başka bir durum değişikliği geçersiz kılar, hesaplanır.</span><span class="sxs-lookup"><span data-stu-id="8332d-179">If another state change invalidates the previously calculated version, it will be recalculated.</span></span> <span data-ttu-id="8332d-180">Bu sınıfı kullanan geliştiriciler, uygulama ayrıntılarını bilmeniz gerekmez.</span><span class="sxs-lookup"><span data-stu-id="8332d-180">Developers that use this class do not need to know the details of the implementation.</span></span> <span data-ttu-id="8332d-181">İç değişikliklerin hiçbiri kişi nesnesinin kullanımını etkiler.</span><span class="sxs-lookup"><span data-stu-id="8332d-181">None of these internal changes affect the use of the Person object.</span></span> <span data-ttu-id="8332d-182">Bir nesnenin üyelerine verileri göstermek için özellikleri kullanmak için anahtar neden olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="8332d-182">That's the key reason for using Properties to expose data members of an object.</span></span>

### <a name="attaching-attributes-to-auto-implemented-properties"></a><span data-ttu-id="8332d-183">Otomatik uygulanan özellikler için öznitelikleri ekleme</span><span class="sxs-lookup"><span data-stu-id="8332d-183">Attaching attributes to auto-implemented properties</span></span>

<span data-ttu-id="8332d-184">İle başlayarak C# 7.3, alan öznitelikleri eklenebilir derleyicinin ürettiği yedekleme alanını otomatik olarak uygulanan özellikler için.</span><span class="sxs-lookup"><span data-stu-id="8332d-184">Beginning with C# 7.3, field attributes can be attached to the compiler generated backing field in auto-implemented properties.</span></span> <span data-ttu-id="8332d-185">Örneğin, bir düzeltmeyi düşünün `Person` benzersiz bir tamsayı ekler sınıfı `Id` özelliği.</span><span class="sxs-lookup"><span data-stu-id="8332d-185">For example, consider a revision to the `Person` class that adds a unique integer `Id` property.</span></span>
<span data-ttu-id="8332d-186">Yazdığınız`Id` otomatik uygulanan bir özellik, ancak tasarımınızı kullanan özellik kalıcı hale getirilmesine yönelik çağırmaz `Id` özelliği.</span><span class="sxs-lookup"><span data-stu-id="8332d-186">You write the`Id` property using an auto-implemented property, but your design does not call for persisting the `Id` property.</span></span> <span data-ttu-id="8332d-187"><xref:System.NonSerializedAttribute> Alanları, özellikleri yalnızca eklenebilir.</span><span class="sxs-lookup"><span data-stu-id="8332d-187">The <xref:System.NonSerializedAttribute> can only be attached to fields, not properties.</span></span> <span data-ttu-id="8332d-188">İliştirebilirsiniz <xref:System.NonSerializedAttribute> yedekleme alanına `Id` özelliğini kullanarak `field:` belirticisi özniteliği aşağıdaki örnekte gösterildiği gibi üzerinde:</span><span class="sxs-lookup"><span data-stu-id="8332d-188">You can attach the <xref:System.NonSerializedAttribute> to the backing field for the `Id` property by using the `field:` specifier on the attribute, as shown in the following example:</span></span>

[!code-csharp[Attaching attributes to a backing field](../../samples/snippets/csharp/properties/Person.cs#14)]

<span data-ttu-id="8332d-189">Bu teknik yedekleme alanını otomatik uygulanan özellik için eklediğiniz herhangi bir öznitelik için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="8332d-189">This technique works for any attribute you attach to the backing field on the auto-implemented property.</span></span>

### <a name="implementing-inotifypropertychanged"></a><span data-ttu-id="8332d-190">INotifyPropertyChanged uygulama</span><span class="sxs-lookup"><span data-stu-id="8332d-190">Implementing INotifyPropertyChanged</span></span>

<span data-ttu-id="8332d-191">Gerek duyduğunuz özellik erişimcisinde kod yazmak için son bir senaryo desteklemektir <xref:System.ComponentModel.INotifyPropertyChanged> bir değer değiştikten veri bağlama istemcilerine bildirmek için kullanılan arabirim.</span><span class="sxs-lookup"><span data-stu-id="8332d-191">A final scenario where you need to write code in a property accessor is to support the <xref:System.ComponentModel.INotifyPropertyChanged> interface used to notify data binding clients that a value has changed.</span></span> <span data-ttu-id="8332d-192">Bir özelliğin değeri değiştiğinde, nesneyi başlatır <xref:System.ComponentModel.INotifyPropertyChanged.PropertyChanged?displayProperty=nameWithType> olay değişikliği göstermek için.</span><span class="sxs-lookup"><span data-stu-id="8332d-192">When the value of a property changes, the object raises the <xref:System.ComponentModel.INotifyPropertyChanged.PropertyChanged?displayProperty=nameWithType> event to indicate the change.</span></span> <span data-ttu-id="8332d-193">Veri bağlama kitaplıkları, sırasıyla görüntüleme öğeleri üzerinde bu değişikliği göre güncelleştirin.</span><span class="sxs-lookup"><span data-stu-id="8332d-193">The data binding libraries, in turn, update display elements based on that change.</span></span> <span data-ttu-id="8332d-194">Aşağıdaki kod nasıl uygulamak gösterir `INotifyPropertyChanged` için `FirstName` bu kişi sınıfın özelliği.</span><span class="sxs-lookup"><span data-stu-id="8332d-194">The code below shows how you would implement `INotifyPropertyChanged` for the `FirstName` property of this person class.</span></span>

[!code-csharp[invalidating the cache correctly](../../samples/snippets/csharp/properties/Person.cs#15)]

<span data-ttu-id="8332d-195">`?.` İşleci çağrıldığında *null koşullu işleci*.</span><span class="sxs-lookup"><span data-stu-id="8332d-195">The `?.` operator is called the *null conditional operator*.</span></span> <span data-ttu-id="8332d-196">İşlecin sağ tarafındaki değerlendirmeden önce bir null başvuru için denetler.</span><span class="sxs-lookup"><span data-stu-id="8332d-196">It checks for a null reference before evaluating the right side of the operator.</span></span> <span data-ttu-id="8332d-197">Hiçbir abonelere varsa olan sonuç `PropertyChanged` değil olay, olayı için kodu yürütün.</span><span class="sxs-lookup"><span data-stu-id="8332d-197">The end result is that if there are no subscribers to the `PropertyChanged` event, the code to raise the event doesn't execute.</span></span> <span data-ttu-id="8332d-198">Throw bir `NullReferenceException` bu durumda bu olmadan denetleyin.</span><span class="sxs-lookup"><span data-stu-id="8332d-198">It would throw a `NullReferenceException` without this check in that case.</span></span> <span data-ttu-id="8332d-199">Daha fazla bilgi için bkz. [`events`](events-overview.md).</span><span class="sxs-lookup"><span data-stu-id="8332d-199">For more information, see [`events`](events-overview.md).</span></span> <span data-ttu-id="8332d-200">Bu örnek ayrıca yeni kullanır `nameof` özelliği adı sembolünden kendi metin gösterimine dönüştürmek için işleci.</span><span class="sxs-lookup"><span data-stu-id="8332d-200">This example also uses the new `nameof` operator to convert from the property name symbol to its text representation.</span></span>
<span data-ttu-id="8332d-201">Kullanarak `nameof` Burada, yanlış yazmış özelliğin adını hataları azaltabilir.</span><span class="sxs-lookup"><span data-stu-id="8332d-201">Using `nameof` can reduce errors where you have mistyped the name of the property.</span></span>

<span data-ttu-id="8332d-202">Uygulama yeniden <xref:System.ComponentModel.INotifyPropertyChanged> nerede yazabilirsiniz kod ihtiyacınız senaryolarını desteklemek üzere erişenler bir servis talebi örneğidir.</span><span class="sxs-lookup"><span data-stu-id="8332d-202">Again, implementing <xref:System.ComponentModel.INotifyPropertyChanged> is an example of a case where you can write code in your accessors to support the scenarios you need.</span></span>

## <a name="summing-up"></a><span data-ttu-id="8332d-203">Özetle</span><span class="sxs-lookup"><span data-stu-id="8332d-203">Summing up</span></span>

<span data-ttu-id="8332d-204">Özellikleri, bir sınıf veya nesne akıllı alanların bir biçimidir.</span><span class="sxs-lookup"><span data-stu-id="8332d-204">Properties are a form of smart fields in a class or object.</span></span> <span data-ttu-id="8332d-205">Gelen nesne nesne alanları gibi görünürler.</span><span class="sxs-lookup"><span data-stu-id="8332d-205">From outside the object, they appear like fields in the object.</span></span> <span data-ttu-id="8332d-206">Ancak, özellikleri tam paletini kullanarak uygulanabilir C# işlevselliği.</span><span class="sxs-lookup"><span data-stu-id="8332d-206">However, properties can be implemented using the full palette of C# functionality.</span></span>
<span data-ttu-id="8332d-207">Doğrulama, farklı erişilebilirlik, geç değerlendirme veya senaryolarınızı gereken herhangi bir gereksinim sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="8332d-207">You can provide validation, different accessibility, lazy evaluation, or any requirements your scenarios need.</span></span>
