---
title: Zaman uyumsuz akışlar oluşturma ve kullanma
description: Bu gelişmiş öğreticide, zaman uyumsuz akışlar oluşturma ve kullanma işlemlerinin nasıl yapılacağı gösterilmektedir. Zaman uyumsuz akışlar, zaman uyumsuz olarak oluşturulabilecek veri dizileri ile çalışmanın daha doğal bir yolunu sağlar.
ms.date: 02/10/2019
ms.technology: csharp-async
ms.custom: mvc
ms.openlocfilehash: fd9fed3469d18c919102640df7bb501b116f5e0e
ms.sourcegitcommit: 9a4488a3625866335e83a20da5e9c5286b1f034c
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 05/15/2020
ms.locfileid: "83420376"
---
# <a name="tutorial-generate-and-consume-async-streams-using-c-80-and-net-core-30"></a><span data-ttu-id="47189-104">Öğretici: C# 8,0 ve .NET Core 3,0 kullanarak zaman uyumsuz akışlar oluşturma ve kullanma</span><span class="sxs-lookup"><span data-stu-id="47189-104">Tutorial: Generate and consume async streams using C# 8.0 and .NET Core 3.0</span></span>

<span data-ttu-id="47189-105">C# 8,0, akış veri kaynağını modelleyebilir ve **zaman uyumsuz akışları**tanıtır.</span><span class="sxs-lookup"><span data-stu-id="47189-105">C# 8.0 introduces **async streams**, which model a streaming source of data.</span></span> <span data-ttu-id="47189-106">Veri akışları genellikle zaman uyumsuz olarak öğeleri alır veya oluşturur.</span><span class="sxs-lookup"><span data-stu-id="47189-106">Data streams often retrieve or generate elements asynchronously.</span></span> <span data-ttu-id="47189-107">Zaman uyumsuz akışlar .NET Standard 2,1 ' de tanıtılan yeni arabirimleri kullanır.</span><span class="sxs-lookup"><span data-stu-id="47189-107">Async streams rely on new interfaces introduced in .NET Standard 2.1.</span></span> <span data-ttu-id="47189-108">Bu arabirimler .NET Core 3,0 ve üzeri sürümlerde desteklenir.</span><span class="sxs-lookup"><span data-stu-id="47189-108">These interfaces are supported in .NET Core 3.0 and later.</span></span> <span data-ttu-id="47189-109">Bunlar, zaman uyumsuz akış veri kaynakları için doğal bir programlama modeli sağlar.</span><span class="sxs-lookup"><span data-stu-id="47189-109">They provide a natural programming model for asynchronous streaming data sources.</span></span>

<span data-ttu-id="47189-110">Bu öğreticide şunların nasıl yapıldığını öğreneceksiniz:</span><span class="sxs-lookup"><span data-stu-id="47189-110">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> - <span data-ttu-id="47189-111">Zaman uyumsuz bir veri öğeleri dizisi üreten bir veri kaynağı oluşturun.</span><span class="sxs-lookup"><span data-stu-id="47189-111">Create a data source that generates a sequence of data elements asynchronously.</span></span>
> - <span data-ttu-id="47189-112">Bu veri kaynağını zaman uyumsuz olarak tükettin.</span><span class="sxs-lookup"><span data-stu-id="47189-112">Consume that data source asynchronously.</span></span>
> - <span data-ttu-id="47189-113">Zaman uyumsuz akışlar için iptal ve yakalanan bağlamlara destek.</span><span class="sxs-lookup"><span data-stu-id="47189-113">Support cancellation and captured contexts for asynchronous streams.</span></span>
> - <span data-ttu-id="47189-114">Yeni arabirim ve veri kaynağı daha önceki zaman uyumlu veri dizileri için tercih edildiği zaman tanıyın.</span><span class="sxs-lookup"><span data-stu-id="47189-114">Recognize when the new interface and data source are preferred to earlier synchronous data sequences.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="47189-115">Ön koşullar</span><span class="sxs-lookup"><span data-stu-id="47189-115">Prerequisites</span></span>

<span data-ttu-id="47189-116">C# 8,0 derleyicisi dahil olmak üzere makinenizi .NET Core çalıştıracak şekilde ayarlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="47189-116">You'll need to set up your machine to run .NET Core, including the C# 8.0 compiler.</span></span> <span data-ttu-id="47189-117">C# 8 derleyicisi, [Visual Studio 2019 sürüm 16,3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) veya [.NET Core 3,0 SDK](https://dotnet.microsoft.com/download)ile başlayarak kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="47189-117">The C# 8 compiler is available starting with [Visual Studio 2019 version 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) or [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download).</span></span>

<span data-ttu-id="47189-118">GitHub GraphQL uç noktasına erişebilmek için bir [GitHub erişim belirteci](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) oluşturmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="47189-118">You'll need to create a [GitHub access token](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) so that you can access the GitHub GraphQL endpoint.</span></span> <span data-ttu-id="47189-119">GitHub erişim belirteciniz için aşağıdaki izinleri seçin:</span><span class="sxs-lookup"><span data-stu-id="47189-119">Select the following permissions for your GitHub Access Token:</span></span>

- <span data-ttu-id="47189-120">Depo: durum</span><span class="sxs-lookup"><span data-stu-id="47189-120">repo:status</span></span>
- <span data-ttu-id="47189-121">public_repo</span><span class="sxs-lookup"><span data-stu-id="47189-121">public_repo</span></span>

<span data-ttu-id="47189-122">Erişim belirtecini, GitHub API uç noktasına erişim kazanmak için kullanabilmeniz için güvenli bir yere kaydedin.</span><span class="sxs-lookup"><span data-stu-id="47189-122">Save the access token in a safe place so you can use it to gain access to the GitHub API endpoint.</span></span>

> [!WARNING]
> <span data-ttu-id="47189-123">Kişisel erişim belirtecinizi güvende tutun.</span><span class="sxs-lookup"><span data-stu-id="47189-123">Keep your personal access token secure.</span></span> <span data-ttu-id="47189-124">Kişisel erişim belirtecinize sahip tüm yazılımlar, erişim haklarınızı kullanarak GitHub API çağrıları yapabilir.</span><span class="sxs-lookup"><span data-stu-id="47189-124">Any software with your personal access token could make GitHub API calls using your access rights.</span></span>

<span data-ttu-id="47189-125">Bu öğreticide, Visual Studio veya .NET Core CLI dahil olmak üzere C# ve .NET hakkında bilgi sahibi olduğunuz varsayılır.</span><span class="sxs-lookup"><span data-stu-id="47189-125">This tutorial assumes you're familiar with C# and .NET, including either Visual Studio or the .NET Core CLI.</span></span>

## <a name="run-the-starter-application"></a><span data-ttu-id="47189-126">Başlangıç uygulamasını çalıştırma</span><span class="sxs-lookup"><span data-stu-id="47189-126">Run the starter application</span></span>

<span data-ttu-id="47189-127">Bu öğreticide kullanılan başlangıç uygulamasının kodunu [CSharp/öğreticiler/AsyncStreams](https://github.com/dotnet/docs/tree/master/docs/csharp/tutorials/snippets/generate-consume-asynchronous-streams/start) klasöründeki [DotNet/docs](https://github.com/dotnet/docs) deposundan alabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="47189-127">You can get the code for the starter application used in this tutorial from the [dotnet/docs](https://github.com/dotnet/docs) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/docs/tree/master/docs/csharp/tutorials/snippets/generate-consume-asynchronous-streams/start) folder.</span></span>

<span data-ttu-id="47189-128">Başlangıç uygulaması, [DotNet/docs](https://github.com/dotnet/docs) deposunda yazılan son sorunları almak Için [GitHub graphql](https://developer.github.com/v4/) arabirimini kullanan bir konsol uygulamasıdır.</span><span class="sxs-lookup"><span data-stu-id="47189-128">The starter application is a console application that uses the [GitHub GraphQL](https://developer.github.com/v4/) interface to retrieve recent issues written in the [dotnet/docs](https://github.com/dotnet/docs) repository.</span></span> <span data-ttu-id="47189-129">Başlangıç uygulaması yöntemi için aşağıdaki koda bakarak başlayın `Main` :</span><span class="sxs-lookup"><span data-stu-id="47189-129">Start by looking at the following code for the starter app `Main` method:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetStarterAppMain" :::

<span data-ttu-id="47189-130">`GitHubKey`Kişisel erişim belirtecinize bir ortam değişkeni ayarlayabilir veya çağrısındaki son bağımsız değişkeni `GenEnvVariable` kişisel erişim belirtecinizle değiştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="47189-130">You can either set a `GitHubKey` environment variable to your personal access token, or you can replace the last argument in the call to `GenEnvVariable` with your personal access token.</span></span> <span data-ttu-id="47189-131">Kaynağı başkalarıyla paylaşacaksanız, erişim kodunuzu kaynak koda yerleştirmeyin.</span><span class="sxs-lookup"><span data-stu-id="47189-131">Don't put your access code in source code if you'll be sharing the source with others.</span></span> <span data-ttu-id="47189-132">Erişim kodlarını bir paylaşılan kaynak deposuna hiçbir daha yükleme.</span><span class="sxs-lookup"><span data-stu-id="47189-132">Never upload access codes to a shared source repository.</span></span>

<span data-ttu-id="47189-133">GitHub istemcisini oluşturduktan sonra, içindeki kod `Main` bir ilerleme raporlama nesnesi ve bir iptal belirteci oluşturur.</span><span class="sxs-lookup"><span data-stu-id="47189-133">After creating the GitHub client, the code in `Main` creates a progress reporting object and a cancellation token.</span></span> <span data-ttu-id="47189-134">Bu nesneler oluşturulduktan sonra, `Main` `runPagedQueryAsync` en son 250 oluşturulan sorunları almak için çağırır.</span><span class="sxs-lookup"><span data-stu-id="47189-134">Once those objects are created, `Main` calls `runPagedQueryAsync` to retrieve the most recent 250 created issues.</span></span> <span data-ttu-id="47189-135">Bu görev bittikten sonra sonuçlar görüntülenir.</span><span class="sxs-lookup"><span data-stu-id="47189-135">After that task has finished, the results are displayed.</span></span>

<span data-ttu-id="47189-136">Başlangıç uygulamasını çalıştırdığınızda, bu uygulamanın nasıl çalıştığı hakkında bazı önemli gözlemlerinizi yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="47189-136">When you run the starter application, you can make some important observations about how this application runs.</span></span>  <span data-ttu-id="47189-137">GitHub 'dan döndürülen her sayfa için ilerleme durumunu görürsünüz.</span><span class="sxs-lookup"><span data-stu-id="47189-137">You'll see progress reported for each page returned from GitHub.</span></span> <span data-ttu-id="47189-138">GitHub her yeni sorun sayfasını geri döndürdüğünden, dikkat çekici bir duraklama gözlemleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="47189-138">You can observe a noticeable pause before GitHub returns each new page of issues.</span></span> <span data-ttu-id="47189-139">Son olarak, sorunlar yalnızca GitHub 'dan 10 sayfa alındıktan sonra görüntülenir.</span><span class="sxs-lookup"><span data-stu-id="47189-139">Finally, the issues are displayed only after all 10 pages have been retrieved from GitHub.</span></span>

## <a name="examine-the-implementation"></a><span data-ttu-id="47189-140">Uygulamayı İnceleme</span><span class="sxs-lookup"><span data-stu-id="47189-140">Examine the implementation</span></span>

<span data-ttu-id="47189-141">Uygulama, önceki bölümde ele alınan davranışı neden gözlemlediğinizi ortaya çıkarır.</span><span class="sxs-lookup"><span data-stu-id="47189-141">The implementation reveals why you observed the behavior discussed in the previous section.</span></span> <span data-ttu-id="47189-142">Kodu inceleyin `runPagedQueryAsync` :</span><span class="sxs-lookup"><span data-stu-id="47189-142">Examine the code for `runPagedQueryAsync`:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetRunPagedQuery" :::

<span data-ttu-id="47189-143">Yukarıdaki kodun disk belleği algoritmasına ve zaman uyumsuz yapısına odaklanalım.</span><span class="sxs-lookup"><span data-stu-id="47189-143">Let's concentrate on the paging algorithm and async structure of the preceding code.</span></span> <span data-ttu-id="47189-144">(GitHub GraphQL API 'SI ile ilgili ayrıntılar için [GitHub graphql belgelerine](https://developer.github.com/v4/guides/) başvurabilirsiniz.) `runPagedQueryAsync`Yöntemi en sonuncudan en eskiye doğru olan sorunları numaralandırır.</span><span class="sxs-lookup"><span data-stu-id="47189-144">(You can consult the [GitHub GraphQL documentation](https://developer.github.com/v4/guides/) for details on the GitHub GraphQL API.) The `runPagedQueryAsync` method enumerates the issues from most recent to oldest.</span></span> <span data-ttu-id="47189-145">Sayfa başına 25 sorun ister ve `pageInfo` önceki sayfaya devam etmek için yanıtın yapısını inceler.</span><span class="sxs-lookup"><span data-stu-id="47189-145">It requests 25 issues per page and examines the `pageInfo` structure of the response to continue with the previous page.</span></span> <span data-ttu-id="47189-146">Bu, çok sayfalı yanıtlar için GraphQL 'in standart disk belleği desteğini izler.</span><span class="sxs-lookup"><span data-stu-id="47189-146">That follows GraphQL's standard paging support for multi-page responses.</span></span> <span data-ttu-id="47189-147">Yanıt, `pageInfo` bir `hasPreviousPages` değeri ve `startCursor` önceki sayfayı istemek için kullanılan bir değeri içeren bir nesnesi içerir.</span><span class="sxs-lookup"><span data-stu-id="47189-147">The response includes a `pageInfo` object that includes a `hasPreviousPages` value and a `startCursor` value used to request the previous page.</span></span> <span data-ttu-id="47189-148">Sorunlar `nodes` dizide bulunur.</span><span class="sxs-lookup"><span data-stu-id="47189-148">The issues are in the `nodes` array.</span></span> <span data-ttu-id="47189-149">`runPagedQueryAsync`Yöntemi, tüm sayfalardaki sonuçları içeren bir diziye bu düğümleri ekler.</span><span class="sxs-lookup"><span data-stu-id="47189-149">The `runPagedQueryAsync` method appends these nodes to an array that contains all the results from all pages.</span></span>

<span data-ttu-id="47189-150">Bir sonuç sayfasını aldıktan ve geri yükledikten sonra, `runPagedQueryAsync` ilerlemeyi raporlar ve iptal olup olmadığını denetler.</span><span class="sxs-lookup"><span data-stu-id="47189-150">After retrieving and restoring a page of results, `runPagedQueryAsync` reports progress and checks for cancellation.</span></span> <span data-ttu-id="47189-151">İptal isteniyorsa, `runPagedQueryAsync` bir oluşturur <xref:System.OperationCanceledException> .</span><span class="sxs-lookup"><span data-stu-id="47189-151">If cancellation has been requested, `runPagedQueryAsync` throws an <xref:System.OperationCanceledException>.</span></span>

<span data-ttu-id="47189-152">Bu kodda iyileştirilen birkaç öğe vardır.</span><span class="sxs-lookup"><span data-stu-id="47189-152">There are several elements in this code that can be improved.</span></span> <span data-ttu-id="47189-153">En önemlisi, `runPagedQueryAsync` döndürülen tüm sorunlar için depolama alanı ayırmalıdır.</span><span class="sxs-lookup"><span data-stu-id="47189-153">Most importantly, `runPagedQueryAsync` must allocate storage for all the issues returned.</span></span> <span data-ttu-id="47189-154">Tüm açık sorunların alınması, alınan tüm sorunları depolamak için çok daha fazla bellek gerektirdiğinden, bu örnek 250 sorunlarını durduruyor.</span><span class="sxs-lookup"><span data-stu-id="47189-154">This sample stops at 250 issues because retrieving all open issues would require much more memory to store all the retrieved issues.</span></span> <span data-ttu-id="47189-155">İlerleme raporlarını ve iptali destekleme protokolleri, ilk okuma sırasında algoritmayı daha zor hale getirir.</span><span class="sxs-lookup"><span data-stu-id="47189-155">The protocols for supporting progress reports and cancellation make the algorithm harder to understand on its first reading.</span></span> <span data-ttu-id="47189-156">Diğer türler ve API 'Ler dahil değildir.</span><span class="sxs-lookup"><span data-stu-id="47189-156">More types and APIs are involved.</span></span> <span data-ttu-id="47189-157"><xref:System.Threading.CancellationTokenSource> <xref:System.Threading.CancellationToken> İptalin istendiği ve nerede verildiğini anlamak için, ve arasındaki iletişimleri takip etmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="47189-157">You must trace the communications through the <xref:System.Threading.CancellationTokenSource> and its associated <xref:System.Threading.CancellationToken> to understand where cancellation is requested and where it's granted.</span></span>

## <a name="async-streams-provide-a-better-way"></a><span data-ttu-id="47189-158">Zaman uyumsuz akışlar daha iyi bir yol sağlar</span><span class="sxs-lookup"><span data-stu-id="47189-158">Async streams provide a better way</span></span>

<span data-ttu-id="47189-159">Zaman uyumsuz akışlar ve ilişkili dil desteği Bu kaygıların tümünü ele.</span><span class="sxs-lookup"><span data-stu-id="47189-159">Async streams and the associated language support address all those concerns.</span></span> <span data-ttu-id="47189-160">Diziyi oluşturan kod artık `yield return` değiştiriciyle tanımlanmış bir yöntemde öğe döndürmek için kullanabilir `async` .</span><span class="sxs-lookup"><span data-stu-id="47189-160">The code that generates the sequence can now use `yield return` to return elements in a method that was declared with the `async` modifier.</span></span> <span data-ttu-id="47189-161">Döngü kullanarak bir zaman uyumsuz akışı, bir `await foreach` döngüyü kullanarak herhangi bir diziyi tüketiğinizde kullanabilirsiniz `foreach` .</span><span class="sxs-lookup"><span data-stu-id="47189-161">You can consume an async stream using an `await foreach` loop just as you consume any sequence using a `foreach` loop.</span></span>

<span data-ttu-id="47189-162">Bu yeni dil özellikleri, 2,1 .NET Standard eklenen ve .NET Core 3,0 ' de uygulanan üç yeni arabirime bağımlıdır:</span><span class="sxs-lookup"><span data-stu-id="47189-162">These new language features depend on three new interfaces added to .NET Standard 2.1 and implemented in .NET Core 3.0:</span></span>

- <xref:System.Collections.Generic.IAsyncEnumerable%601?displayProperty=nameWithType>
- <xref:System.Collections.Generic.IAsyncEnumerator%601?displayProperty=nameWithType>
- <xref:System.IAsyncDisposable?displayProperty=nameWithType>

<span data-ttu-id="47189-163">Bu üç arabirim çoğu C# geliştiricisi için tanıdık olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="47189-163">These three interfaces should be familiar to most C# developers.</span></span> <span data-ttu-id="47189-164">Zaman uyumlu ortaklarınıza benzer bir şekilde davranır:</span><span class="sxs-lookup"><span data-stu-id="47189-164">They behave in a manner similar to their synchronous counterparts:</span></span>

- <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>
- <xref:System.Collections.Generic.IEnumerator%601?displayProperty=nameWithType>
- <xref:System.IDisposable?displayProperty=nameWithType>

<span data-ttu-id="47189-165">Alışkın olabilecek bir tür <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="47189-165">One type that may be unfamiliar is <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType>.</span></span> <span data-ttu-id="47189-166">`ValueTask`Struct, sınıfa benzer BIR API sağlar <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="47189-166">The `ValueTask` struct provides a similar API to the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="47189-167">`ValueTask`performans nedenleriyle bu arabirimlerde kullanılır.</span><span class="sxs-lookup"><span data-stu-id="47189-167">`ValueTask` is used in these interfaces for performance reasons.</span></span>

## <a name="convert-to-async-streams"></a><span data-ttu-id="47189-168">Zaman uyumsuz akışlara Dönüştür</span><span class="sxs-lookup"><span data-stu-id="47189-168">Convert to async streams</span></span>

<span data-ttu-id="47189-169">Sonra, `runPagedQueryAsync` zaman uyumsuz akış oluşturmak için yöntemini dönüştürün.</span><span class="sxs-lookup"><span data-stu-id="47189-169">Next, convert the `runPagedQueryAsync` method to generate an async stream.</span></span> <span data-ttu-id="47189-170">İlk olarak, `runPagedQueryAsync` öğesini döndürmek için imzasını değiştirin `IAsyncEnumerable<JToken>` ve aşağıdaki kodda gösterildiği gibi parametre listesinden iptal belirtecini ve ilerleme nesnelerini kaldırın:</span><span class="sxs-lookup"><span data-stu-id="47189-170">First, change the signature of `runPagedQueryAsync` to return an `IAsyncEnumerable<JToken>`, and remove the cancellation token and progress objects from the parameter list as shown in the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetUpdateSignature" :::

<span data-ttu-id="47189-171">Başlangıç kodu, aşağıdaki kodda gösterildiği gibi her sayfayı sayfa alındığından işler:</span><span class="sxs-lookup"><span data-stu-id="47189-171">The starter code processes each page as the page is retrieved, as shown in the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetProcessPage" :::

<span data-ttu-id="47189-172">Bu üç satırı aşağıdaki kodla değiştirin:</span><span class="sxs-lookup"><span data-stu-id="47189-172">Replace those three lines with the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetYieldReturnPage" :::

<span data-ttu-id="47189-173">Ayrıca, `finalResults` Bu yöntemin önceki bildirimini ve `return` değiştirdiğiniz döngüyü izleyen ifadeyi de kaldırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="47189-173">You can also remove the declaration of `finalResults` earlier in this method and the `return` statement that follows the loop you modified.</span></span>

<span data-ttu-id="47189-174">Zaman uyumsuz akış oluşturma değişikliklerini tamamladınız.</span><span class="sxs-lookup"><span data-stu-id="47189-174">You've finished the changes to generate an async stream.</span></span> <span data-ttu-id="47189-175">Tamamlanan yöntem aşağıdaki koda benzemelidir:</span><span class="sxs-lookup"><span data-stu-id="47189-175">The finished method should resemble the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetGenerateAsyncStream" :::

<span data-ttu-id="47189-176">Daha sonra, zaman uyumsuz akışı kullanmak için koleksiyonu tüketen kodu değiştirirsiniz.</span><span class="sxs-lookup"><span data-stu-id="47189-176">Next, you change the code that consumes the collection to consume the async stream.</span></span> <span data-ttu-id="47189-177">Sorun koleksiyonunu işleyen ' de aşağıdaki kodu bulun `Main` :</span><span class="sxs-lookup"><span data-stu-id="47189-177">Find the following code in `Main` that processes the collection of issues:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetEnumerateOldStyle" :::

<span data-ttu-id="47189-178">Bu kodu aşağıdaki `await foreach` döngüyle değiştirin:</span><span class="sxs-lookup"><span data-stu-id="47189-178">Replace that code with the following `await foreach` loop:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetEnumerateAsyncStream" :::

<span data-ttu-id="47189-179">Yeni arabirim <xref:System.Collections.Generic.IAsyncEnumerator%601> öğesinden türetilir <xref:System.IAsyncDisposable> .</span><span class="sxs-lookup"><span data-stu-id="47189-179">The new interface <xref:System.Collections.Generic.IAsyncEnumerator%601> derives from <xref:System.IAsyncDisposable>.</span></span> <span data-ttu-id="47189-180">Diğer bir deyişle, döngü tamamlandığında önceki döngünün akışı zaman uyumsuz olarak elden atacaktır.</span><span class="sxs-lookup"><span data-stu-id="47189-180">That means the preceding loop will asynchronously dispose the stream when the loop finishes.</span></span> <span data-ttu-id="47189-181">Döngünün aşağıdaki kod gibi göründüğünü hayal edebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="47189-181">You can imagine the loop looks like the following code:</span></span>

```csharp
int num = 0;
var enumerator = runPagedQueryAsync(client, PagedIssueQuery, "docs").GetEnumeratorAsync();
try
{
    while (await enumerator.MoveNextAsync())
    {
        var issue = enumerator.Current;
        Console.WriteLine(issue);
        Console.WriteLine($"Received {++num} issues in total");
    }
} finally
{
    if (enumerator != null)
        await enumerator.DisposeAsync();
}
```

<span data-ttu-id="47189-182">Akış öğeleri varsayılan olarak yakalanan bağlamda işlenir.</span><span class="sxs-lookup"><span data-stu-id="47189-182">By default, stream elements are processed in the captured context.</span></span> <span data-ttu-id="47189-183">Bağlam yakalamayı devre dışı bırakmak istiyorsanız, <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.ConfigureAwait%2A?displayProperty=nameWithType> genişletme yöntemini kullanın.</span><span class="sxs-lookup"><span data-stu-id="47189-183">If you want to disable capturing of the context, use the <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.ConfigureAwait%2A?displayProperty=nameWithType> extension method.</span></span> <span data-ttu-id="47189-184">Eşitleme bağlamları ve geçerli bağlamı yakalama hakkında daha fazla bilgi için [görev tabanlı zaman uyumsuz model](../../standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md)kullanma başlıklı makaleye bakın.</span><span class="sxs-lookup"><span data-stu-id="47189-184">For more information about synchronization contexts and capturing the current context, see the article on [consuming the Task-based asynchronous pattern](../../standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span></span>

<span data-ttu-id="47189-185">Zaman uyumsuz akışlar, diğer yöntemlerle aynı protokolü kullanarak iptali destekler `async` .</span><span class="sxs-lookup"><span data-stu-id="47189-185">Async streams support cancellation using the same protocol as other `async` methods.</span></span> <span data-ttu-id="47189-186">İptali desteklemek için zaman uyumsuz Yineleyici yönteminin imzasını aşağıdaki şekilde değiştirirsiniz:</span><span class="sxs-lookup"><span data-stu-id="47189-186">You would modify the signature for the async iterator method as follows to support cancellation:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetGenerateWithCancellation" :::

<span data-ttu-id="47189-187"><xref:System.Runtime.CompilerServices.EnumeratorCancellationAttribute?dipslayProperty=nameWithType>Özniteliği, derleyicinin, <xref:System.Collections.Generic.IAsyncEnumerator%601> belirtecin `GetAsyncEnumerator` zaman uyumsuz yineleyicinin gövdesine bu bağımsız değişken olarak geçirilmesini sağlayan kod oluşturmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="47189-187">The <xref:System.Runtime.CompilerServices.EnumeratorCancellationAttribute?dipslayProperty=nameWithType> attribute causes the compiler to generate code for the <xref:System.Collections.Generic.IAsyncEnumerator%601> that makes the token passed to `GetAsyncEnumerator` visible to the body of the async iterator as that argument.</span></span> <span data-ttu-id="47189-188">İçinde `runQueryAsync` , belirtecin durumunu inceleyebilir ve istenirse daha fazla çalışmayı iptal edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="47189-188">Inside `runQueryAsync`, you could examine the state of the token and cancel further work if requested.</span></span>

<span data-ttu-id="47189-189"><xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.WithCancellation%2A>İptal belirtecini zaman uyumsuz akışa geçirmek için başka bir genişletme yöntemi kullanın.</span><span class="sxs-lookup"><span data-stu-id="47189-189">You use another extension method, <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.WithCancellation%2A>, to pass the cancellation token to the async stream.</span></span> <span data-ttu-id="47189-190">Sorunları şu şekilde numaralandırarak aşağıdaki gibi düzenleyin:</span><span class="sxs-lookup"><span data-stu-id="47189-190">You would modify the loop enumerating the issues as follows:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetEnumerateWithCancellation" :::

<span data-ttu-id="47189-191">Tamamlanan öğreticinin kodunu [CSharp/öğreticiler/AsyncStreams](https://github.com/dotnet/docs/tree/master/docs/csharp/tutorials/snippets/generate-consume-asynchronous-streams/finished) klasöründeki [DotNet/docs](https://github.com/dotnet/docs) deposundan alabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="47189-191">You can get the code for the finished tutorial from the [dotnet/docs](https://github.com/dotnet/docs) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/docs/tree/master/docs/csharp/tutorials/snippets/generate-consume-asynchronous-streams/finished) folder.</span></span>

## <a name="run-the-finished-application"></a><span data-ttu-id="47189-192">Tamamlanmış uygulamayı çalıştırma</span><span class="sxs-lookup"><span data-stu-id="47189-192">Run the finished application</span></span>

<span data-ttu-id="47189-193">Uygulamayı yeniden çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="47189-193">Run the application again.</span></span> <span data-ttu-id="47189-194">Davranışını, başlangıç uygulamasının davranışıyla kontrast.</span><span class="sxs-lookup"><span data-stu-id="47189-194">Contrast its behavior with the behavior of the starter application.</span></span> <span data-ttu-id="47189-195">Sonuçların ilk sayfası, kullanılabilir duruma geldiğinde numaralandırılır.</span><span class="sxs-lookup"><span data-stu-id="47189-195">The first page of results is enumerated as soon as it's available.</span></span> <span data-ttu-id="47189-196">Her yeni sayfa istendiği ve alındığı için bir observable durakladıkça, sonraki sayfanın sonuçları hızla numaralandırılır.</span><span class="sxs-lookup"><span data-stu-id="47189-196">There's an observable pause as each new page is requested and retrieved, then the next page's results are quickly enumerated.</span></span> <span data-ttu-id="47189-197">`try`  /  `catch` İptali işlemek için blok gerekmez: çağıran, koleksiyonu listemeyi durdurabilir.</span><span class="sxs-lookup"><span data-stu-id="47189-197">The `try` / `catch` block isn't needed to handle cancellation: the caller can stop enumerating the collection.</span></span> <span data-ttu-id="47189-198">Zaman uyumsuz akış, her sayfa indirildiğinden sonuçlar oluşturduğundan, ilerleme durumu açıkça raporlanır.</span><span class="sxs-lookup"><span data-stu-id="47189-198">Progress is clearly reported because the async stream generates results as each page is downloaded.</span></span> <span data-ttu-id="47189-199">Döndürülen her bir sorunun durumu, döngüye sorunsuz bir şekilde dahildir `await foreach` .</span><span class="sxs-lookup"><span data-stu-id="47189-199">The status for each issue returned is seamlessly included in the `await foreach` loop.</span></span> <span data-ttu-id="47189-200">İlerlemeyi izlemek için bir geri çağırma nesnesine gerek yoktur.</span><span class="sxs-lookup"><span data-stu-id="47189-200">You don't need a callback object to track progress.</span></span>

<span data-ttu-id="47189-201">Kodu inceleyerek, bellek kullanımıyla iyileştirmeleri görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="47189-201">You can see improvements in memory use by examining the code.</span></span> <span data-ttu-id="47189-202">Artık tüm sonuçları numaralandırılmadan önce depolamak için bir koleksiyon ayırmanız gerekmez.</span><span class="sxs-lookup"><span data-stu-id="47189-202">You no longer need to allocate a collection to store all the results before they're enumerated.</span></span> <span data-ttu-id="47189-203">Çağıran, sonuçların nasıl kullanıldığını ve bir depolama koleksiyonu gerekip gerekmediğini belirleyebilir.</span><span class="sxs-lookup"><span data-stu-id="47189-203">The caller can determine how to consume the results and if a storage collection is needed.</span></span>

<span data-ttu-id="47189-204">Hem Başlatıcı hem de tamamlanmış uygulamaları çalıştırın ve uygulamalar arasındaki farklılıkları gözlemleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="47189-204">Run both the starter and finished applications and you can observe the differences between the implementations for yourself.</span></span> <span data-ttu-id="47189-205">İşiniz bittiğinde, bu öğreticiyi başlattığınızda oluşturduğunuz GitHub erişim belirtecini silebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="47189-205">You can delete the GitHub access token you created when you started this tutorial after you've finished.</span></span> <span data-ttu-id="47189-206">Bir saldırgan bu belirtece erişim kazanırsa, kimlik bilgilerinizi kullanarak GitHub API 'Lerine erişebilirler.</span><span class="sxs-lookup"><span data-stu-id="47189-206">If an attacker gained access to that token, they could access GitHub APIs using your credentials.</span></span>
