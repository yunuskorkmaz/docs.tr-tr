---
title: İçindeki C# sınıflar ve nesneler- C# dilin turu
description: Yeni C#misiniz? Sınıflar, nesneler ve devralmayla bu genel bakışı okuyun
ms.date: 08/10/2016
ms.assetid: 63a89bde-0f05-4bc4-b0cd-4f693854f0cd
ms.openlocfilehash: be8e760b19b7ca5305918ecfdbf9ad797d7e76b2
ms.sourcegitcommit: 6f28b709592503d27077b16fff2e2eacca569992
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 08/28/2019
ms.locfileid: "70105628"
---
# <a name="classes-and-objects"></a><span data-ttu-id="5304e-104">Sınıflar ve nesneler</span><span class="sxs-lookup"><span data-stu-id="5304e-104">Classes and objects</span></span>

<span data-ttu-id="5304e-105">*Sınıflar* , türlerin en temel C#larıdır.</span><span class="sxs-lookup"><span data-stu-id="5304e-105">*Classes* are the most fundamental of C#’s types.</span></span> <span data-ttu-id="5304e-106">Bir sınıf, durumu (alanları) ve eylemleri (Yöntemler ve diğer işlev üyelerini) tek bir birimde birleştiren bir veri yapısıdır.</span><span class="sxs-lookup"><span data-stu-id="5304e-106">A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit.</span></span> <span data-ttu-id="5304e-107">Sınıf, *nesne*olarak da bilinen, sınıfının dinamik olarak oluşturulan *örnekleri* için bir tanım sağlar.</span><span class="sxs-lookup"><span data-stu-id="5304e-107">A class provides a definition for dynamically created *instances* of the class, also known as *objects*.</span></span> <span data-ttu-id="5304e-108">Sınıflar, *Devralma* ve çok *biçimlilik*desteği, *türetilmiş sınıfların* *temel sınıfları*genişletebileceği ve özelleştirilebilecek mekanizmalar.</span><span class="sxs-lookup"><span data-stu-id="5304e-108">Classes support *inheritance* and *polymorphism*, mechanisms whereby *derived classes* can extend and specialize *base classes*.</span></span>

<span data-ttu-id="5304e-109">Yeni sınıflar sınıf bildirimleri kullanılarak oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="5304e-109">New classes are created using class declarations.</span></span> <span data-ttu-id="5304e-110">Sınıf bildirimi, sınıfın özniteliklerini ve değiştiricilerini, sınıfın adını, Taban sınıfını (belirtilmişse) ve sınıf tarafından uygulanan arabirimleri belirten bir üstbilgiyle başlar.</span><span class="sxs-lookup"><span data-stu-id="5304e-110">A class declaration starts with a header that specifies the attributes and modifiers of the class, the name of the class, the base class (if given), and the interfaces implemented by the class.</span></span> <span data-ttu-id="5304e-111">Üst bilgi, sınırlayıcılar `{` ve `}`arasında yazılmış üye bildirimlerinin listesinden oluşan sınıf gövdesinden gelir.</span><span class="sxs-lookup"><span data-stu-id="5304e-111">The header is followed by the class body, which consists of a list of member declarations written between the delimiters `{` and `}`.</span></span>

<span data-ttu-id="5304e-112">Aşağıda adlı `Point`basit bir sınıfın bildirimi verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="5304e-112">The following is a declaration of a simple class named `Point`:</span></span>

[!code-csharp[PointClass](~/samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L11)]

<span data-ttu-id="5304e-113">Sınıf örnekleri, yeni bir örnek için `new` bellek ayıran işleç kullanılarak oluşturulur, örneği başlatmak için bir oluşturucu çağırır ve örneğe bir başvuru döndürür.</span><span class="sxs-lookup"><span data-stu-id="5304e-113">Instances of classes are created using the `new` operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance.</span></span> <span data-ttu-id="5304e-114">Aşağıdaki deyimler iki nokta nesnesi oluşturur ve bu nesnelere başvuruları iki değişken halinde depolar:</span><span class="sxs-lookup"><span data-stu-id="5304e-114">The following statements create two Point objects and store references to those objects in two variables:</span></span>

[!code-csharp[PointExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L9-L10)]

<span data-ttu-id="5304e-115">Nesne artık erişilebilir olmadığında bir nesnenin kapladığı bellek otomatik olarak geri kazanılır.</span><span class="sxs-lookup"><span data-stu-id="5304e-115">The memory occupied by an object is automatically reclaimed when the object is no longer reachable.</span></span> <span data-ttu-id="5304e-116">Üzerinde C#nesneleri açıkça serbest bırakmak gerekli değildir veya mümkün değildir.</span><span class="sxs-lookup"><span data-stu-id="5304e-116">It is neither necessary nor possible to explicitly deallocate objects in C#.</span></span>

## <a name="members"></a><span data-ttu-id="5304e-117">Üyeler</span><span class="sxs-lookup"><span data-stu-id="5304e-117">Members</span></span>

<span data-ttu-id="5304e-118">Bir sınıfın üyeleri statik üyeler veya örnek üyeleridir.</span><span class="sxs-lookup"><span data-stu-id="5304e-118">The members of a class are either static members or instance members.</span></span> <span data-ttu-id="5304e-119">Statik Üyeler sınıflara aittir ve örnek üyeleri nesnelere aittir (sınıf örnekleri).</span><span class="sxs-lookup"><span data-stu-id="5304e-119">Static members belong to classes, and instance members belong to objects (instances of classes).</span></span>

<span data-ttu-id="5304e-120">Aşağıda bir sınıfın içerebileceği üye türlerine ilişkin bir genel bakış sunulmaktadır.</span><span class="sxs-lookup"><span data-stu-id="5304e-120">The following provides an overview of the kinds of members a class can contain.</span></span>

- <span data-ttu-id="5304e-121">Sabitler</span><span class="sxs-lookup"><span data-stu-id="5304e-121">Constants</span></span>
  - <span data-ttu-id="5304e-122">Sınıfla ilişkili sabit değerler</span><span class="sxs-lookup"><span data-stu-id="5304e-122">Constant values associated with the class</span></span>
- <span data-ttu-id="5304e-123">Alanlar</span><span class="sxs-lookup"><span data-stu-id="5304e-123">Fields</span></span>
  - <span data-ttu-id="5304e-124">Sınıfın değişkenleri</span><span class="sxs-lookup"><span data-stu-id="5304e-124">Variables of the class</span></span>
- <span data-ttu-id="5304e-125">Yöntemler</span><span class="sxs-lookup"><span data-stu-id="5304e-125">Methods</span></span>
  - <span data-ttu-id="5304e-126">Sınıfı tarafından gerçekleştirilebilecek hesaplamalar ve eylemler</span><span class="sxs-lookup"><span data-stu-id="5304e-126">Computations and actions that can be performed by the class</span></span>
- <span data-ttu-id="5304e-127">Özellikler</span><span class="sxs-lookup"><span data-stu-id="5304e-127">Properties</span></span>
  - <span data-ttu-id="5304e-128">Sınıfın adlandırılmış özelliklerini okuma ve yazma ile ilişkili eylemler</span><span class="sxs-lookup"><span data-stu-id="5304e-128">Actions associated with reading and writing named properties of the class</span></span>
- <span data-ttu-id="5304e-129">Dizin Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="5304e-129">Indexers</span></span>
  - <span data-ttu-id="5304e-130">Bir dizi gibi sınıfın dizin oluşturma örnekleri ile ilişkili eylemler</span><span class="sxs-lookup"><span data-stu-id="5304e-130">Actions associated with indexing instances of the class like an array</span></span>
- <span data-ttu-id="5304e-131">Olaylar</span><span class="sxs-lookup"><span data-stu-id="5304e-131">Events</span></span>
  - <span data-ttu-id="5304e-132">Sınıfı tarafından oluşturulabilecek bildirimler</span><span class="sxs-lookup"><span data-stu-id="5304e-132">Notifications that can be generated by the class</span></span>
- <span data-ttu-id="5304e-133">İşleçler</span><span class="sxs-lookup"><span data-stu-id="5304e-133">Operators</span></span>
  - <span data-ttu-id="5304e-134">Sınıf tarafından desteklenen dönüşümler ve ifade işleçleri</span><span class="sxs-lookup"><span data-stu-id="5304e-134">Conversions and expression operators supported by the class</span></span>
- <span data-ttu-id="5304e-135">Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="5304e-135">Constructors</span></span>
  - <span data-ttu-id="5304e-136">Sınıfın veya sınıfın örneklerinin örneğini başlatmak için gereken eylemler</span><span class="sxs-lookup"><span data-stu-id="5304e-136">Actions required to initialize instances of the class or the class itself</span></span>
- <span data-ttu-id="5304e-137">Sonlandırıcılar</span><span class="sxs-lookup"><span data-stu-id="5304e-137">Finalizers</span></span>
  - <span data-ttu-id="5304e-138">Sınıfın örneklerinden önce gerçekleştirilecek eylemler kalıcı olarak atılır</span><span class="sxs-lookup"><span data-stu-id="5304e-138">Actions to perform before instances of the class are permanently discarded</span></span>
- <span data-ttu-id="5304e-139">Türler</span><span class="sxs-lookup"><span data-stu-id="5304e-139">Types</span></span>
  - <span data-ttu-id="5304e-140">Sınıf tarafından tanımlanan iç içe türler</span><span class="sxs-lookup"><span data-stu-id="5304e-140">Nested types declared by the class</span></span>

## <a name="accessibility"></a><span data-ttu-id="5304e-141">Erişilebilirlik</span><span class="sxs-lookup"><span data-stu-id="5304e-141">Accessibility</span></span>

<span data-ttu-id="5304e-142">Bir sınıfın her üyesinin ilişkili bir erişilebilirliği vardır ve bu, üyeye erişebilen program metni bölgelerini denetler.</span><span class="sxs-lookup"><span data-stu-id="5304e-142">Each member of a class has an associated accessibility, which controls the regions of program text that are able to access the member.</span></span> <span data-ttu-id="5304e-143">Olası altı erişilebilirlik biçimi vardır.</span><span class="sxs-lookup"><span data-stu-id="5304e-143">There are six possible forms of accessibility.</span></span> <span data-ttu-id="5304e-144">Bunlar aşağıda özetlenmiştir.</span><span class="sxs-lookup"><span data-stu-id="5304e-144">These are summarized below.</span></span>

- `public`
  - <span data-ttu-id="5304e-145">Erişim sınırlı değil</span><span class="sxs-lookup"><span data-stu-id="5304e-145">Access not limited</span></span>
- `protected`
  - <span data-ttu-id="5304e-146">Bu sınıftan türetilmiş bu sınıfla veya sınıflarla sınırlı erişim</span><span class="sxs-lookup"><span data-stu-id="5304e-146">Access limited to this class or classes derived from this class</span></span>
- `internal`
  - <span data-ttu-id="5304e-147">Geçerli bütünleştirilmiş koda (. exe,. dll, vb.) sınırlı erişim</span><span class="sxs-lookup"><span data-stu-id="5304e-147">Access limited to the current assembly (.exe, .dll, etc.)</span></span>
- `protected internal`
  - <span data-ttu-id="5304e-148">İçerilen sınıfla sınırlı erişim, kapsayan sınıftan türetilmiş sınıflar veya aynı derleme içindeki sınıflar</span><span class="sxs-lookup"><span data-stu-id="5304e-148">Access limited to the containing class, classes derived from the containing class, or classes within the same assembly</span></span>
- `private`
  - <span data-ttu-id="5304e-149">Bu sınıfla sınırlı erişim</span><span class="sxs-lookup"><span data-stu-id="5304e-149">Access limited to this class</span></span>
- `private protected`
  - <span data-ttu-id="5304e-150">Aynı derleme içindeki kapsayan türden türetilmiş kapsayan sınıf veya sınıflarla sınırlı erişim</span><span class="sxs-lookup"><span data-stu-id="5304e-150">Access limited to the containing class or classes derived from the containing type within the same assembly</span></span>

## <a name="type-parameters"></a><span data-ttu-id="5304e-151">Tür parametreleri</span><span class="sxs-lookup"><span data-stu-id="5304e-151">Type parameters</span></span>

<span data-ttu-id="5304e-152">Sınıf tanımı, tür parametre adlarının bir listesini kapsayan açılı ayraçları olan sınıf adını izleyerek bir tür parametreleri kümesi belirtebilir.</span><span class="sxs-lookup"><span data-stu-id="5304e-152">A class definition may specify a set of type parameters by following the class name with angle brackets enclosing a list of type parameter names.</span></span> <span data-ttu-id="5304e-153">Daha sonra tür parametreleri sınıfının üyelerini tanımlamak için sınıf bildirimlerinin gövdesinde kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="5304e-153">The type parameters can then be used in the body of the class declarations to define the members of the class.</span></span> <span data-ttu-id="5304e-154">Aşağıdaki örnekte, öğesinin `Pair` `TFirst` tür parametreleri ve `TSecond`:</span><span class="sxs-lookup"><span data-stu-id="5304e-154">In the following example, the type parameters of `Pair` are `TFirst` and `TSecond`:</span></span>

[!code-csharp[Pair](~/samples/snippets/csharp/tour/classes-and-objects/Pair.cs#L3-L7)]

<span data-ttu-id="5304e-155">Tür parametrelerini almak için belirtilen bir sınıf türüne *Genel sınıf türü*denir.</span><span class="sxs-lookup"><span data-stu-id="5304e-155">A class type that is declared to take type parameters is called a *generic class type*.</span></span> <span data-ttu-id="5304e-156">Yapı, arabirim ve temsilci türleri de genel olabilir.</span><span class="sxs-lookup"><span data-stu-id="5304e-156">Struct, interface and delegate types can also be generic.</span></span>
<span data-ttu-id="5304e-157">Genel sınıf kullanıldığında, tür parametrelerinin her biri için tür bağımsız değişkenlerinin sağlanması gerekir:</span><span class="sxs-lookup"><span data-stu-id="5304e-157">When the generic class is used, type arguments must be provided for each of the type parameters:</span></span>

[!code-csharp[PairExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L15-L17)]

<span data-ttu-id="5304e-158">Yukarıda olduğu gibi `Pair<int,string>` , tür bağımsız değişkenlerine sahip genel bir tür, oluşturulmuş bir *tür*olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="5304e-158">A generic type with type arguments provided, like `Pair<int,string>` above, is called a *constructed type*.</span></span>

## <a name="base-classes"></a><span data-ttu-id="5304e-159">Temel sınıflar</span><span class="sxs-lookup"><span data-stu-id="5304e-159">Base classes</span></span>

<span data-ttu-id="5304e-160">Sınıf bildirimi, sınıf adı ve tür parametreleri iki nokta ve temel sınıfın adı ile birlikte bir temel sınıf belirtebilir.</span><span class="sxs-lookup"><span data-stu-id="5304e-160">A class declaration may specify a base class by following the class name and type parameters with a colon and the name of the base class.</span></span> <span data-ttu-id="5304e-161">Temel sınıf belirtiminin atlanması, türden `object`türetmeye benzer.</span><span class="sxs-lookup"><span data-stu-id="5304e-161">Omitting a base class specification is the same as deriving from type `object`.</span></span> <span data-ttu-id="5304e-162">`Point3D` Aşağıdaki örnekte, öğesinin `Point`temel sınıfı ve öğesinin `Point` `object`temel sınıfı:</span><span class="sxs-lookup"><span data-stu-id="5304e-162">In the following example, the base class of `Point3D` is `Point`, and the base class of `Point` is `object`:</span></span>

[!code-csharp[Point3DClass](~/samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L20)]

<span data-ttu-id="5304e-163">Bir sınıf, temel sınıfının üyelerini devralır.</span><span class="sxs-lookup"><span data-stu-id="5304e-163">A class inherits the members of its base class.</span></span> <span data-ttu-id="5304e-164">Devralma, bir sınıfın örnek ve statik oluşturucular ve temel sınıfın sonlandırıcıları dışında, temel sınıfının tüm üyelerini örtük olarak içerdiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="5304e-164">Inheritance means that a class implicitly contains all members of its base class, except for the instance and static constructors, and the finalizers of the base class.</span></span> <span data-ttu-id="5304e-165">Türetilmiş bir sınıf, devralananlara yeni üyeler ekleyebilir, ancak devralınmış bir üyenin tanımını kaldıramaz.</span><span class="sxs-lookup"><span data-stu-id="5304e-165">A derived class can add new members to those it inherits, but it cannot remove the definition of an inherited member.</span></span> <span data-ttu-id="5304e-166">Önceki örnekte `Point3D` , `Point3D` `x` `z`ve alanlarını`y` öğesinden`Point`devralır ve her örnek üç alan`y`içerir,, ve. `x`</span><span class="sxs-lookup"><span data-stu-id="5304e-166">In the previous example, `Point3D` inherits the `x` and `y` fields from `Point`, and every `Point3D` instance contains three fields, `x`, `y`, and `z`.</span></span>

<span data-ttu-id="5304e-167">Bir sınıf türünden, temel sınıf türlerinden herhangi birine örtük bir dönüştürme vardır.</span><span class="sxs-lookup"><span data-stu-id="5304e-167">An implicit conversion exists from a class type to any of its base class types.</span></span> <span data-ttu-id="5304e-168">Bu nedenle, bir sınıf türünün değişkeni bu sınıfın bir örneğine veya türetilmiş herhangi bir sınıfın örneğine başvurabilir.</span><span class="sxs-lookup"><span data-stu-id="5304e-168">Therefore, a variable of a class type can reference an instance of that class or an instance of any derived class.</span></span> <span data-ttu-id="5304e-169">Örneğin, önceki sınıf bildirimleri verildiğinde, türünde `Point` bir değişken bir `Point` veya a `Point3D`başvurabilir:</span><span class="sxs-lookup"><span data-stu-id="5304e-169">For example, given the previous class declarations, a variable of type `Point` can reference either a `Point` or a `Point3D`:</span></span>

[!code-csharp[Point3DExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L22-L23)]

## <a name="fields"></a><span data-ttu-id="5304e-170">Alanlar</span><span class="sxs-lookup"><span data-stu-id="5304e-170">Fields</span></span>

<span data-ttu-id="5304e-171">*Alan* , bir sınıf ile veya bir sınıf örneğiyle ilişkili bir değişkendir.</span><span class="sxs-lookup"><span data-stu-id="5304e-171">A *field* is a variable that is associated with a class or with an instance of a class.</span></span>

<span data-ttu-id="5304e-172">Statik değiştiriciyle belirtilen bir alan statik bir alan tanımlar.</span><span class="sxs-lookup"><span data-stu-id="5304e-172">A field declared with the static modifier defines a static field.</span></span> <span data-ttu-id="5304e-173">Statik alan tam olarak bir depolama konumunu tanımlar.</span><span class="sxs-lookup"><span data-stu-id="5304e-173">A static field identifies exactly one storage location.</span></span> <span data-ttu-id="5304e-174">Bir sınıfın kaç örneğinin oluşturulduğuna bakılmaksızın, bir statik alanın yalnızca bir kopyası vardır.</span><span class="sxs-lookup"><span data-stu-id="5304e-174">No matter how many instances of a class are created, there is only ever one copy of a static field.</span></span>

<span data-ttu-id="5304e-175">Statik değiştirici olmadan belirtilen bir alan bir örnek alanını tanımlar.</span><span class="sxs-lookup"><span data-stu-id="5304e-175">A field declared without the static modifier defines an instance field.</span></span> <span data-ttu-id="5304e-176">Bir sınıfın her örneği, bu sınıfın tüm örnek alanlarının ayrı bir kopyasını içerir.</span><span class="sxs-lookup"><span data-stu-id="5304e-176">Every instance of a class contains a separate copy of all the instance fields of that class.</span></span>

<span data-ttu-id="5304e-177">Aşağıdaki örnekte `Color` , sınıfının her örneği `r`, `g`, ve `b` `Black`örnek `Red`alanlarının ayrı bir kopyasına sahiptir ancak `White` ,,,,,,,,,,,,,,,,,,,`Green` ve`Blue` statik alanları:</span><span class="sxs-lookup"><span data-stu-id="5304e-177">In the following example, each instance of the `Color` class has a separate copy of the `r`, `g`, and `b` instance fields, but there is only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:</span></span>

[!code-csharp[ColorClass](~/samples/snippets/csharp/tour/classes-and-objects/Color.cs#L3-L17)]

<span data-ttu-id="5304e-178">Önceki örnekte gösterildiği gibi, *salt okuma alanları* bir `readonly` değiştirici ile bildirilebilecek.</span><span class="sxs-lookup"><span data-stu-id="5304e-178">As shown in the previous example, *read-only fields* may be declared with a `readonly` modifier.</span></span> <span data-ttu-id="5304e-179">Bir `readonly` alana atama yalnızca alanın bildiriminin veya aynı sınıftaki bir oluşturucunun parçası olarak gerçekleşebilir.</span><span class="sxs-lookup"><span data-stu-id="5304e-179">Assignment to a `readonly` field can only occur as part of the field’s declaration or in a constructor in the same class.</span></span>

## <a name="methods"></a><span data-ttu-id="5304e-180">Yöntemler</span><span class="sxs-lookup"><span data-stu-id="5304e-180">Methods</span></span>

<span data-ttu-id="5304e-181">Bir *Yöntem* , bir nesne veya sınıf tarafından gerçekleştirilebilecek bir hesaplama veya eylem uygulayan bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="5304e-181">A *method* is a member that implements a computation or action that can be performed by an object or class.</span></span> <span data-ttu-id="5304e-182">*Statik yöntemlere* sınıfı aracılığıyla erişilir.</span><span class="sxs-lookup"><span data-stu-id="5304e-182">*Static methods* are accessed through the class.</span></span> <span data-ttu-id="5304e-183">*Örnek yöntemlerine* , sınıfının örnekleri aracılığıyla erişilir.</span><span class="sxs-lookup"><span data-stu-id="5304e-183">*Instance methods* are accessed through instances of the class.</span></span>

<span data-ttu-id="5304e-184">Yöntemler, yönteme geçirilen değerleri veya değişken başvurularını temsil eden bir *parametre*listesine ve hesaplanan ve yöntem tarafından döndürülen değer türünü belirten bir *dönüş türüne*sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="5304e-184">Methods may have a list of *parameters*, which represent values or variable references passed to the method, and a *return type*, which specifies the type of the value computed and returned by the method.</span></span> <span data-ttu-id="5304e-185">Bir yöntemin dönüş türü `void` bir değer döndürmezse.</span><span class="sxs-lookup"><span data-stu-id="5304e-185">A method’s return type is `void` if it does not return a value.</span></span>

<span data-ttu-id="5304e-186">Türler gibi yöntemler de bir tür parametreleri kümesine sahip olabilir, bu da yöntem çağrıldığında tür bağımsız değişkenlerinin belirtilmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="5304e-186">Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</span></span> <span data-ttu-id="5304e-187">Türlerin aksine, tür bağımsız değişkenleri genellikle yöntem çağrısının bağımsız değişkenlerinden çıkarsanamıyor ve açıkça verilmemelidir.</span><span class="sxs-lookup"><span data-stu-id="5304e-187">Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</span></span>

<span data-ttu-id="5304e-188">Yöntemin *imzası* , yöntemin bildirildiği sınıfta benzersiz olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="5304e-188">The *signature* of a method must be unique in the class in which the method is declared.</span></span> <span data-ttu-id="5304e-189">Bir yöntemin imzası yöntemin adından, tür parametrelerinin sayısına ve parametrelerinin sayısına, değiştiricilerine ve türlerine sahiptir.</span><span class="sxs-lookup"><span data-stu-id="5304e-189">The signature of a method consists of the name of the method, the number of type parameters and the number, modifiers, and types of its parameters.</span></span> <span data-ttu-id="5304e-190">Bir yöntemin imzası, dönüş türünü içermez.</span><span class="sxs-lookup"><span data-stu-id="5304e-190">The signature of a method does not include the return type.</span></span>

### <a name="parameters"></a><span data-ttu-id="5304e-191">Parametreler</span><span class="sxs-lookup"><span data-stu-id="5304e-191">Parameters</span></span>

<span data-ttu-id="5304e-192">Parametreler, değerlere veya değişken başvurularını yöntemlere geçirmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="5304e-192">Parameters are used to pass values or variable references to methods.</span></span> <span data-ttu-id="5304e-193">Bir yöntemin parametreleri, yöntemi çağrıldığında belirtilen *bağımsız değişkenlerden* gerçek değerlerini alır.</span><span class="sxs-lookup"><span data-stu-id="5304e-193">The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked.</span></span> <span data-ttu-id="5304e-194">Dört tür parametre vardır: değer parametreleri, başvuru parametreleri, çıkış parametreleri ve parametre dizileri.</span><span class="sxs-lookup"><span data-stu-id="5304e-194">There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</span></span>

<span data-ttu-id="5304e-195">Giriş bağımsız değişkenlerini geçirmek için bir *değer parametresi* kullanılır.</span><span class="sxs-lookup"><span data-stu-id="5304e-195">A *value parameter* is used for passing input arguments.</span></span> <span data-ttu-id="5304e-196">Değer parametresi, parametresi için geçirilen bağımsız değişkenden ilk değerini alan yerel bir değişkene karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="5304e-196">A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</span></span> <span data-ttu-id="5304e-197">Değer parametresindeki değişiklikler, parametresi için geçirilen bağımsız değişkeni etkilemez.</span><span class="sxs-lookup"><span data-stu-id="5304e-197">Modifications to a value parameter do not affect the argument that was passed for the parameter.</span></span>

<span data-ttu-id="5304e-198">Değer parametreleri, ilgili bağımsız değişkenlerin atlanabilmesi için varsayılan bir değer belirtilerek isteğe bağlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="5304e-198">Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</span></span>

<span data-ttu-id="5304e-199">*Başvuru parametresi* , bağımsız değişkenleri başvuruya göre geçirmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="5304e-199">A *reference parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="5304e-200">Başvuru parametresi için geçirilen bağımsız değişken, kesin bir değere sahip bir değişken olmalıdır ve yöntemin yürütülmesi sırasında başvuru parametresi, bağımsız değişken değişkeniyle aynı depolama konumunu temsil eder.</span><span class="sxs-lookup"><span data-stu-id="5304e-200">The argument passed for a reference parameter must be a variable with a definite value, and during execution of the method, the reference parameter represents the same storage location as the argument variable.</span></span> <span data-ttu-id="5304e-201">Bir başvuru parametresi `ref` değiştiriciyle birlikte bildirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="5304e-201">A reference parameter is declared with the `ref` modifier.</span></span> <span data-ttu-id="5304e-202">Aşağıdaki örnek `ref` parametrelerin kullanımını gösterir.</span><span class="sxs-lookup"><span data-stu-id="5304e-202">The following example shows the use of `ref` parameters.</span></span>

[!code-csharp[swapExample](~/samples/snippets/csharp/tour/classes-and-objects/RefExample.cs#L3-L18)]

<span data-ttu-id="5304e-203">Bir *output parametresi* , bağımsız değişkenleri başvuruya göre geçirmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="5304e-203">An *output parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="5304e-204">Bir başvuru parametresine benzer, ancak çağıran tarafından belirtilen bağımsız değişkene açıkça bir değer atamanız gerekmez.</span><span class="sxs-lookup"><span data-stu-id="5304e-204">It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</span></span> <span data-ttu-id="5304e-205">Bir çıkış parametresi `out` değiştiriciyle birlikte bildirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="5304e-205">An output parameter is declared with the `out` modifier.</span></span> <span data-ttu-id="5304e-206">Aşağıdaki örnek, 7 ' de `out` C# tanıtılan sözdizimi kullanılarak parametrelerin kullanımını gösterir.</span><span class="sxs-lookup"><span data-stu-id="5304e-206">The following example shows the use of `out` parameters using the syntax introduced in C# 7.</span></span>

[!code-csharp[OutExample](~/samples/snippets/csharp/tour/classes-and-objects/OutExample.cs#L3-L17)]

<span data-ttu-id="5304e-207">Bir *parametre dizisi* , bir metoda değişken sayıda bağımsız değişken geçirilmesine izin verir.</span><span class="sxs-lookup"><span data-stu-id="5304e-207">A *parameter array* permits a variable number of arguments to be passed to a method.</span></span> <span data-ttu-id="5304e-208">Bir parametre dizisi `params` değiştiriciyle birlikte bildirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="5304e-208">A parameter array is declared with the `params` modifier.</span></span> <span data-ttu-id="5304e-209">Bir yöntemin yalnızca son parametresi bir parametre dizisi olabilir ve bir parametre dizisinin türü tek boyutlu bir dizi türü olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="5304e-209">Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</span></span> <span data-ttu-id="5304e-210"><xref:System.Console?displayProperty=nameWithType> Sınıfının Write ve WriteLine yöntemleri, parametre dizisi kullanımının iyi örnekleridir.</span><span class="sxs-lookup"><span data-stu-id="5304e-210">The Write and WriteLine methods of the <xref:System.Console?displayProperty=nameWithType> class are good examples of parameter array usage.</span></span> <span data-ttu-id="5304e-211">Bunlar aşağıdaki gibi bildirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="5304e-211">They are declared as follows.</span></span>

[!code-csharp[ConsoleExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L78-L83)]

<span data-ttu-id="5304e-212">Bir parametre dizisi kullanan bir yöntem içinde, parametre dizisi tam olarak bir dizi türünün normal parametresine benzer şekilde davranır.</span><span class="sxs-lookup"><span data-stu-id="5304e-212">Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</span></span> <span data-ttu-id="5304e-213">Ancak, bir parametre dizisi olan bir yöntem çağrısında, parametre dizisi türünün tek bir bağımsız değişkenini veya parametre dizisinin öğe türünün herhangi bir sayıda bağımsız değişkenini geçirmek mümkündür.</span><span class="sxs-lookup"><span data-stu-id="5304e-213">However, in an invocation of a method with a parameter array, it is possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</span></span> <span data-ttu-id="5304e-214">İkinci durumda, bir dizi örneği otomatik olarak oluşturulur ve verilen bağımsız değişkenlerle başlatılır.</span><span class="sxs-lookup"><span data-stu-id="5304e-214">In the latter case, an array instance is automatically created and initialized with the given arguments.</span></span> <span data-ttu-id="5304e-215">Bu örnek</span><span class="sxs-lookup"><span data-stu-id="5304e-215">This example</span></span>

[!code-csharp[StringFormat](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L55-L55)]

<span data-ttu-id="5304e-216">, aşağıdaki yazma ile eşdeğerdir.</span><span class="sxs-lookup"><span data-stu-id="5304e-216">is equivalent to writing the following.</span></span>

[!code-csharp[StringFormat2](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L30-L35)]

### <a name="method-body-and-local-variables"></a><span data-ttu-id="5304e-217">Yöntem gövdesi ve yerel değişkenler</span><span class="sxs-lookup"><span data-stu-id="5304e-217">Method body and local variables</span></span>

<span data-ttu-id="5304e-218">Yöntemin gövdesi, yöntemi çağrıldığında yürütülecek deyimleri belirtir.</span><span class="sxs-lookup"><span data-stu-id="5304e-218">A method’s body specifies the statements to execute when the method is invoked.</span></span>

<span data-ttu-id="5304e-219">Yöntem gövdesi, yöntemi çağrısına özgü değişkenleri bildirebilir.</span><span class="sxs-lookup"><span data-stu-id="5304e-219">A method body can declare variables that are specific to the invocation of the method.</span></span> <span data-ttu-id="5304e-220">Bu tür değişkenlere *yerel değişkenler*denir.</span><span class="sxs-lookup"><span data-stu-id="5304e-220">Such variables are called *local variables*.</span></span> <span data-ttu-id="5304e-221">Yerel bir değişken bildirimi bir tür adı, değişken adı ve muhtemelen bir başlangıç değeri belirtir.</span><span class="sxs-lookup"><span data-stu-id="5304e-221">A local variable declaration specifies a type name, a variable name, and possibly an initial value.</span></span> <span data-ttu-id="5304e-222">Aşağıdaki örnek, başlangıç değeri sıfır olan `i` yerel bir değişken ve ilk değeri olmayan bir yerel değişken `j` bildirir.</span><span class="sxs-lookup"><span data-stu-id="5304e-222">The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.</span></span>

[!code-csharp[Squares](~/samples/snippets/csharp/tour/classes-and-objects/Squares.cs#L3-L17)]

<span data-ttu-id="5304e-223">C#değeri alınabilmesi için önce bir yerel değişkenin *kesinlikle atanmasını* gerektirir.</span><span class="sxs-lookup"><span data-stu-id="5304e-223">C# requires a local variable to be *definitely assigned* before its value can be obtained.</span></span> <span data-ttu-id="5304e-224">Örneğin, önceki `i` bildiriminde bir başlangıç değeri yoksa, derleyici programın sonraki `i` kullanımları için bir hata bildirir çünkü `i` bu, programda bu noktalarda kesinlikle atanmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="5304e-224">For example, if the declaration of the previous `i` did not include an initial value, the compiler would report an error for the subsequent usages of `i` because `i` would not be definitely assigned at those points in the program.</span></span>

<span data-ttu-id="5304e-225">Bir yöntem, çağrı `return` yapana denetim döndürmek için deyimlerini kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="5304e-225">A method can use `return` statements to return control to its caller.</span></span> <span data-ttu-id="5304e-226">`void` Döndürülen`return` bir yöntemde deyimler bir ifade belirtemez.</span><span class="sxs-lookup"><span data-stu-id="5304e-226">In a method returning `void`, `return` statements cannot specify an expression.</span></span> <span data-ttu-id="5304e-227">Void olmayan bir yöntemde `return` deyim dönüş değerini hesaplayan bir ifade içermelidir.</span><span class="sxs-lookup"><span data-stu-id="5304e-227">In a method returning non-void, `return` statements must include an expression that computes the return value.</span></span>

### <a name="static-and-instance-methods"></a><span data-ttu-id="5304e-228">Statik ve örnek yöntemleri</span><span class="sxs-lookup"><span data-stu-id="5304e-228">Static and instance methods</span></span>

<span data-ttu-id="5304e-229">Statik değiştirici ile belirtilen bir yöntem *statik bir yöntemdir*.</span><span class="sxs-lookup"><span data-stu-id="5304e-229">A method declared with a static modifier is a *static method*.</span></span> <span data-ttu-id="5304e-230">Statik bir yöntem belirli bir örnek üzerinde çalışmaz ve yalnızca statik üyelere doğrudan erişebilir.</span><span class="sxs-lookup"><span data-stu-id="5304e-230">A static method does not operate on a specific instance and can only directly access static members.</span></span>

<span data-ttu-id="5304e-231">Statik değiştirici olmadan belirtilen bir yöntem bir *örnek yöntemidir*.</span><span class="sxs-lookup"><span data-stu-id="5304e-231">A method declared without a static modifier is an *instance method*.</span></span> <span data-ttu-id="5304e-232">Örnek yöntemi, belirli bir örnek üzerinde çalışır ve hem statik hem de örnek üyelerine erişebilir.</span><span class="sxs-lookup"><span data-stu-id="5304e-232">An instance method operates on a specific instance and can access both static and instance members.</span></span> <span data-ttu-id="5304e-233">Örnek yönteminin çağrıldığı örnek, olarak `this`açıkça erişilebilir.</span><span class="sxs-lookup"><span data-stu-id="5304e-233">The instance on which an instance method was invoked can be explicitly accessed as `this`.</span></span> <span data-ttu-id="5304e-234">Statik bir yöntemde başvurmak `this` için bir hatadır.</span><span class="sxs-lookup"><span data-stu-id="5304e-234">It is an error to refer to `this` in a static method.</span></span>

<span data-ttu-id="5304e-235">Aşağıdaki `Entity` sınıfta hem statik hem de örnek üyeleri vardır.</span><span class="sxs-lookup"><span data-stu-id="5304e-235">The following `Entity` class has both static and instance members.</span></span>

[!code-csharp[Entity](~/samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L16-L36)]

<span data-ttu-id="5304e-236">Her `Entity` örnek bir seri numarası içerir (ve burada görünmeyen bazı diğer bilgileri kabul etmez).</span><span class="sxs-lookup"><span data-stu-id="5304e-236">Each `Entity` instance contains a serial number (and presumably some other information that is not shown here).</span></span> <span data-ttu-id="5304e-237">`Entity` Oluşturucu (bir örnek yöntemi gibi) yeni örneği bir sonraki kullanılabilir seri numarasıyla başlatır.</span><span class="sxs-lookup"><span data-stu-id="5304e-237">The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number.</span></span> <span data-ttu-id="5304e-238">Oluşturucu bir örnek üyesi olduğundan, hem `serialNo` örnek alanına `nextSerialNo` hem de statik alana erişim izni verilir.</span><span class="sxs-lookup"><span data-stu-id="5304e-238">Because the constructor is an instance member, it is permitted to access both the `serialNo` instance field and the `nextSerialNo` static field.</span></span>

<span data-ttu-id="5304e-239">`GetNextSerialNo` Ve `serialNo` statik yöntemler statikalanaerişebilir,ancakörnekalanınadoğrudanerişmesiiçinbirhataolabilir.`nextSerialNo` `SetNextSerialNo`</span><span class="sxs-lookup"><span data-stu-id="5304e-239">The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `nextSerialNo` static field, but it would be an error for them to directly access the `serialNo` instance field.</span></span>

<span data-ttu-id="5304e-240">Aşağıdaki örnek, Entity sınıfının kullanımını gösterir.</span><span class="sxs-lookup"><span data-stu-id="5304e-240">The following example shows the use of the Entity class.</span></span>

[!code-csharp[EntityExample](~/samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L3-L15)]

<span data-ttu-id="5304e-241">Sınıfının örneklerinde `GetSerialNo` örnek `SetNextSerialNo` yöntemi `GetNextSerialNo` çağrıldığında, ve statik yöntemlerin sınıfında çağrılabileceğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="5304e-241">Note that the `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.</span></span>

### <a name="virtual-override-and-abstract-methods"></a><span data-ttu-id="5304e-242">Sanal, geçersiz kılma ve soyut yöntemler</span><span class="sxs-lookup"><span data-stu-id="5304e-242">Virtual, override, and abstract methods</span></span>

<span data-ttu-id="5304e-243">Bir örnek yöntemi bildirimi bir `virtual` değiştirici içerdiğinde, yöntemi bir *sanal yöntem*olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="5304e-243">When an instance method declaration includes a `virtual` modifier, the method is said to be a *virtual method*.</span></span> <span data-ttu-id="5304e-244">Bir sanal değiştirici yoksa, yöntem *sanal olmayan bir yöntem*olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="5304e-244">When no virtual modifier is present, the method is said to be a *nonvirtual method*.</span></span>

<span data-ttu-id="5304e-245">Bir sanal yöntem çağrıldığında, çağrının gerçekleştiği örneğin *çalışma zamanı türü* , çağrılacak gerçek Yöntem uygulamasını belirler.</span><span class="sxs-lookup"><span data-stu-id="5304e-245">When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke.</span></span> <span data-ttu-id="5304e-246">Sanal olmayan bir yöntem çağrısında, örneğin *derleme zamanı türü* belirleme faktörü olur.</span><span class="sxs-lookup"><span data-stu-id="5304e-246">In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.</span></span>

<span data-ttu-id="5304e-247">Bir sanal yöntem, türetilmiş bir sınıfta *geçersiz kılınabilir* .</span><span class="sxs-lookup"><span data-stu-id="5304e-247">A virtual method can be *overridden* in a derived class.</span></span> <span data-ttu-id="5304e-248">Bir örnek yöntemi bildirimi bir geçersiz kılma değiştiricisi içerdiğinde, yöntemi aynı imzaya sahip devralınmış bir sanal yöntemi geçersiz kılar.</span><span class="sxs-lookup"><span data-stu-id="5304e-248">When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</span></span> <span data-ttu-id="5304e-249">Sanal bir yöntem bildiriminde yeni bir yöntem tanıtıldığı halde, bir geçersiz kılma yöntemi bildirimi, bu yöntemin yeni bir uygulamasını sağlayarak, var olan bir devralınmış sanal yöntemi uzmanlık eder.</span><span class="sxs-lookup"><span data-stu-id="5304e-249">Whereas a virtual method declaration introduces a new method, an override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</span></span>

<span data-ttu-id="5304e-250">*Soyut bir yöntem* , uygulama içermeyen bir sanal yöntemdir.</span><span class="sxs-lookup"><span data-stu-id="5304e-250">An *abstract method* is a virtual method with no implementation.</span></span> <span data-ttu-id="5304e-251">Soyut bir yöntem soyut değiştiriciyle birlikte bildirilmiştir ve yalnızca soyut olarak da tanımlanmış bir sınıfta izin verilir.</span><span class="sxs-lookup"><span data-stu-id="5304e-251">An abstract method is declared with the abstract modifier and is permitted only in a class that is also declared abstract.</span></span> <span data-ttu-id="5304e-252">Soyut olmayan her türetilmiş sınıfta bir soyut yöntem geçersiz kılınmalıdır.</span><span class="sxs-lookup"><span data-stu-id="5304e-252">An abstract method must be overridden in every non-abstract derived class.</span></span>

<span data-ttu-id="5304e-253">Aşağıdaki örnek, bir ifade ağaç düğümünü temsil `Expression`eden bir soyut sınıfı ve sabitler, değişken için ifade ağacı düğümleri uygulayan `Constant`üç `VariableReference`türetilmiş sınıfı `Operation`,, ve ve ' ı tanımlar. başvurular ve aritmetik işlemler.</span><span class="sxs-lookup"><span data-stu-id="5304e-253">The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations.</span></span> <span data-ttu-id="5304e-254">(Bu şuna benzerdir, ancak ifade ağacı türleriyle karıştırılmamalıdır).</span><span class="sxs-lookup"><span data-stu-id="5304e-254">(This is similar to, but not to be confused with the expression tree types).</span></span>

[!code-csharp[ExpressionClass](~/samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L3-L61)]

<span data-ttu-id="5304e-255">Önceki dört sınıf aritmetik ifadeleri modellemek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="5304e-255">The previous four classes can be used to model arithmetic expressions.</span></span> <span data-ttu-id="5304e-256">Örneğin, bu sınıfların örneklerini kullanarak, ifadesi `x + 3` aşağıdaki gibi gösterilebilir.</span><span class="sxs-lookup"><span data-stu-id="5304e-256">For example, using instances of these classes, the expression `x + 3` can be represented as follows.</span></span>

[!code-csharp[ExpressionExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L40-L43)]

<span data-ttu-id="5304e-257">`double` Bir `Evaluate` Örneğinyöntemi,verilenifadeyideğerlendirmekvebirdeğerüretmekiçinçağrılır.`Expression`</span><span class="sxs-lookup"><span data-stu-id="5304e-257">The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value.</span></span> <span data-ttu-id="5304e-258">Yöntemi, değişken adlarını `Dictionary` (girdilerin anahtarları olarak) ve değerlerini (girişlerin değerleri olarak) içeren bir bağımsız değişken alır.</span><span class="sxs-lookup"><span data-stu-id="5304e-258">The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries).</span></span> <span data-ttu-id="5304e-259">Soyut `Evaluate` bir yöntem olduğundan, öğesinden `Expression` türetilen soyut olmayan sınıflar geçersiz kılınmalıdır `Evaluate`.</span><span class="sxs-lookup"><span data-stu-id="5304e-259">Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.</span></span>

<span data-ttu-id="5304e-260">' Nin uygulanması, `Evaluate` yalnızca saklı sabiti döndürür. `Constant`</span><span class="sxs-lookup"><span data-stu-id="5304e-260">A `Constant`'s implementation of `Evaluate` simply returns the stored constant.</span></span> <span data-ttu-id="5304e-261">A `VariableReference`uygulamasının, sözlükte değişken adını arar ve elde edilen değeri döndürür.</span><span class="sxs-lookup"><span data-stu-id="5304e-261">A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value.</span></span> <span data-ttu-id="5304e-262">Bir `Operation`uygulama ilk olarak sol ve sağ işlenenleri değerlendirir ( `Evaluate` yöntemlerini özyinelemeli olarak çağırarak) ve ardından verilen aritmetik işlemi gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="5304e-262">An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.</span></span>

<span data-ttu-id="5304e-263">Aşağıdaki program, `Expression` `x` ve `x * (y + 2)` farklı`y`değerleri için ifadeyi değerlendirmek için sınıflarını kullanır.</span><span class="sxs-lookup"><span data-stu-id="5304e-263">The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.</span></span>

[!code-csharp[ExpressionUsage](~/samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L66-L89)]

### <a name="method-overloading"></a><span data-ttu-id="5304e-264">Yöntem aşırı yüklemesi</span><span class="sxs-lookup"><span data-stu-id="5304e-264">Method overloading</span></span>

<span data-ttu-id="5304e-265">Yöntem *aşırı yüklemesi* , aynı sınıftaki birden çok metodun benzersiz imzalara sahip oldukları sürece aynı ada sahip olmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="5304e-265">Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures.</span></span> <span data-ttu-id="5304e-266">Aşırı yüklenmiş bir yöntemin çağrılması derlenirken, derleyici çağrılacak özel yöntemi belirlemekte *aşırı yükleme çözümü* kullanır.</span><span class="sxs-lookup"><span data-stu-id="5304e-266">When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke.</span></span> <span data-ttu-id="5304e-267">Aşırı yükleme çözümlemesi, bağımsız değişkenlerle en iyi eşleşen bir yöntemi bulur veya tek bir en iyi eşleşme bulunamazsa hata bildiriyor.</span><span class="sxs-lookup"><span data-stu-id="5304e-267">Overload resolution finds the one method that best matches the arguments or reports an error if no single best match can be found.</span></span> <span data-ttu-id="5304e-268">Aşağıdaki örnekte, etkin olan aşırı yükleme çözümü gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="5304e-268">The following example shows overload resolution in effect.</span></span> <span data-ttu-id="5304e-269">`UsageExample` Yöntemi içindeki her çağrının yorumu aslında hangi yöntemin çağrılacağını gösterir.</span><span class="sxs-lookup"><span data-stu-id="5304e-269">The comment for each invocation in the `UsageExample` method shows which method is actually invoked.</span></span>

[!code-csharp[OverloadUsage](~/samples/snippets/csharp/tour/classes-and-objects/Overloading.cs#L3-L41)]

<span data-ttu-id="5304e-270">Örnekte gösterildiği gibi belirli bir yöntem her zaman bağımsız değişkenleri tam parametre türlerine açıkça atayarak ve/veya açıkça tür bağımsız değişkenleri sunarak seçilebilir.</span><span class="sxs-lookup"><span data-stu-id="5304e-270">As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and/or explicitly supplying type arguments.</span></span>

## <a name="other-function-members"></a><span data-ttu-id="5304e-271">Diğer işlev üyeleri</span><span class="sxs-lookup"><span data-stu-id="5304e-271">Other function members</span></span>

<span data-ttu-id="5304e-272">Yürütülebilir kod içeren Üyeler topluca bir sınıfın *işlev üyeleri* olarak bilinir.</span><span class="sxs-lookup"><span data-stu-id="5304e-272">Members that contain executable code are collectively known as the *function members* of a class.</span></span> <span data-ttu-id="5304e-273">Yukarıdaki bölümde, işlev üyelerinin birincil türü olan yöntemler açıklanmıştır.</span><span class="sxs-lookup"><span data-stu-id="5304e-273">The preceding section describes methods, which are the primary kind of function members.</span></span> <span data-ttu-id="5304e-274">Bu bölümde, tarafından C#desteklenen diğer işlev üyesi türleri açıklanmaktadır: oluşturucular, özellikler, Dizin oluşturucular, olaylar, işleçler ve sonlandırıcılar.</span><span class="sxs-lookup"><span data-stu-id="5304e-274">This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</span></span>

<span data-ttu-id="5304e-275">Aşağıda, bir nesne growable listesini uygulayan `MyList<T>`adlı bir genel sınıf gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="5304e-275">The following shows a generic class called `MyList<T>`, which implements a growable list of objects.</span></span> <span data-ttu-id="5304e-276">Sınıfı, en yaygın işlev üyesi türlerine birkaç örnek içerir.</span><span class="sxs-lookup"><span data-stu-id="5304e-276">The class contains several examples of the most common kinds of function members.</span></span>

> [!NOTE]
> <span data-ttu-id="5304e-277">Bu örnek, .net `MyList` standardı <xref:System.Collections.Generic.List%601?displayProperty=nameWithType>ile aynı olmayan bir sınıf oluşturur.</span><span class="sxs-lookup"><span data-stu-id="5304e-277">This example creates a `MyList` class, which is not the same as the .NET standard <xref:System.Collections.Generic.List%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5304e-278">Bu, bu tur için gereken kavramları gösterir, ancak bu sınıfın yerini almaz.</span><span class="sxs-lookup"><span data-stu-id="5304e-278">It does illustrate the concepts needed for this tour, but is not a replacement for that class.</span></span>

[!code-csharp[ListClass](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L4-L89)]

### <a name="constructors"></a><span data-ttu-id="5304e-279">Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="5304e-279">Constructors</span></span>

<span data-ttu-id="5304e-280">C#hem örnek hem de statik oluşturucuları destekler.</span><span class="sxs-lookup"><span data-stu-id="5304e-280">C# supports both instance and static constructors.</span></span> <span data-ttu-id="5304e-281">*Örnek Oluşturucu* , bir sınıfın örneğini başlatmak için gereken eylemleri uygulayan bir üyedir.</span><span class="sxs-lookup"><span data-stu-id="5304e-281">An *instance constructor* is a member that implements the actions required to initialize an instance of a class.</span></span> <span data-ttu-id="5304e-282">*Statik Oluşturucu* , ilk yüklendiği zaman bir sınıfın kendisini başlatmak için gereken eylemleri uygulayan bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="5304e-282">A *static constructor* is a member that implements the actions required to initialize a class itself when it is first loaded.</span></span>

<span data-ttu-id="5304e-283">Bir Oluşturucu, dönüş türü olmayan bir yöntem ve kapsayan sınıfla aynı adı ile birlikte bildirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="5304e-283">A constructor is declared like a method with no return type and the same name as the containing class.</span></span> <span data-ttu-id="5304e-284">Bir Oluşturucu bildirimi statik değiştirici içeriyorsa, statik bir Oluşturucu bildirir.</span><span class="sxs-lookup"><span data-stu-id="5304e-284">If a constructor declaration includes a static modifier, it declares a static constructor.</span></span> <span data-ttu-id="5304e-285">Aksi takdirde, bir örnek Oluşturucu bildirir.</span><span class="sxs-lookup"><span data-stu-id="5304e-285">Otherwise, it declares an instance constructor.</span></span>

<span data-ttu-id="5304e-286">Örnek oluşturucular aşırı yüklenebilir ve isteğe bağlı parametrelere sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="5304e-286">Instance constructors can be overloaded and can have optional parameters.</span></span> <span data-ttu-id="5304e-287">Örneğin, `MyList<T>` sınıfı tek bir isteğe bağlı `int` parametre ile bir örnek Oluşturucu bildirir.</span><span class="sxs-lookup"><span data-stu-id="5304e-287">For example, the `MyList<T>` class declares one instance constructor with a single optional `int` parameter.</span></span> <span data-ttu-id="5304e-288">Örnek oluşturucular `new` işleci kullanılarak çağrılır.</span><span class="sxs-lookup"><span data-stu-id="5304e-288">Instance constructors are invoked using the `new` operator.</span></span> <span data-ttu-id="5304e-289">Aşağıdaki deyimler, ve isteğe `MyList<string>` bağlı bağımsız değişken olmadan `MyList` sınıfının oluşturucusunu kullanarak iki örnek ayırır.</span><span class="sxs-lookup"><span data-stu-id="5304e-289">The following statements allocate two `MyList<string>` instances using the constructor of the `MyList` class with and without the optional argument.</span></span>

[!code-csharp[ListExample1](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L95-L96)]

<span data-ttu-id="5304e-290">Diğer üyelerin aksine, örnek oluşturucular devralınmaz ve bir sınıfın sınıfta tanımlananlardan farklı örnek oluşturucuları yoktur.</span><span class="sxs-lookup"><span data-stu-id="5304e-290">Unlike other members, instance constructors are not inherited, and a class has no instance constructors other than those actually declared in the class.</span></span> <span data-ttu-id="5304e-291">Bir sınıf için örnek Oluşturucu sağlanmazsa, parametresi olmayan boş bir değer otomatik olarak sağlanır.</span><span class="sxs-lookup"><span data-stu-id="5304e-291">If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</span></span>

### <a name="properties"></a><span data-ttu-id="5304e-292">Özellikler</span><span class="sxs-lookup"><span data-stu-id="5304e-292">Properties</span></span>

<span data-ttu-id="5304e-293">*Özellikler* , alanlar için doğal bir uzantıdır.</span><span class="sxs-lookup"><span data-stu-id="5304e-293">*Properties* are a natural extension of fields.</span></span> <span data-ttu-id="5304e-294">Her ikisi de ilişkili türlerin bulunduğu isimlerdir ve alanlara ve özelliklere erişim için sözdizimi aynıdır.</span><span class="sxs-lookup"><span data-stu-id="5304e-294">Both are named members with associated types, and the syntax for accessing fields and properties is the same.</span></span> <span data-ttu-id="5304e-295">Ancak, alanların aksine, Özellikler depolama konumlarını göstermiyor.</span><span class="sxs-lookup"><span data-stu-id="5304e-295">However, unlike fields, properties do not denote storage locations.</span></span> <span data-ttu-id="5304e-296">Bunun yerine, özellikler, değerleri okunmak veya yazıldığında yürütülecek deyimleri belirten *erişimcileri* vardır.</span><span class="sxs-lookup"><span data-stu-id="5304e-296">Instead, properties have *accessors* that specify the statements to be executed when their values are read or written.</span></span>

<span data-ttu-id="5304e-297">Bir özellik, bildirim bir get erişimcisi ve/veya sınırlayıcılar `{` arasında yazılmış bir set erişimcisi ile sona erdiğinde ve `}` noktalı virgül ile sona ermek yerine bir alan gibi tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="5304e-297">A property is declared like a field, except that the declaration ends with a get accessor and/or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.</span></span> <span data-ttu-id="5304e-298">Hem get erişimcisine hem de bir set erişimcisine sahip olan bir özellik *okuma-yazma özelliğidir*, yalnızca bir get erişimcisine sahip olan bir özellik *salt okunurdur*ve yalnızca bir set erişimcisi olan bir özellik yalnızca bir salt *yazılır özelliktir*.</span><span class="sxs-lookup"><span data-stu-id="5304e-298">A property that has both a get accessor and a set accessor is a *read-write property*, a property that has only a get accessor is a *read-only property*, and a property that has only a set accessor is a *write-only property*.</span></span>

<span data-ttu-id="5304e-299">Get erişimcisi, özellik türünün dönüş değeri olan parametresiz bir yönteme karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="5304e-299">A get accessor corresponds to a parameterless method with a return value of the property type.</span></span> <span data-ttu-id="5304e-300">Atama hedefi haricinde, bir ifadede bir özelliğe başvurulduğunda, özelliğin değerini hesaplamak için özelliğin get erişimcisi çağrılır.</span><span class="sxs-lookup"><span data-stu-id="5304e-300">Except as the target of an assignment, when a property is referenced in an expression, the get accessor of the property is invoked to compute the value of the property.</span></span>

<span data-ttu-id="5304e-301">Bir set erişimcisi, value adlı tek parametreli ve dönüş türü olmayan bir yönteme karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="5304e-301">A set accessor corresponds to a method with a single parameter named value and no return type.</span></span> <span data-ttu-id="5304e-302">Bir atamaya bir atama hedefi olarak veya + + veya--, işleneni olarak başvurulduğunda, yeni değer sağlayan bir bağımsız değişkenle çağrılır.</span><span class="sxs-lookup"><span data-stu-id="5304e-302">When a property is referenced as the target of an assignment or as the operand of ++ or --, the set accessor is invoked with an argument that provides the new value.</span></span>

<span data-ttu-id="5304e-303">Sınıfı iki özellik bildirir `Capacity`ve sırasıyla salt okunurdur ve okuma-yazma olur. `Count` `MyList<T>`</span><span class="sxs-lookup"><span data-stu-id="5304e-303">The `MyList<T>` class declares two properties, `Count` and `Capacity`, which are read-only and read-write, respectively.</span></span> <span data-ttu-id="5304e-304">Aşağıda bu özelliklerin kullanılmasına bir örnek verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="5304e-304">The following is an example of use of these properties:</span></span>

[!code-csharp[ListExample2](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L101-L104)]

<span data-ttu-id="5304e-305">Alanlar ve yöntemlere benzer şekilde hem C# örnek özelliklerini hem de statik özellikleri destekler.</span><span class="sxs-lookup"><span data-stu-id="5304e-305">Similar to fields and methods, C# supports both instance properties and static properties.</span></span> <span data-ttu-id="5304e-306">Statik özellikler statik değiştirici ile tanımlanır ve örnek özellikleri bu olmadan tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="5304e-306">Static properties are declared with the static modifier, and instance properties are declared without it.</span></span>

<span data-ttu-id="5304e-307">Bir özelliğin erişimcisi sanal olabilir.</span><span class="sxs-lookup"><span data-stu-id="5304e-307">The accessor(s) of a property can be virtual.</span></span> <span data-ttu-id="5304e-308">Bir özellik bildirimi `virtual`, `abstract`, veya `override` değiştiricisini içerdiğinde, özelliğin erişimcilerle geçerli olur.</span><span class="sxs-lookup"><span data-stu-id="5304e-308">When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.</span></span>

### <a name="indexers"></a><span data-ttu-id="5304e-309">Dizin Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="5304e-309">Indexers</span></span>

<span data-ttu-id="5304e-310">*Dizin Oluşturucu* , nesnelerin diziyle aynı şekilde dizinlenmesini sağlayan bir üyedir.</span><span class="sxs-lookup"><span data-stu-id="5304e-310">An *indexer* is a member that enables objects to be indexed in the same way as an array.</span></span> <span data-ttu-id="5304e-311">Bir Dizin Oluşturucu, üyenin `this` adının ardından sınırlayıcılar `[` ve `]`arasında yazılmış bir parametre listesi gelmesi dışında bir özellik gibi bildirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="5304e-311">An indexer is declared like a property except that the name of the member is `this` followed by a parameter list written between the delimiters `[` and `]`.</span></span> <span data-ttu-id="5304e-312">Parametreler, dizin oluşturucunun erişimcisinde kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="5304e-312">The parameters are available in the accessor(s) of the indexer.</span></span> <span data-ttu-id="5304e-313">Özelliklere benzer şekilde, Dizin oluşturucular okunabilir-yazılır, salt okunurdur ve salt yazılır olabilir ve bir dizin oluşturucunun erişimcisi sanal olabilir.</span><span class="sxs-lookup"><span data-stu-id="5304e-313">Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</span></span>

<span data-ttu-id="5304e-314">Sınıfı `MyList<T>` , bir `int` parametresi alan tek bir okuma-yazma Dizin Oluşturucu bildirir.</span><span class="sxs-lookup"><span data-stu-id="5304e-314">The `MyList<T>` class declares a single read-write indexer that takes an `int` parameter.</span></span> <span data-ttu-id="5304e-315">Dizin Oluşturucu, `MyList<T>` `int` örneklerin değerleriyle dizin oluşturmanızı mümkün kılar.</span><span class="sxs-lookup"><span data-stu-id="5304e-315">The indexer makes it possible to index `MyList<T>` instances with `int` values.</span></span> <span data-ttu-id="5304e-316">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="5304e-316">For example:</span></span>

[!code-csharp[ListExample3](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L109-L117)]

<span data-ttu-id="5304e-317">Dizin oluşturucular aşırı yüklenebilir, yani parametrelerinin sayısı veya türleri farklı olduğu sürece bir sınıfın birden çok dizin kümesini bildirebileceği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="5304e-317">Indexers can be overloaded, meaning that a class can declare multiple indexers as long as the number or types of their parameters differ.</span></span>

### <a name="events"></a><span data-ttu-id="5304e-318">Olaylar</span><span class="sxs-lookup"><span data-stu-id="5304e-318">Events</span></span>

<span data-ttu-id="5304e-319">Bir *olay* , bir sınıf veya nesnenin bildirimler sağlamasını sağlayan bir üyedir.</span><span class="sxs-lookup"><span data-stu-id="5304e-319">An *event* is a member that enables a class or object to provide notifications.</span></span> <span data-ttu-id="5304e-320">Bir olay, bildirim bir event anahtar sözcüğü içermesi ve türün bir temsilci türü olması dışında, bir alan gibi bildirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="5304e-320">An event is declared like a field except that the declaration includes an event keyword and the type must be a delegate type.</span></span>

<span data-ttu-id="5304e-321">Olay üyesini bildiren bir sınıf içinde, olay bir temsilci türünün alanı gibi davranır (olay soyut değildir ve erişimcileri bildirmez).</span><span class="sxs-lookup"><span data-stu-id="5304e-321">Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event is not abstract and does not declare accessors).</span></span> <span data-ttu-id="5304e-322">Bu alan, olaya eklenmiş olan olay işleyicilerini temsil eden bir temsilciye bir başvuru depolar.</span><span class="sxs-lookup"><span data-stu-id="5304e-322">The field stores a reference to a delegate that represents the event handlers that have been added to the event.</span></span> <span data-ttu-id="5304e-323">Hiçbir olay işleyicisi yoksa, alanı olur `null`.</span><span class="sxs-lookup"><span data-stu-id="5304e-323">If no event handlers are present, the field is `null`.</span></span>

<span data-ttu-id="5304e-324">Sınıfı, adlı `Changed`tek bir olay üyesini bildirir ve bu, listeye yeni bir öğe eklendiğini gösterir. `MyList<T>`</span><span class="sxs-lookup"><span data-stu-id="5304e-324">The `MyList<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list.</span></span> <span data-ttu-id="5304e-325">Değiştirilen olay `OnChanged` sanal yöntemi tarafından tetiklenir ve bu, önce `null` olayın (hiçbir işleyicinin mevcut olmadığı anlamına gelir) olup olmadığını denetler.</span><span class="sxs-lookup"><span data-stu-id="5304e-325">The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present).</span></span> <span data-ttu-id="5304e-326">Bir olayı oluşturma kavramı, olayın gösterdiği temsilciyi çağırmak için tam olarak eşdeğerdir. bu nedenle, olayları yükseltmek için özel dil yapıları yoktur.</span><span class="sxs-lookup"><span data-stu-id="5304e-326">The notion of raising an event is precisely equivalent to invoking the delegate represented by the event—thus, there are no special language constructs for raising events.</span></span>

<span data-ttu-id="5304e-327">İstemciler *olay işleyicileri*aracılığıyla olaylara tepki verir.</span><span class="sxs-lookup"><span data-stu-id="5304e-327">Clients react to events through *event handlers*.</span></span> <span data-ttu-id="5304e-328">Olay işleyicileri `+=` işleci kullanılarak eklenir ve `-=` işleci kullanılarak kaldırılır.</span><span class="sxs-lookup"><span data-stu-id="5304e-328">Event handlers are attached using the `+=` operator and removed using the `-=` operator.</span></span> <span data-ttu-id="5304e-329">Aşağıdaki örnek, olayına bir `Changed` `MyList<string>`olay işleyicisi ekler.</span><span class="sxs-lookup"><span data-stu-id="5304e-329">The following example attaches an event handler to the `Changed` event of a `MyList<string>`.</span></span>

[!code-csharp[EventExample](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L132-L148)]

<span data-ttu-id="5304e-330">Bir olayın temeldeki depolamanın denetiminin istendiği Gelişmiş senaryolarda, bir olay bildirimi açıkça bir özelliğin `add` `set` erişenine benzer bir şekilde sağlayabilir ve `remove` erişimciler sağlar.</span><span class="sxs-lookup"><span data-stu-id="5304e-330">For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are somewhat similar to the `set` accessor of a property.</span></span>

### <a name="operators"></a><span data-ttu-id="5304e-331">İşleçler</span><span class="sxs-lookup"><span data-stu-id="5304e-331">Operators</span></span>

<span data-ttu-id="5304e-332">*İşleci* , bir sınıfın örneklerine belirli bir ifade işlecini uygulamanın anlamını tanımlayan bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="5304e-332">An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class.</span></span> <span data-ttu-id="5304e-333">Üç tür işleç tanımlanabilir: Birli İşleçler, ikili işleçler ve dönüştürme işleçleri.</span><span class="sxs-lookup"><span data-stu-id="5304e-333">Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</span></span> <span data-ttu-id="5304e-334">Tüm işleçler ve `public` `static`olarak bildirilmelidir.</span><span class="sxs-lookup"><span data-stu-id="5304e-334">All operators must be declared as `public` and `static`.</span></span>

<span data-ttu-id="5304e-335">Sınıfı iki `MyList` işleç `operator ==` bildirirvebunedenlebuişleçleriörneklereuygulayandeyimlereyenianlamıverir.`operator !=` `MyList<T>`</span><span class="sxs-lookup"><span data-stu-id="5304e-335">The `MyList<T>` class declares two operators, `operator ==` and `operator !=`, and thus gives new meaning to expressions that apply those operators to `MyList` instances.</span></span> <span data-ttu-id="5304e-336">Özellikle, işleçler, içerilen nesnelerin her birini `MyList<T>` , eşittir yöntemlerini kullanarak karşılaştıran iki örnek için eşitlik tanımlar.</span><span class="sxs-lookup"><span data-stu-id="5304e-336">Specifically, the operators define equality of two `MyList<T>` instances as comparing each of the contained objects using their Equals methods.</span></span> <span data-ttu-id="5304e-337">Aşağıdaki örnek, iki `==` `MyList<int>` örneği karşılaştırmak için işlecini kullanır.</span><span class="sxs-lookup"><span data-stu-id="5304e-337">The following example uses the `==` operator to compare two `MyList<int>` instances.</span></span>

[!code-csharp[OperatorExample](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L121-L129)]

<span data-ttu-id="5304e-338">Bu iki `Console.WriteLine` liste `True` aynı sırada aynı değerleri taşıyan aynı sayıda nesne içerdiğinden ilk çıktılar.</span><span class="sxs-lookup"><span data-stu-id="5304e-338">The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order.</span></span> <span data-ttu-id="5304e-339">`MyList<T>` Tanımlı değil,`Console.WriteLine` ilkiçıktıyı`False` içeriyor ve`b` farklı örneklere`MyList<int>` başvuracaktır. `a` `operator ==`</span><span class="sxs-lookup"><span data-stu-id="5304e-339">Had `MyList<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `MyList<int>` instances.</span></span>

### <a name="finalizers"></a><span data-ttu-id="5304e-340">Sonlandırıcılar</span><span class="sxs-lookup"><span data-stu-id="5304e-340">Finalizers</span></span>

<span data-ttu-id="5304e-341">*Sonlandırıcı* , bir sınıfın örneğini tamamlamak için gereken eylemleri uygulayan bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="5304e-341">A *finalizer* is a member that implements the actions required to finalize an instance of a class.</span></span> <span data-ttu-id="5304e-342">Sonlandırıcılar parametrelere sahip olamaz, erişilebilirlik değiştiricilerine sahip olamaz ve açıkça çağrılamaz.</span><span class="sxs-lookup"><span data-stu-id="5304e-342">Finalizers cannot have parameters, they cannot have accessibility modifiers, and they cannot be invoked explicitly.</span></span> <span data-ttu-id="5304e-343">Örnek için Sonlandırıcı çöp toplama sırasında otomatik olarak çağrılır.</span><span class="sxs-lookup"><span data-stu-id="5304e-343">The finalizer for an instance is invoked automatically during garbage collection.</span></span>

<span data-ttu-id="5304e-344">Çöp toplayıcısına, nesnelerin toplanması ve Sonlandırıcıların ne zaman toplanacağına karar verirken geniş bir enlem vardır.</span><span class="sxs-lookup"><span data-stu-id="5304e-344">The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</span></span> <span data-ttu-id="5304e-345">Özellikle, Sonlandırıcı etkinleştirmeleri zamanlaması belirleyici değildir ve herhangi bir iş parçacığında sonlandırıcılar çalıştırılabilir.</span><span class="sxs-lookup"><span data-stu-id="5304e-345">Specifically, the timing of finalizer invocations is not deterministic, and finalizers may be executed on any thread.</span></span> <span data-ttu-id="5304e-346">Bu ve diğer nedenlerden dolayı sınıfların yalnızca başka hiçbir çözüm uygulanabilir olmadığında sonlandırıcılar uygulaması gerekir.</span><span class="sxs-lookup"><span data-stu-id="5304e-346">For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</span></span>

<span data-ttu-id="5304e-347">İfade `using` , nesne yok etme için daha iyi bir yaklaşım sağlar.</span><span class="sxs-lookup"><span data-stu-id="5304e-347">The `using` statement provides a better approach to object destruction.</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="5304e-348">[Önceki](statements.md)İleri
> [](structs.md)</span><span class="sxs-lookup"><span data-stu-id="5304e-348">[Previous](statements.md)
[Next](structs.md)</span></span>
