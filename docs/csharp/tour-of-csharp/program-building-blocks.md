---
title: C# programlarının yapı taşları "
description: C# üyeleri, ifadeler ve deyimler hakkında bilgi edinin. Türler yazdığınız üyeleri içerir. Bu Üyeler deyimlerden ve ifadelerden oluşturulur.
ms.date: 08/06/2020
ms.openlocfilehash: 3bdc6a4da6ae76148c7d1d5cb8ccb65d91fda61a
ms.sourcegitcommit: ae2e8a61a93c5cf3f0035c59e6b064fa2f812d14
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 09/02/2020
ms.locfileid: "89358823"
---
# <a name="program-building-blocks"></a><span data-ttu-id="7edb9-105">Program yapı taşları</span><span class="sxs-lookup"><span data-stu-id="7edb9-105">Program building blocks</span></span>

<span data-ttu-id="7edb9-106">Önceki makalede açıklanan türler, bu derleme blokları kullanılarak oluşturulmuştur: [***Üyeler***](../programming-guide/classes-and-structs/members.md), [ ***ifadeler***ve ***deyimler***](../programming-guide/statements-expressions-operators/index.md).</span><span class="sxs-lookup"><span data-stu-id="7edb9-106">The types described in the previous article are built using these building blocks: [***members***](../programming-guide/classes-and-structs/members.md), [***expressions***, and ***statements***](../programming-guide/statements-expressions-operators/index.md).</span></span>

## <a name="members"></a><span data-ttu-id="7edb9-107">Üyeler</span><span class="sxs-lookup"><span data-stu-id="7edb9-107">Members</span></span>

<span data-ttu-id="7edb9-108">A üyeleri `class` ***statik Üyeler*** veya ***örnek üyeleridir***.</span><span class="sxs-lookup"><span data-stu-id="7edb9-108">The members of a `class` are either ***static members*** or ***instance members***.</span></span> <span data-ttu-id="7edb9-109">Statik Üyeler sınıflara aittir ve örnek üyeleri nesnelere aittir (sınıf örnekleri).</span><span class="sxs-lookup"><span data-stu-id="7edb9-109">Static members belong to classes, and instance members belong to objects (instances of classes).</span></span>

<span data-ttu-id="7edb9-110">Aşağıdaki liste, bir sınıfın içerebileceği üye türlerine genel bir bakış sağlar.</span><span class="sxs-lookup"><span data-stu-id="7edb9-110">The following list provides an overview of the kinds of members a class can contain.</span></span>

- <span data-ttu-id="7edb9-111">**Sabitler**: sınıfla ilişkili sabit değerler</span><span class="sxs-lookup"><span data-stu-id="7edb9-111">**Constants**: Constant values associated with the class</span></span>
- <span data-ttu-id="7edb9-112">**Alanlar**: sınıfıyla ilişkili değişkenler</span><span class="sxs-lookup"><span data-stu-id="7edb9-112">**Fields**:  Variables that are associated of the class</span></span>
- <span data-ttu-id="7edb9-113">**Yöntemler**: sınıfı tarafından gerçekleştirilebilecek eylemler</span><span class="sxs-lookup"><span data-stu-id="7edb9-113">**Methods**:  Actions that can be performed by the class</span></span>
- <span data-ttu-id="7edb9-114">**Özellikler**: sınıfının adlandırılmış özelliklerini okuma ve yazma ile ilişkili eylemler</span><span class="sxs-lookup"><span data-stu-id="7edb9-114">**Properties**: Actions associated with reading and writing named properties of the class</span></span>
- <span data-ttu-id="7edb9-115">**Dizin oluşturucular**: bir dizi gibi sınıfın dizin oluşturma örnekleri ile ilişkili eylemler</span><span class="sxs-lookup"><span data-stu-id="7edb9-115">**Indexers**: Actions associated with indexing instances of the class like an array</span></span>
- <span data-ttu-id="7edb9-116">**Olaylar**: sınıfı tarafından oluşturulabilecek bildirimler</span><span class="sxs-lookup"><span data-stu-id="7edb9-116">**Events**: Notifications that can be generated by the class</span></span>
- <span data-ttu-id="7edb9-117">**İşleçler**: sınıf tarafından desteklenen dönüşümler ve ifade işleçleri</span><span class="sxs-lookup"><span data-stu-id="7edb9-117">**Operators**: Conversions and expression operators supported by the class</span></span>
- <span data-ttu-id="7edb9-118">**Oluşturucular**: sınıf veya sınıf örneklerinin başlatılması için gereken eylemler</span><span class="sxs-lookup"><span data-stu-id="7edb9-118">**Constructors**: Actions required to initialize instances of the class or the class itself</span></span>
- <span data-ttu-id="7edb9-119">**Sonlandırıcılar**: sınıf örneklerinin kalıcı olarak atılmadan önce gerçekleştirilen eylemler</span><span class="sxs-lookup"><span data-stu-id="7edb9-119">**Finalizers**: Actions performed before instances of the class are permanently discarded</span></span>
- <span data-ttu-id="7edb9-120">**Türler**: sınıf tarafından belirtilen iç içe türler</span><span class="sxs-lookup"><span data-stu-id="7edb9-120">**Types**: Nested types declared by the class</span></span>

## <a name="accessibility"></a><span data-ttu-id="7edb9-121">Erişilebilirlik</span><span class="sxs-lookup"><span data-stu-id="7edb9-121">Accessibility</span></span>

<span data-ttu-id="7edb9-122">Bir sınıfın her üyesinin ilişkili bir erişilebilirliği vardır ve bu, üyeye erişebilen program metni bölgelerini denetler.</span><span class="sxs-lookup"><span data-stu-id="7edb9-122">Each member of a class has an associated accessibility, which controls the regions of program text that can access the member.</span></span> <span data-ttu-id="7edb9-123">Olası altı erişilebilirlik biçimi vardır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-123">There are six possible forms of accessibility.</span></span> <span data-ttu-id="7edb9-124">Erişim değiştiriciler aşağıda özetlenmiştir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-124">The access modifiers are summarized below.</span></span>

- <span data-ttu-id="7edb9-125">`public`: Erişim sınırlı değil.</span><span class="sxs-lookup"><span data-stu-id="7edb9-125">`public`: Access isn't limited.</span></span>
- <span data-ttu-id="7edb9-126">`private`: Erişim bu sınıfla sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-126">`private`: Access is limited to this class.</span></span>
- <span data-ttu-id="7edb9-127">`protected`: Erişim bu sınıftan türetilmiş bu sınıf veya sınıflarla sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-127">`protected`: Access is limited to this class or classes derived from this class.</span></span>
- <span data-ttu-id="7edb9-128">`internal`: Erişim geçerli derleme (veya) ile sınırlıdır `.exe` `.dll` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-128">`internal`: Access is limited to the current assembly (`.exe` or `.dll`).</span></span>
- <span data-ttu-id="7edb9-129">`protected internal`: Erişim bu sınıfla, bu sınıftan türetilmiş sınıflarla veya aynı derleme içindeki sınıflardan sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-129">`protected internal`: Access is limited to this class, classes derived from this class, or classes within the same assembly.</span></span>
- <span data-ttu-id="7edb9-130">`private protected`: Erişim bu sınıf veya aynı derleme içindeki bu türden türetilmiş sınıflarla sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-130">`private protected`: Access is limited to this class or classes derived from this type within the same assembly.</span></span>

## <a name="fields"></a><span data-ttu-id="7edb9-131">Alanlar</span><span class="sxs-lookup"><span data-stu-id="7edb9-131">Fields</span></span>

<span data-ttu-id="7edb9-132">*Alan* , bir sınıf ile veya bir sınıf örneğiyle ilişkili bir değişkendir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-132">A *field* is a variable that is associated with a class or with an instance of a class.</span></span>

<span data-ttu-id="7edb9-133">Statik değiştiriciyle belirtilen bir alan statik bir alan tanımlar.</span><span class="sxs-lookup"><span data-stu-id="7edb9-133">A field declared with the static modifier defines a static field.</span></span> <span data-ttu-id="7edb9-134">Statik alan tam olarak bir depolama konumunu tanımlar.</span><span class="sxs-lookup"><span data-stu-id="7edb9-134">A static field identifies exactly one storage location.</span></span> <span data-ttu-id="7edb9-135">Bir sınıfın kaç örneğinin oluşturulduğuna bakılmaksızın, bir statik alanın yalnızca bir kopyası vardır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-135">No matter how many instances of a class are created, there's only ever one copy of a static field.</span></span>

<span data-ttu-id="7edb9-136">Statik değiştirici olmadan belirtilen bir alan bir örnek alanını tanımlar.</span><span class="sxs-lookup"><span data-stu-id="7edb9-136">A field declared without the static modifier defines an instance field.</span></span> <span data-ttu-id="7edb9-137">Bir sınıfın her örneği, bu sınıfın tüm örnek alanlarının ayrı bir kopyasını içerir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-137">Every instance of a class contains a separate copy of all the instance fields of that class.</span></span>

<span data-ttu-id="7edb9-138">Aşağıdaki örnekte, sınıfının her örneği `Color` ,, ve örnek alanlarının ayrı bir kopyasına sahiptir `r` `g` `b` , ancak,,, `Black` `White` `Red` `Green` ve `Blue` statik alanlarının yalnızca bir kopyası vardır:</span><span class="sxs-lookup"><span data-stu-id="7edb9-138">In the following example, each instance of the `Color` class has a separate copy of the `r`, `g`, and `b` instance fields, but there's only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ColorClassDefinition":::

<span data-ttu-id="7edb9-139">Önceki örnekte gösterildiği gibi, *salt okuma alanları* bir değiştirici ile bildirilebilecek `readonly` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-139">As shown in the previous example, *read-only fields* may be declared with a `readonly` modifier.</span></span> <span data-ttu-id="7edb9-140">Salt okunurdur bir alana atama, yalnızca alanın bildiriminin bir parçası olarak veya aynı sınıftaki bir Oluşturucu halinde gerçekleşebilir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-140">Assignment to a read-only field can only occur as part of the field’s declaration or in a constructor in the same class.</span></span>

## <a name="methods"></a><span data-ttu-id="7edb9-141">Yöntemler</span><span class="sxs-lookup"><span data-stu-id="7edb9-141">Methods</span></span>

<span data-ttu-id="7edb9-142">Bir *Yöntem* , bir nesne veya sınıf tarafından gerçekleştirilebilecek bir hesaplama veya eylem uygulayan bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-142">A *method* is a member that implements a computation or action that can be performed by an object or class.</span></span> <span data-ttu-id="7edb9-143">*Statik yöntemlere* sınıfı aracılığıyla erişilir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-143">*Static methods* are accessed through the class.</span></span> <span data-ttu-id="7edb9-144">*Örnek yöntemlerine* , sınıfının örnekleri aracılığıyla erişilir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-144">*Instance methods* are accessed through instances of the class.</span></span>

<span data-ttu-id="7edb9-145">Metotlarda, metoda geçirilen değerleri veya değişken başvurularını temsil eden bir *parametre*listesi bulunabilir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-145">Methods may have a list of *parameters*, which represent values or variable references passed to the method.</span></span> <span data-ttu-id="7edb9-146">Yöntemler, hesaplanan ve yöntemi tarafından döndürülen değerin türünü belirten bir *dönüş türüne*sahiptir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-146">Methods have a *return type*, which specifies the type of the value computed and returned by the method.</span></span> <span data-ttu-id="7edb9-147">Bir yöntemin dönüş türü `void` bir değer döndürmezse.</span><span class="sxs-lookup"><span data-stu-id="7edb9-147">A method’s return type is `void` if it doesn't return a value.</span></span>

<span data-ttu-id="7edb9-148">Türler gibi yöntemler de bir tür parametreleri kümesine sahip olabilir, bu da yöntem çağrıldığında tür bağımsız değişkenlerinin belirtilmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-148">Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</span></span> <span data-ttu-id="7edb9-149">Türlerin aksine, tür bağımsız değişkenleri genellikle yöntem çağrısının bağımsız değişkenlerinden çıkarsanamıyor ve açıkça verilmemelidir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-149">Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</span></span>

<span data-ttu-id="7edb9-150">Yöntemin *imzası* , yöntemin bildirildiği sınıfta benzersiz olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-150">The *signature* of a method must be unique in the class in which the method is declared.</span></span> <span data-ttu-id="7edb9-151">Bir yöntemin imzası yöntemin adından, tür parametrelerinin sayısına ve parametrelerinin sayısına, değiştiricilerine ve türlerine sahiptir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-151">The signature of a method consists of the name of the method, the number of type parameters, and the number, modifiers, and types of its parameters.</span></span> <span data-ttu-id="7edb9-152">Bir yöntemin imzası, dönüş türünü içermez.</span><span class="sxs-lookup"><span data-stu-id="7edb9-152">The signature of a method doesn't include the return type.</span></span>

<span data-ttu-id="7edb9-153">Bir yöntem gövdesi tek bir ifadesiyse, aşağıdaki örnekte gösterildiği gibi, yöntem bir Compact ifadesi biçimi kullanılarak tanımlanabilir:</span><span class="sxs-lookup"><span data-stu-id="7edb9-153">When a method body is a single expression, the method can be defined using a compact expression format, as shown in the following example:</span></span>

```csharp
public override ToString() => "This is an object";
```

### <a name="parameters"></a><span data-ttu-id="7edb9-154">Parametreler</span><span class="sxs-lookup"><span data-stu-id="7edb9-154">Parameters</span></span>

<span data-ttu-id="7edb9-155">Parametreler, değerlere veya değişken başvurularını yöntemlere geçirmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-155">Parameters are used to pass values or variable references to methods.</span></span> <span data-ttu-id="7edb9-156">Bir yöntemin parametreleri, yöntemi çağrıldığında belirtilen *bağımsız değişkenlerden* gerçek değerlerini alır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-156">The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked.</span></span> <span data-ttu-id="7edb9-157">Dört tür parametre vardır: değer parametreleri, başvuru parametreleri, çıkış parametreleri ve parametre dizileri.</span><span class="sxs-lookup"><span data-stu-id="7edb9-157">There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</span></span>

<span data-ttu-id="7edb9-158">Giriş bağımsız değişkenlerini geçirmek için bir *değer parametresi* kullanılır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-158">A *value parameter* is used for passing input arguments.</span></span> <span data-ttu-id="7edb9-159">Değer parametresi, parametresi için geçirilen bağımsız değişkenden ilk değerini alan yerel bir değişkene karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-159">A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</span></span> <span data-ttu-id="7edb9-160">Değer parametresindeki değişiklikler, parametresi için geçirilen bağımsız değişkeni etkilemez.</span><span class="sxs-lookup"><span data-stu-id="7edb9-160">Modifications to a value parameter don't affect the argument that was passed for the parameter.</span></span>

<span data-ttu-id="7edb9-161">Değer parametreleri, ilgili bağımsız değişkenlerin atlanabilmesi için varsayılan bir değer belirtilerek isteğe bağlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-161">Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</span></span>

<span data-ttu-id="7edb9-162">*Başvuru parametresi* , bağımsız değişkenleri başvuruya göre geçirmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-162">A *reference parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="7edb9-163">Başvuru parametresi için geçirilen bağımsız değişken, kesin bir değere sahip bir değişken olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-163">The argument passed for a reference parameter must be a variable with a definite value.</span></span> <span data-ttu-id="7edb9-164">Yöntemin yürütülmesi sırasında başvuru parametresi, bağımsız değişken değişkeniyle aynı depolama konumunu temsil eder.</span><span class="sxs-lookup"><span data-stu-id="7edb9-164">During execution of the method, the reference parameter represents the same storage location as the argument variable.</span></span> <span data-ttu-id="7edb9-165">Bir başvuru parametresi değiştiriciyle birlikte bildirilmiştir `ref` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-165">A reference parameter is declared with the `ref` modifier.</span></span> <span data-ttu-id="7edb9-166">Aşağıdaki örnek parametrelerin kullanımını gösterir `ref` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-166">The following example shows the use of `ref` parameters.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RefExample":::

<span data-ttu-id="7edb9-167">Bir *output parametresi* , bağımsız değişkenleri başvuruya göre geçirmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-167">An *output parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="7edb9-168">Bir başvuru parametresine benzer, ancak çağıran tarafından belirtilen bağımsız değişkene açıkça bir değer atamanız gerekmez.</span><span class="sxs-lookup"><span data-stu-id="7edb9-168">It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</span></span> <span data-ttu-id="7edb9-169">Bir çıkış parametresi değiştiriciyle birlikte bildirilmiştir `out` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-169">An output parameter is declared with the `out` modifier.</span></span> <span data-ttu-id="7edb9-170">Aşağıdaki örnek, `out` C# 7 ' de tanıtılan sözdizimi kullanılarak parametrelerin kullanımını gösterir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-170">The following example shows the use of `out` parameters using the syntax introduced in C# 7.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="OutExample":::

<span data-ttu-id="7edb9-171">Bir *parametre dizisi* , bir metoda değişken sayıda bağımsız değişken geçirilmesine izin verir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-171">A *parameter array* permits a variable number of arguments to be passed to a method.</span></span> <span data-ttu-id="7edb9-172">Bir parametre dizisi değiştiriciyle birlikte bildirilmiştir `params` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-172">A parameter array is declared with the `params` modifier.</span></span> <span data-ttu-id="7edb9-173">Bir yöntemin yalnızca son parametresi bir parametre dizisi olabilir ve bir parametre dizisinin türü tek boyutlu bir dizi türü olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-173">Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</span></span> <span data-ttu-id="7edb9-174">`Write`Sınıfının ve `WriteLine` yöntemleri, <xref:System.Console?displayProperty=nameWithType> parametre dizisi kullanımının iyi örnekleridir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-174">The `Write` and `WriteLine` methods of the <xref:System.Console?displayProperty=nameWithType> class are good examples of parameter array usage.</span></span> <span data-ttu-id="7edb9-175">Bunlar aşağıdaki şekilde bildirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-175">They're declared as follows.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ConsoleExtract":::

<span data-ttu-id="7edb9-176">Bir parametre dizisi kullanan bir yöntem içinde, parametre dizisi tam olarak bir dizi türünün normal parametresine benzer şekilde davranır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-176">Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</span></span> <span data-ttu-id="7edb9-177">Ancak, bir parametre dizisi olan bir yöntem çağrısında, parametre dizisi türünün tek bir bağımsız değişkenini veya parametre dizisinin öğe türünün herhangi bir sayıda bağımsız değişkenini geçirmek mümkündür.</span><span class="sxs-lookup"><span data-stu-id="7edb9-177">However, in an invocation of a method with a parameter array, it's possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</span></span> <span data-ttu-id="7edb9-178">İkinci durumda, bir dizi örneği otomatik olarak oluşturulur ve verilen bağımsız değişkenlerle başlatılır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-178">In the latter case, an array instance is automatically created and initialized with the given arguments.</span></span> <span data-ttu-id="7edb9-179">Bu örnek</span><span class="sxs-lookup"><span data-stu-id="7edb9-179">This example</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseParamsArgs":::

<span data-ttu-id="7edb9-180">, aşağıdaki yazma ile eşdeğerdir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-180">is equivalent to writing the following.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CompilerParams":::

### <a name="method-body-and-local-variables"></a><span data-ttu-id="7edb9-181">Yöntem gövdesi ve yerel değişkenler</span><span class="sxs-lookup"><span data-stu-id="7edb9-181">Method body and local variables</span></span>

<span data-ttu-id="7edb9-182">Yöntemin gövdesi, yöntemi çağrıldığında yürütülecek deyimleri belirtir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-182">A method’s body specifies the statements to execute when the method is invoked.</span></span>

<span data-ttu-id="7edb9-183">Yöntem gövdesi, yöntemi çağrısına özgü değişkenleri bildirebilir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-183">A method body can declare variables that are specific to the invocation of the method.</span></span> <span data-ttu-id="7edb9-184">Bu tür değişkenlere *yerel değişkenler*denir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-184">Such variables are called *local variables*.</span></span> <span data-ttu-id="7edb9-185">Yerel bir değişken bildirimi bir tür adı, değişken adı ve muhtemelen bir başlangıç değeri belirtir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-185">A local variable declaration specifies a type name, a variable name, and possibly an initial value.</span></span> <span data-ttu-id="7edb9-186">Aşağıdaki örnek, başlangıç değeri sıfır olan yerel bir değişken `i` ve ilk değeri olmayan bir yerel değişken bildirir `j` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-186">The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="SquaresClass":::

<span data-ttu-id="7edb9-187">C# değeri alınabilmesi için önce bir yerel değişkenin *kesinlikle atanmasını* gerektirir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-187">C# requires a local variable to be *definitely assigned* before its value can be obtained.</span></span> <span data-ttu-id="7edb9-188">Örneğin, önceki bildirimi `i` bir başlangıç değeri içermiyorsa, `i` `i` programda bu noktalarda kesin olarak atanmadığı için derleyici daha sonraki kullanımları için bir hata bildirir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-188">For example, if the declaration of the previous `i` didn't include an initial value, the compiler would report an error for the later usages of `i` because `i` wouldn't be definitely assigned at those points in the program.</span></span>

<span data-ttu-id="7edb9-189">Bir yöntem `return` , çağrı yapana denetim döndürmek için deyimlerini kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-189">A method can use `return` statements to return control to its caller.</span></span> <span data-ttu-id="7edb9-190">Döndürülen bir yöntemde `void` `return` deyimler bir ifade belirtemez.</span><span class="sxs-lookup"><span data-stu-id="7edb9-190">In a method returning `void`, `return` statements can't specify an expression.</span></span> <span data-ttu-id="7edb9-191">Void olmayan bir yöntemde `return` deyim dönüş değerini hesaplayan bir ifade içermelidir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-191">In a method returning non-void, `return` statements must include an expression that computes the return value.</span></span>

### <a name="static-and-instance-methods"></a><span data-ttu-id="7edb9-192">Statik ve örnek yöntemleri</span><span class="sxs-lookup"><span data-stu-id="7edb9-192">Static and instance methods</span></span>

<span data-ttu-id="7edb9-193">Değiştirici ile belirtilen bir yöntem `static` *statik bir yöntemdir*.</span><span class="sxs-lookup"><span data-stu-id="7edb9-193">A method declared with a `static` modifier is a *static method*.</span></span> <span data-ttu-id="7edb9-194">Statik bir yöntem, belirli bir örnek üzerinde çalışmaz ve yalnızca statik üyelere doğrudan erişebilir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-194">A static method doesn't operate on a specific instance and can only directly access static members.</span></span>

<span data-ttu-id="7edb9-195">Değiştirici olmadan bildirildiği bir yöntem `static` bir *örnek yöntemidir*.</span><span class="sxs-lookup"><span data-stu-id="7edb9-195">A method declared without a `static` modifier is an *instance method*.</span></span> <span data-ttu-id="7edb9-196">Örnek yöntemi, belirli bir örnek üzerinde çalışır ve hem statik hem de örnek üyelerine erişebilir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-196">An instance method operates on a specific instance and can access both static and instance members.</span></span> <span data-ttu-id="7edb9-197">Örnek yönteminin çağrıldığı örnek, olarak açıkça erişilebilir `this` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-197">The instance on which an instance method was invoked can be explicitly accessed as `this`.</span></span> <span data-ttu-id="7edb9-198">Statik bir yöntemde başvurmak için bir hatadır `this` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-198">It's an error to refer to `this` in a static method.</span></span>

<span data-ttu-id="7edb9-199">Aşağıdaki `Entity` sınıfta hem statik hem de örnek üyeleri vardır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-199">The following `Entity` class has both static and instance members.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="EntityClass":::

<span data-ttu-id="7edb9-200">Her `Entity` örnek bir seri numarası içerir (ve burada görünmeyen bazı diğer bilgileri kabul edilir).</span><span class="sxs-lookup"><span data-stu-id="7edb9-200">Each `Entity` instance contains a serial number (and presumably some other information that isn't shown here).</span></span> <span data-ttu-id="7edb9-201">`Entity`Oluşturucu (bir örnek yöntemi gibi) yeni örneği bir sonraki kullanılabilir seri numarasıyla başlatır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-201">The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number.</span></span> <span data-ttu-id="7edb9-202">Oluşturucu bir örnek üyesi olduğundan, hem `_serialNo` örnek alanına hem de statik alana erişme izni vardır `s_nextSerialNo` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-202">Because the constructor is an instance member, it's permitted to access both the `_serialNo` instance field and the `s_nextSerialNo` static field.</span></span>

<span data-ttu-id="7edb9-203">`GetNextSerialNo`Ve `SetNextSerialNo` statik yöntemler `s_nextSerialNo` statik alana erişebilir, ancak örnek alanına doğrudan erişmesi için bir hata olabilir `_serialNo` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-203">The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `s_nextSerialNo` static field, but it would be an error for them to directly access the `_serialNo` instance field.</span></span>

<span data-ttu-id="7edb9-204">Aşağıdaki örnek sınıfının kullanımını gösterir `Entity` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-204">The following example shows the use of the `Entity` class.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingEntity":::

<span data-ttu-id="7edb9-205">`SetNextSerialNo`Ve `GetNextSerialNo` statik yöntemler sınıfında çağrılır, ancak `GetSerialNo` örnek yöntemi sınıfının örneklerinde çağrılır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-205">The `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.</span></span>

### <a name="virtual-override-and-abstract-methods"></a><span data-ttu-id="7edb9-206">Sanal, geçersiz kılma ve soyut yöntemler</span><span class="sxs-lookup"><span data-stu-id="7edb9-206">Virtual, override, and abstract methods</span></span>

<span data-ttu-id="7edb9-207">Bir örnek yöntemi bildirimi bir değiştirici içerdiğinde `virtual` , yöntemi bir *sanal yöntem*olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-207">When an instance method declaration includes a `virtual` modifier, the method is said to be a *virtual method*.</span></span> <span data-ttu-id="7edb9-208">Bir sanal değiştirici yoksa, yöntem *sanal olmayan bir yöntem*olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-208">When no virtual modifier is present, the method is said to be a *nonvirtual method*.</span></span>

<span data-ttu-id="7edb9-209">Bir sanal yöntem çağrıldığında, çağrının gerçekleştiği örneğin *çalışma zamanı türü* , çağrılacak gerçek Yöntem uygulamasını belirler.</span><span class="sxs-lookup"><span data-stu-id="7edb9-209">When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke.</span></span> <span data-ttu-id="7edb9-210">Sanal olmayan bir yöntem çağrısında, örneğin *derleme zamanı türü* belirleme faktörü olur.</span><span class="sxs-lookup"><span data-stu-id="7edb9-210">In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.</span></span>

<span data-ttu-id="7edb9-211">Bir sanal yöntem, türetilmiş bir sınıfta *geçersiz kılınabilir* .</span><span class="sxs-lookup"><span data-stu-id="7edb9-211">A virtual method can be *overridden* in a derived class.</span></span> <span data-ttu-id="7edb9-212">Bir örnek yöntemi bildirimi bir geçersiz kılma değiştiricisi içerdiğinde, yöntemi aynı imzaya sahip devralınmış bir sanal yöntemi geçersiz kılar.</span><span class="sxs-lookup"><span data-stu-id="7edb9-212">When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</span></span> <span data-ttu-id="7edb9-213">Bir sanal yöntem bildirimi yeni bir yöntem sunar.</span><span class="sxs-lookup"><span data-stu-id="7edb9-213">A virtual method declaration introduces a new method.</span></span> <span data-ttu-id="7edb9-214">Bir geçersiz kılma yöntemi bildirimi, bu yöntemin yeni bir uygulamasını sağlayarak, var olan bir devralınmış sanal yöntemi uzmanlık eder.</span><span class="sxs-lookup"><span data-stu-id="7edb9-214">An override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</span></span>

<span data-ttu-id="7edb9-215">*Soyut bir yöntem* , uygulama içermeyen bir sanal yöntemdir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-215">An *abstract method* is a virtual method with no implementation.</span></span> <span data-ttu-id="7edb9-216">Soyut bir yöntem `abstract` değiştiriciyle tanımlanmış ve yalnızca bir soyut sınıfta izin verilir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-216">An abstract method is declared with the `abstract` modifier and is permitted only in an abstract class.</span></span> <span data-ttu-id="7edb9-217">Soyut olmayan her türetilmiş sınıfta bir soyut yöntem geçersiz kılınmalıdır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-217">An abstract method must be overridden in every non-abstract derived class.</span></span>

<span data-ttu-id="7edb9-218">Aşağıdaki örnek, `Expression` bir ifade ağaç düğümünü temsil eden bir soyut sınıfı ve `Constant` `VariableReference` `Operation` sabitler, değişken başvuruları ve aritmetik işlemler için ifade ağacı düğümleri uygulayan üç türetilmiş sınıfı,, ve ' ı tanımlar.</span><span class="sxs-lookup"><span data-stu-id="7edb9-218">The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations.</span></span> <span data-ttu-id="7edb9-219">(Bu örnek, ifade ağacı türleriyle ilgili değildir ancak ile benzerdir).</span><span class="sxs-lookup"><span data-stu-id="7edb9-219">(This example is similar to, but not related to the expression tree types).</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="WorkingWithExpressions":::

<span data-ttu-id="7edb9-220">Önceki dört sınıf aritmetik ifadeleri modellemek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-220">The previous four classes can be used to model arithmetic expressions.</span></span> <span data-ttu-id="7edb9-221">Örneğin, bu sınıfların örneklerini kullanarak, ifadesi `x + 3` aşağıdaki gibi gösterilebilir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-221">For example, using instances of these classes, the expression `x + 3` can be represented as follows.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseExpressions":::

<span data-ttu-id="7edb9-222">`Evaluate`Bir örneğin yöntemi, `Expression` verilen ifadeyi değerlendirmek ve bir değer üretmek için çağrılır `double` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-222">The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value.</span></span> <span data-ttu-id="7edb9-223">Yöntemi, `Dictionary` değişken adlarını (girdilerin anahtarları olarak) ve değerlerini (girişlerin değerleri olarak) içeren bir bağımsız değişken alır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-223">The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries).</span></span> <span data-ttu-id="7edb9-224">`Evaluate`Soyut bir yöntem olduğundan, öğesinden türetilen soyut olmayan sınıflar `Expression` geçersiz kılınmalıdır `Evaluate` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-224">Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.</span></span>

<span data-ttu-id="7edb9-225">' `Constant` Nin uygulanması, `Evaluate` yalnızca saklı sabiti döndürür.</span><span class="sxs-lookup"><span data-stu-id="7edb9-225">A `Constant`'s implementation of `Evaluate` simply returns the stored constant.</span></span> <span data-ttu-id="7edb9-226">A `VariableReference` uygulamasının, sözlükte değişken adını arar ve elde edilen değeri döndürür.</span><span class="sxs-lookup"><span data-stu-id="7edb9-226">A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value.</span></span> <span data-ttu-id="7edb9-227">Bir `Operation` uygulama ilk olarak sol ve sağ işlenenleri değerlendirir (yöntemlerini özyinelemeli olarak çağırarak `Evaluate` ) ve ardından verilen aritmetik işlemi gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-227">An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.</span></span>

<span data-ttu-id="7edb9-228">Aşağıdaki program, `Expression` `x * (y + 2)` ve farklı değerleri için ifadeyi değerlendirmek için sınıflarını kullanır `x` `y` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-228">The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingExpressions":::

### <a name="method-overloading"></a><span data-ttu-id="7edb9-229">Yöntem aşırı yüklemesi</span><span class="sxs-lookup"><span data-stu-id="7edb9-229">Method overloading</span></span>

<span data-ttu-id="7edb9-230">Yöntem *aşırı yüklemesi* , aynı sınıftaki birden çok metodun benzersiz imzalara sahip oldukları sürece aynı ada sahip olmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="7edb9-230">Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures.</span></span> <span data-ttu-id="7edb9-231">Aşırı yüklenmiş bir yöntemin çağrılması derlenirken, derleyici çağrılacak özel yöntemi belirlemekte *aşırı yükleme çözümü* kullanır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-231">When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke.</span></span> <span data-ttu-id="7edb9-232">Aşırı yükleme çözümlemesi, bağımsız değişkenlerle en iyi eşleşen bir yöntemi bulur.</span><span class="sxs-lookup"><span data-stu-id="7edb9-232">Overload resolution finds the one method that best matches the arguments.</span></span> <span data-ttu-id="7edb9-233">Tek bir en iyi eşleşme bulunamazsa bir hata bildirilir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-233">If no single best match can be found, an error is reported.</span></span> <span data-ttu-id="7edb9-234">Aşağıdaki örnekte, etkin olan aşırı yükleme çözümü gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-234">The following example shows overload resolution in effect.</span></span> <span data-ttu-id="7edb9-235">Yöntemi içindeki her çağrının yorumu `UsageExample` hangi yöntemin çağrılacağını gösterir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-235">The comment for each invocation in the `UsageExample` method shows which method is invoked.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="Overloading":::

<span data-ttu-id="7edb9-236">Örnekte gösterildiği gibi belirli bir yöntem her zaman bağımsız değişkenleri tam parametre türlerine ve tür bağımsız değişkenlerine açıkça atayarak seçilebilir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-236">As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and type arguments.</span></span>

## <a name="other-function-members"></a><span data-ttu-id="7edb9-237">Diğer işlev üyeleri</span><span class="sxs-lookup"><span data-stu-id="7edb9-237">Other function members</span></span>

<span data-ttu-id="7edb9-238">Yürütülebilir kod içeren Üyeler topluca bir sınıfın *işlev üyeleri* olarak bilinir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-238">Members that contain executable code are collectively known as the *function members* of a class.</span></span> <span data-ttu-id="7edb9-239">Yukarıdaki bölümde, işlev üyelerinin birincil türleri olan yöntemler açıklanmıştır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-239">The preceding section describes methods, which are the primary types of function members.</span></span> <span data-ttu-id="7edb9-240">Bu bölümde C# tarafından desteklenen diğer işlev üyesi türleri açıklanmaktadır: oluşturucular, özellikler, Dizin oluşturucular, olaylar, işleçler ve sonlandırıcılar.</span><span class="sxs-lookup"><span data-stu-id="7edb9-240">This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</span></span>

<span data-ttu-id="7edb9-241">Aşağıdaki örnek `MyList<T>` , bir nesne growable listesini uygulayan adlı bir genel sınıfı gösterir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-241">The following example shows a generic class called `MyList<T>`, which implements a growable list of objects.</span></span> <span data-ttu-id="7edb9-242">Sınıfı, en yaygın işlev üyesi türlerine birkaç örnek içerir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-242">The class contains several examples of the most common kinds of function members.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListExample":::

### <a name="constructors"></a><span data-ttu-id="7edb9-243">Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="7edb9-243">Constructors</span></span>

<span data-ttu-id="7edb9-244">C# hem örnek hem de statik oluşturucuları destekler.</span><span class="sxs-lookup"><span data-stu-id="7edb9-244">C# supports both instance and static constructors.</span></span> <span data-ttu-id="7edb9-245">*Örnek Oluşturucu* , bir sınıfın örneğini başlatmak için gereken eylemleri uygulayan bir üyedir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-245">An *instance constructor* is a member that implements the actions required to initialize an instance of a class.</span></span> <span data-ttu-id="7edb9-246">*Statik Oluşturucu* , ilk yüklendiği zaman bir sınıfın kendisini başlatmak için gereken eylemleri uygulayan bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-246">A *static constructor* is a member that implements the actions required to initialize a class itself when it's first loaded.</span></span>

<span data-ttu-id="7edb9-247">Bir Oluşturucu, dönüş türü olmayan bir yöntem ve kapsayan sınıfla aynı adı ile birlikte bildirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-247">A constructor is declared like a method with no return type and the same name as the containing class.</span></span> <span data-ttu-id="7edb9-248">Bir Oluşturucu bildiriminde bir değiştirici varsa `static` , bir statik oluşturucu bildirir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-248">If a constructor declaration includes a `static` modifier, it declares a static constructor.</span></span> <span data-ttu-id="7edb9-249">Aksi takdirde, bir örnek Oluşturucu bildirir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-249">Otherwise, it declares an instance constructor.</span></span>

<span data-ttu-id="7edb9-250">Örnek oluşturucular aşırı yüklenebilir ve isteğe bağlı parametrelere sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-250">Instance constructors can be overloaded and can have optional parameters.</span></span> <span data-ttu-id="7edb9-251">Örneğin, `MyList<T>` sınıfı tek bir isteğe bağlı parametre ile bir örnek Oluşturucu bildirir `int` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-251">For example, the `MyList<T>` class declares one instance constructor with a single optional `int` parameter.</span></span> <span data-ttu-id="7edb9-252">Örnek oluşturucular işleci kullanılarak çağrılır `new` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-252">Instance constructors are invoked using the `new` operator.</span></span> <span data-ttu-id="7edb9-253">Aşağıdaki deyimler, `MyList<string>` `MyList` ve isteğe bağlı bağımsız değişken olmadan sınıfının oluşturucusunu kullanarak iki örnek ayırır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-253">The following statements allocate two `MyList<string>` instances using the constructor of the `MyList` class with and without the optional argument.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CreateLists":::

<span data-ttu-id="7edb9-254">Diğer üyelerin aksine, örnek oluşturucular devralınmaz.</span><span class="sxs-lookup"><span data-stu-id="7edb9-254">Unlike other members, instance constructors aren't inherited.</span></span> <span data-ttu-id="7edb9-255">Bir sınıf, sınıfta gerçekten tanımlanmış olan oluşturuculardan başka örnek oluşturuculara sahip değildir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-255">A class has no instance constructors other than those constructors actually declared in the class.</span></span> <span data-ttu-id="7edb9-256">Bir sınıf için örnek Oluşturucu sağlanmazsa, parametresi olmayan boş bir değer otomatik olarak sağlanır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-256">If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</span></span>

### <a name="properties"></a><span data-ttu-id="7edb9-257">Özellikler</span><span class="sxs-lookup"><span data-stu-id="7edb9-257">Properties</span></span>

<span data-ttu-id="7edb9-258">*Özellikler* , alanlar için doğal bir uzantıdır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-258">*Properties* are a natural extension of fields.</span></span> <span data-ttu-id="7edb9-259">Her ikisi de ilişkili türlerin bulunduğu isimlerdir ve alanlara ve özelliklere erişim için sözdizimi aynıdır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-259">Both are named members with associated types, and the syntax for accessing fields and properties is the same.</span></span> <span data-ttu-id="7edb9-260">Ancak, alanların aksine, Özellikler depolama konumlarını göstermiyor.</span><span class="sxs-lookup"><span data-stu-id="7edb9-260">However, unlike fields, properties don't denote storage locations.</span></span> <span data-ttu-id="7edb9-261">Bunun yerine, özellikler, değerleri okunmak veya yazıldığında yürütülen deyimleri belirten *erişimcileri* vardır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-261">Instead, properties have *accessors* that specify the statements executed when their values are read or written.</span></span>

<span data-ttu-id="7edb9-262">Bir özellik, bildirim bir get erişimcisi ile sona erene veya sınırlayıcılar arasında yazılmış bir set erişimcisi ya da bir `{` noktalı virgülle bitmesi dışında, bir alan gibi tanımlanır `}` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-262">A property is declared like a field, except that the declaration ends with a get accessor or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.</span></span> <span data-ttu-id="7edb9-263">Hem get erişimcisine hem de bir set erişimcisine sahip olan bir özellik *okuma-yazma özelliğidir*, yalnızca bir get erişimcisine sahip olan bir özellik *salt okunurdur*ve yalnızca bir set erişimcisi olan bir özellik yalnızca bir salt *yazılır özelliktir*.</span><span class="sxs-lookup"><span data-stu-id="7edb9-263">A property that has both a get accessor and a set accessor is a *read-write property*, a property that has only a get accessor is a *read-only property*, and a property that has only a set accessor is a *write-only property*.</span></span>

<span data-ttu-id="7edb9-264">Get erişimcisi, özellik türünün dönüş değeri olan parametresiz bir yönteme karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-264">A get accessor corresponds to a parameterless method with a return value of the property type.</span></span> <span data-ttu-id="7edb9-265">Bir set erişimcisi, value adlı tek parametreli ve dönüş türü olmayan bir yönteme karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-265">A set accessor corresponds to a method with a single parameter named value and no return type.</span></span> <span data-ttu-id="7edb9-266">Get erişimcisi özelliğin değerini hesaplar.</span><span class="sxs-lookup"><span data-stu-id="7edb9-266">The get accessor computes the value of the property.</span></span> <span data-ttu-id="7edb9-267">Set erişimcisi, özelliği için yeni bir değer sağlar.</span><span class="sxs-lookup"><span data-stu-id="7edb9-267">The set accessor provides a new value for the property.</span></span> <span data-ttu-id="7edb9-268">Özellik bir atamanın hedefi ya da veya işleneni, `++` `--` set erişimcisi çağrılır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-268">When the property is the target of an assignment, or the operand of `++` or `--`, the set accessor is invoked.</span></span> <span data-ttu-id="7edb9-269">Özelliğin başvurduğu diğer durumlarda, get erişimcisi çağrılır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-269">In other cases where the property is referenced, the get accessor is invoked.</span></span>

<span data-ttu-id="7edb9-270">`MyList<T>`Sınıfı iki özellik bildirir `Count` ve `Capacity` sırasıyla salt okunurdur ve okuma-yazma olur.</span><span class="sxs-lookup"><span data-stu-id="7edb9-270">The `MyList<T>` class declares two properties, `Count` and `Capacity`, which are read-only and read-write, respectively.</span></span> <span data-ttu-id="7edb9-271">Aşağıdaki kod, bu özelliklerin kullanım örneğidir:</span><span class="sxs-lookup"><span data-stu-id="7edb9-271">The following code is an example of use of these properties:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="AccessProperties":::

<span data-ttu-id="7edb9-272">Alanlar ve yöntemlere benzer şekilde C# hem örnek özelliklerini hem de statik özellikleri destekler.</span><span class="sxs-lookup"><span data-stu-id="7edb9-272">Similar to fields and methods, C# supports both instance properties and static properties.</span></span> <span data-ttu-id="7edb9-273">Statik özellikler statik değiştirici ile tanımlanır ve örnek özellikleri bu olmadan tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-273">Static properties are declared with the static modifier, and instance properties are declared without it.</span></span>

<span data-ttu-id="7edb9-274">Bir özelliğin erişimcisi sanal olabilir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-274">The accessor(s) of a property can be virtual.</span></span> <span data-ttu-id="7edb9-275">Bir özellik bildirimi `virtual` ,, `abstract` veya değiştiricisini içerdiğinde, `override` özelliğin erişimcilerle geçerli olur.</span><span class="sxs-lookup"><span data-stu-id="7edb9-275">When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.</span></span>

### <a name="indexers"></a><span data-ttu-id="7edb9-276">Dizin Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="7edb9-276">Indexers</span></span>

<span data-ttu-id="7edb9-277">*Dizin Oluşturucu* , nesnelerin diziyle aynı şekilde dizinlenmesini sağlayan bir üyedir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-277">An *indexer* is a member that enables objects to be indexed in the same way as an array.</span></span> <span data-ttu-id="7edb9-278">Bir Dizin Oluşturucu, üyenin adının `this` ardından sınırlayıcılar ve arasında yazılmış bir parametre listesi gelmesi dışında bir özellik gibi bildirilmiştir `[` `]` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-278">An indexer is declared like a property except that the name of the member is `this` followed by a parameter list written between the delimiters `[` and `]`.</span></span> <span data-ttu-id="7edb9-279">Parametreler, dizin oluşturucunun erişimcisinde kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-279">The parameters are available in the accessor(s) of the indexer.</span></span> <span data-ttu-id="7edb9-280">Özelliklere benzer şekilde, Dizin oluşturucular okunabilir-yazılır, salt okunurdur ve salt yazılır olabilir ve bir dizin oluşturucunun erişimcisi sanal olabilir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-280">Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</span></span>

<span data-ttu-id="7edb9-281">`MyList<T>`Sınıfı, bir parametresi alan tek bir okuma-yazma Dizin Oluşturucu bildirir `int` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-281">The `MyList<T>` class declares a single read-write indexer that takes an `int` parameter.</span></span> <span data-ttu-id="7edb9-282">Dizin Oluşturucu, örneklerin değerleriyle dizin oluşturmanızı mümkün kılar `MyList<T>` `int` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-282">The indexer makes it possible to index `MyList<T>` instances with `int` values.</span></span> <span data-ttu-id="7edb9-283">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="7edb9-283">For example:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAccess":::

<span data-ttu-id="7edb9-284">Dizin oluşturucular aşırı yüklenebilir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-284">Indexers can be overloaded.</span></span> <span data-ttu-id="7edb9-285">Bir sınıf, parametrelerinin sayısı veya türleri farklı olduğu sürece birden çok Dizin Oluşturucu bildirebilir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-285">A class can declare multiple indexers as long as the number or types of their parameters differ.</span></span>

### <a name="events"></a><span data-ttu-id="7edb9-286">Ekinlikler</span><span class="sxs-lookup"><span data-stu-id="7edb9-286">Events</span></span>

<span data-ttu-id="7edb9-287">Bir *olay* , bir sınıf veya nesnenin bildirimler sağlamasını sağlayan bir üyedir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-287">An *event* is a member that enables a class or object to provide notifications.</span></span> <span data-ttu-id="7edb9-288">Bildirimin bir `event` anahtar sözcük içermesi ve türün bir temsilci türü olması dışında bir olay, bir alan gibi bildirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-288">An event is declared like a field except that the declaration includes an `event` keyword and the type must be a delegate type.</span></span>

<span data-ttu-id="7edb9-289">Olay üyesini bildiren bir sınıf içinde, olay bir temsilci türünün alanı gibi davranır (olay soyut değildir ve erişimcileri bildirmez).</span><span class="sxs-lookup"><span data-stu-id="7edb9-289">Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event isn't abstract and doesn't declare accessors).</span></span> <span data-ttu-id="7edb9-290">Bu alan, olaya eklenmiş olan olay işleyicilerini temsil eden bir temsilciye bir başvuru depolar.</span><span class="sxs-lookup"><span data-stu-id="7edb9-290">The field stores a reference to a delegate that represents the event handlers that have been added to the event.</span></span> <span data-ttu-id="7edb9-291">Hiçbir olay işleyicisi yoksa, alanı olur `null` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-291">If no event handlers are present, the field is `null`.</span></span>

<span data-ttu-id="7edb9-292">`MyList<T>`Sınıfı, adlı tek bir olay üyesini bildirir `Changed` ve bu, listeye yeni bir öğe eklendiğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-292">The `MyList<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list.</span></span> <span data-ttu-id="7edb9-293">Değiştirilen olay `OnChanged` sanal yöntemi tarafından tetiklenir ve bu, önce olayın `null` (hiçbir işleyicinin mevcut olmadığı anlamına gelir) olup olmadığını denetler.</span><span class="sxs-lookup"><span data-stu-id="7edb9-293">The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present).</span></span> <span data-ttu-id="7edb9-294">Bir olayı oluşturma kavramı, olay tarafından temsil edilen temsilciyi çağırmaya tam olarak eşdeğerdir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-294">The notion of raising an event is precisely equivalent to invoking the delegate represented by the event.</span></span> <span data-ttu-id="7edb9-295">Olayları yükseltmek için özel dil yapıları yoktur.</span><span class="sxs-lookup"><span data-stu-id="7edb9-295">There are no special language constructs for raising events.</span></span>

<span data-ttu-id="7edb9-296">İstemciler *olay işleyicileri*aracılığıyla olaylara tepki verir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-296">Clients react to events through *event handlers*.</span></span> <span data-ttu-id="7edb9-297">Olay işleyicileri işleci kullanılarak eklenir `+=` ve işleci kullanılarak kaldırılır `-=` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-297">Event handlers are attached using the `+=` operator and removed using the `-=` operator.</span></span> <span data-ttu-id="7edb9-298">Aşağıdaki örnek, olayına bir olay işleyicisi ekler `Changed` `MyList<string>` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-298">The following example attaches an event handler to the `Changed` event of a `MyList<string>`.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RespondToEvents":::

<span data-ttu-id="7edb9-299">Bir olayın temeldeki depolamanın denetiminin istendiği Gelişmiş senaryolarda, bir olay bildirimi açıkça sağlayabilir `add` ve `remove` Bu da `set` bir özelliğin erişimcisine benzer.</span><span class="sxs-lookup"><span data-stu-id="7edb9-299">For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are similar to the `set` accessor of a property.</span></span>

### <a name="operators"></a><span data-ttu-id="7edb9-300">İşleçler</span><span class="sxs-lookup"><span data-stu-id="7edb9-300">Operators</span></span>

<span data-ttu-id="7edb9-301">*İşleci* , bir sınıfın örneklerine belirli bir ifade işlecini uygulamanın anlamını tanımlayan bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-301">An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class.</span></span> <span data-ttu-id="7edb9-302">Üç tür işleç tanımlanabilir: Birli İşleçler, ikili işleçler ve dönüştürme işleçleri.</span><span class="sxs-lookup"><span data-stu-id="7edb9-302">Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</span></span> <span data-ttu-id="7edb9-303">Tüm işleçler ve olarak bildirilmelidir `public` `static` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-303">All operators must be declared as `public` and `static`.</span></span>

<span data-ttu-id="7edb9-304">`MyList<T>`Sınıfı iki işleç bildirir `operator ==` ve `operator !=` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-304">The `MyList<T>` class declares two operators, `operator ==` and `operator !=`.</span></span> <span data-ttu-id="7edb9-305">Bu geçersiz kılınan operatörler, bu işleçleri örneklere uygulayan deyimlere yeni anlam verir `MyList` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-305">These overridden operators give new meaning to expressions that apply those operators to `MyList` instances.</span></span> <span data-ttu-id="7edb9-306">Özellikle, işleçler, `MyList<T>` içerilen nesnelerin her birini yöntemlerini kullanarak karşılaştıran iki örneğin eşitliğini tanımlar `Equals` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-306">Specifically, the operators define equality of two `MyList<T>` instances as comparing each of the contained objects using their `Equals` methods.</span></span> <span data-ttu-id="7edb9-307">Aşağıdaki örnek, `==` iki örneği karşılaştırmak için işlecini kullanır `MyList<int>` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-307">The following example uses the `==` operator to compare two `MyList<int>` instances.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAddition":::

<span data-ttu-id="7edb9-308">Bu `Console.WriteLine` `True` iki liste aynı sırada aynı değerleri taşıyan aynı sayıda nesne içerdiğinden ilk çıktılar.</span><span class="sxs-lookup"><span data-stu-id="7edb9-308">The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order.</span></span> <span data-ttu-id="7edb9-309">`MyList<T>`Tanımlı değil `operator ==` , ilki `Console.WriteLine` çıktıyı içeriyor `False` `a` ve `b` farklı örneklere başvuracaktır `MyList<int>` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-309">Had `MyList<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `MyList<int>` instances.</span></span>

### <a name="finalizers"></a><span data-ttu-id="7edb9-310">Sonlandırıcılar</span><span class="sxs-lookup"><span data-stu-id="7edb9-310">Finalizers</span></span>

<span data-ttu-id="7edb9-311">*Sonlandırıcı* , bir sınıfın örneğini tamamlamak için gereken eylemleri uygulayan bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-311">A *finalizer* is a member that implements the actions required to finalize an instance of a class.</span></span> <span data-ttu-id="7edb9-312">Genellikle, yönetilmeyen kaynakları serbest bırakmak için sonlandırıcının olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-312">Typically, a finalizer is needed to release unmanaged resources.</span></span> <span data-ttu-id="7edb9-313">Sonlandırıcılar parametrelere sahip olamaz, erişilebilirlik değiştiricilerine sahip olamaz ve açıkça çağrılamaz.</span><span class="sxs-lookup"><span data-stu-id="7edb9-313">Finalizers can't have parameters, they can't have accessibility modifiers, and they can't be invoked explicitly.</span></span> <span data-ttu-id="7edb9-314">Örnek için Sonlandırıcı çöp toplama sırasında otomatik olarak çağrılır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-314">The finalizer for an instance is invoked automatically during garbage collection.</span></span> <span data-ttu-id="7edb9-315">Daha fazla ayrıntı için [sonlandırıcılar](../programming-guide/classes-and-structs/destructors.md)hakkındaki makaleye bakın.</span><span class="sxs-lookup"><span data-stu-id="7edb9-315">For more details, see the article on [finalizers](../programming-guide/classes-and-structs/destructors.md).</span></span>

<span data-ttu-id="7edb9-316">Çöp toplayıcısına, nesnelerin toplanması ve Sonlandırıcıların ne zaman toplanacağına karar verirken geniş bir enlem vardır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-316">The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</span></span> <span data-ttu-id="7edb9-317">Özellikle, Sonlandırıcı çağırma zamanlaması belirleyici değildir ve herhangi bir iş parçacığında sonlandırıcılar çalıştırılabilir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-317">Specifically, the timing of finalizer invocations isn't deterministic, and finalizers may be executed on any thread.</span></span> <span data-ttu-id="7edb9-318">Bu ve diğer nedenlerden dolayı sınıfların yalnızca başka hiçbir çözüm uygulanabilir olmadığında sonlandırıcılar uygulaması gerekir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-318">For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</span></span>

<span data-ttu-id="7edb9-319">`using`İfade, nesne yok etme için daha iyi bir yaklaşım sağlar.</span><span class="sxs-lookup"><span data-stu-id="7edb9-319">The `using` statement provides a better approach to object destruction.</span></span>

## <a name="expressions"></a><span data-ttu-id="7edb9-320">İfadeler</span><span class="sxs-lookup"><span data-stu-id="7edb9-320">Expressions</span></span>

<span data-ttu-id="7edb9-321">*İfadeler* , *işlenenler* ve *işleçlerden*oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="7edb9-321">*Expressions* are constructed from *operands* and *operators*.</span></span> <span data-ttu-id="7edb9-322">Bir ifadenin işleçleri, işlenenlerin hangi işlemleri uygulanacağını gösterir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-322">The operators of an expression indicate which operations to apply to the operands.</span></span> <span data-ttu-id="7edb9-323">İşleç örnekleri,, `+` , `-` `*` ve içerir `/` `new` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-323">Examples of operators include `+`, `-`, `*`, `/`, and `new`.</span></span> <span data-ttu-id="7edb9-324">İşlenenlerin örnekleri, sabit değerleri, alanları, yerel değişkenleri ve ifadeleri içerir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-324">Examples of operands include literals, fields, local variables, and expressions.</span></span>

<span data-ttu-id="7edb9-325">Bir ifade birden çok işleç içerdiğinde işleçlerin *önceliği*, her bir işlecin değerlendirilme sırasını denetler.</span><span class="sxs-lookup"><span data-stu-id="7edb9-325">When an expression contains multiple operators, the *precedence* of the operators controls the order in which the individual operators are evaluated.</span></span> <span data-ttu-id="7edb9-326">Örneğin, `x + y * z` `x + (y * z)` `*` işleç işleçten daha yüksek önceliğe sahip olduğu için ifade değerlendirilir `+` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-326">For example, the expression `x + y * z` is evaluated as `x + (y * z)` because the `*` operator has higher precedence than the `+` operator.</span></span>

<span data-ttu-id="7edb9-327">Aynı önceliğe sahip iki işleç arasında bir işlenen gerçekleştiğinde, işleçlerin *ilişkilendirilebilirliği* , işlemlerin gerçekleştirileceği sırayı denetler:</span><span class="sxs-lookup"><span data-stu-id="7edb9-327">When an operand occurs between two operators with the same precedence, the *associativity* of the operators controls the order in which the operations are performed:</span></span>

* <span data-ttu-id="7edb9-328">Atama ve null birleşim işleçleri hariç olmak üzere tüm ikili işleçler *sola ilişkilendirilebilir*, yani işlemler soldan sağa yapılır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-328">Except for the assignment and null-coalescing operators, all binary operators are *left-associative*, meaning that operations are performed from left to right.</span></span> <span data-ttu-id="7edb9-329">Örneğin, `x + y + z` olarak değerlendirilir `(x + y) + z` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-329">For example, `x + y + z` is evaluated as `(x + y) + z`.</span></span>
* <span data-ttu-id="7edb9-330">Atama işleçleri, null birleşim `??` ve `??=` İşleçler ve koşullu operatör `?:` *doğru ilişkilendirilebilir*, yani işlemler sağdan sola yapılır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-330">The assignment operators, the null-coalescing `??` and `??=` operators, and the conditional operator `?:` are *right-associative*, meaning that operations are performed from right to left.</span></span> <span data-ttu-id="7edb9-331">Örneğin, `x = y = z` olarak değerlendirilir `x = (y = z)` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-331">For example, `x = y = z` is evaluated as `x = (y = z)`.</span></span>

<span data-ttu-id="7edb9-332">Öncelik ve ilişkilendirilebilirlik, parantezler kullanılarak denetlenebilir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-332">Precedence and associativity can be controlled using parentheses.</span></span> <span data-ttu-id="7edb9-333">Örneğin, ilk olarak ile `x + y * z` çarpar `y` `z` ve sonra sonucunu ekler `x` , ancak ilk olarak `(x + y) * z` sonucu ekler `x` ve `y` sonra sonucunu ile çarpar `z` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-333">For example, `x + y * z` first multiplies `y` by `z` and then adds the result to `x`, but `(x + y) * z` first adds `x` and `y` and then multiplies the result by `z`.</span></span>

<span data-ttu-id="7edb9-334">Çoğu işleç [*aşırı*](../language-reference/operators/operator-overloading.md)yüklenebilir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-334">Most operators can be [*overloaded*](../language-reference/operators/operator-overloading.md).</span></span> <span data-ttu-id="7edb9-335">İşleç aşırı yüklemesi, Kullanıcı tanımlı operatör uygulamalarının bir veya her ikisinin de Kullanıcı tanımlı sınıf veya yapı türünde olduğu işlemler için belirtilmesine izin verir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-335">Operator overloading permits user-defined operator implementations to be specified for operations where one or both of the operands are of a user-defined class or struct type.</span></span>

<span data-ttu-id="7edb9-336">C# [Aritmetik](../language-reference/operators/arithmetic-operators.md), [mantıksal](../language-reference/operators/boolean-logical-operators.md), [bit düzeyinde ve vardiya](../language-reference/operators/bitwise-and-shift-operators.md) işlemleri, [eşitlik](../language-reference/operators/equality-operators.md) ve [sıra](../language-reference/operators/comparison-operators.md) karşılaştırmaları gerçekleştirmeye yönelik bir dizi işleç sağlar.</span><span class="sxs-lookup"><span data-stu-id="7edb9-336">C# provides a number of operators to perform [arithmetic](../language-reference/operators/arithmetic-operators.md), [logical](../language-reference/operators/boolean-logical-operators.md), [bitwise and shift](../language-reference/operators/bitwise-and-shift-operators.md) operations and [equality](../language-reference/operators/equality-operators.md) and [order](../language-reference/operators/comparison-operators.md) comparisons.</span></span>

<span data-ttu-id="7edb9-337">Öncelik düzeyine göre sıralanan C# işleçlerinin tüm listesi için bkz. [c# işleçleri](../language-reference/operators/index.md).</span><span class="sxs-lookup"><span data-stu-id="7edb9-337">For the complete list of C# operators ordered by precedence level, see [C# operators](../language-reference/operators/index.md).</span></span>

## <a name="statements"></a><span data-ttu-id="7edb9-338">Deyimler</span><span class="sxs-lookup"><span data-stu-id="7edb9-338">Statements</span></span>

<span data-ttu-id="7edb9-339">Bir programın eylemleri *deyimler*kullanılarak ifade edilir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-339">The actions of a program are expressed using *statements*.</span></span> <span data-ttu-id="7edb9-340">C#, gömülü deyimler açısından tanımlanmış bir dizi farklı sayıda ifadeyi destekler.</span><span class="sxs-lookup"><span data-stu-id="7edb9-340">C# supports several different kinds of statements, a number of which are defined in terms of embedded statements.</span></span>

- <span data-ttu-id="7edb9-341">Bir *blok* , tek bir ifadeye izin verilen bağlamlarda birden çok deyimin yazılmasına izin verir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-341">A *block* permits multiple statements to be written in contexts where a single statement is allowed.</span></span> <span data-ttu-id="7edb9-342">Bir blok, sınırlayıcılar ve arasında yazılmış deyimler listesinden oluşur `{` `}` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-342">A block consists of a list of statements written between the delimiters `{` and `}`.</span></span>
- <span data-ttu-id="7edb9-343">*Bildirim deyimleri* yerel değişkenleri ve sabitleri bildirmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-343">*Declaration statements* are used to declare local variables and constants.</span></span>
- <span data-ttu-id="7edb9-344">*İfade deyimleri* , ifadeleri değerlendirmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-344">*Expression statements* are used to evaluate expressions.</span></span> <span data-ttu-id="7edb9-345">Deyim olarak kullanılabilecek ifadeler, yöntem etkinleştirmeleri, işleci kullanılarak nesne ayırmaları `new` , ve `=` bileşik atama işleçleri kullanan atamalar, artırma ve azaltma işlemlerini ve `++` `--` işleçlerini ve `await` ifadelerini içerir.</span><span class="sxs-lookup"><span data-stu-id="7edb9-345">Expressions that can be used as statements include method invocations, object allocations using the `new` operator, assignments using `=` and the compound assignment operators, increment and decrement operations using the `++` and `--` operators and `await` expressions.</span></span>
- <span data-ttu-id="7edb9-346">*Seçim deyimleri* , bazı deyimlerin değerine göre yürütme için bir dizi olası deyimden birini seçmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-346">*Selection statements* are used to select one of a number of possible statements for execution based on the value of some expression.</span></span> <span data-ttu-id="7edb9-347">Bu grup `if` ve deyimlerini içerir `switch` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-347">This group contains the `if` and `switch` statements.</span></span>
- <span data-ttu-id="7edb9-348">*Yineleme deyimleri* , art arda gömülü bir deyimi yürütmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-348">*Iteration statements* are used to execute repeatedly an embedded statement.</span></span> <span data-ttu-id="7edb9-349">Bu grup,, `while` , `do` `for` ve deyimlerini içerir `foreach` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-349">This group contains the `while`, `do`, `for`, and `foreach` statements.</span></span>
- <span data-ttu-id="7edb9-350">*Sıçrama deyimleri* , denetimi aktarmak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-350">*Jump statements* are used to transfer control.</span></span> <span data-ttu-id="7edb9-351">Bu grup,,,, `break` `continue` `goto` `throw` `return` ve deyimlerini içerir `yield` .</span><span class="sxs-lookup"><span data-stu-id="7edb9-351">This group contains the `break`, `continue`, `goto`, `throw`, `return`, and `yield` statements.</span></span>
- <span data-ttu-id="7edb9-352">`try`... `catch` Bildirisi, bir bloğun yürütülmesi sırasında oluşan özel durumları yakalamak için kullanılır ve `try` ... `finally` deyimleri her zaman yürütülen ve özel bir durumun gerçekleşmediği sonlandırma kodunu belirtmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-352">The `try`...`catch` statement is used to catch exceptions that occur during execution of a block, and the `try`...`finally` statement is used to specify finalization code that is always executed, whether an exception occurred or not.</span></span>
- <span data-ttu-id="7edb9-353">`checked`Ve `unchecked` deyimleri, tam sayı türü aritmetik işlemler ve dönüştürmeler için taşma denetimi bağlamını denetlemek üzere kullanılır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-353">The `checked` and `unchecked` statements are used to control the overflow-checking context for integral-type arithmetic operations and conversions.</span></span>
- <span data-ttu-id="7edb9-354">Bu `lock` ifade, belirli bir nesne için karşılıklı dışlama kilidini almak, bir ifadeyi yürütmek ve sonra kilidi serbest bırakmak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-354">The `lock` statement is used to obtain the mutual-exclusion lock for a given object, execute a statement, and then release the lock.</span></span>
- <span data-ttu-id="7edb9-355">`using`İfade, kaynak almak, bir ifadeyi yürütmek ve ardından bu kaynağı atmak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="7edb9-355">The `using` statement is used to obtain a resource, execute a statement, and then dispose of that resource.</span></span>

<span data-ttu-id="7edb9-356">Aşağıdakiler, kullanılabilecek deyimlerin türlerini listeler:</span><span class="sxs-lookup"><span data-stu-id="7edb9-356">The following lists the kinds of statements that can be used:</span></span>

* <span data-ttu-id="7edb9-357">Yerel değişken bildirimi.</span><span class="sxs-lookup"><span data-stu-id="7edb9-357">Local variable declaration.</span></span>
* <span data-ttu-id="7edb9-358">Yerel sabit bildirimi.</span><span class="sxs-lookup"><span data-stu-id="7edb9-358">Local constant declaration.</span></span>
* <span data-ttu-id="7edb9-359">İfade deyimi.</span><span class="sxs-lookup"><span data-stu-id="7edb9-359">Expression statement.</span></span>
* <span data-ttu-id="7edb9-360">`if` Ekstre.</span><span class="sxs-lookup"><span data-stu-id="7edb9-360">`if` statement.</span></span>
* <span data-ttu-id="7edb9-361">`switch` Ekstre.</span><span class="sxs-lookup"><span data-stu-id="7edb9-361">`switch` statement.</span></span>
* <span data-ttu-id="7edb9-362">`while` Ekstre.</span><span class="sxs-lookup"><span data-stu-id="7edb9-362">`while` statement.</span></span>
* <span data-ttu-id="7edb9-363">`do` Ekstre.</span><span class="sxs-lookup"><span data-stu-id="7edb9-363">`do` statement.</span></span>
* <span data-ttu-id="7edb9-364">`for` Ekstre.</span><span class="sxs-lookup"><span data-stu-id="7edb9-364">`for` statement.</span></span>
* <span data-ttu-id="7edb9-365">`foreach` Ekstre.</span><span class="sxs-lookup"><span data-stu-id="7edb9-365">`foreach` statement.</span></span>
* <span data-ttu-id="7edb9-366">`break` Ekstre.</span><span class="sxs-lookup"><span data-stu-id="7edb9-366">`break` statement.</span></span>
* <span data-ttu-id="7edb9-367">`continue` Ekstre.</span><span class="sxs-lookup"><span data-stu-id="7edb9-367">`continue` statement.</span></span>
* <span data-ttu-id="7edb9-368">`goto` Ekstre.</span><span class="sxs-lookup"><span data-stu-id="7edb9-368">`goto` statement.</span></span>
* <span data-ttu-id="7edb9-369">`return` Ekstre.</span><span class="sxs-lookup"><span data-stu-id="7edb9-369">`return` statement.</span></span>
* <span data-ttu-id="7edb9-370">`yield` Ekstre.</span><span class="sxs-lookup"><span data-stu-id="7edb9-370">`yield` statement.</span></span>
* <span data-ttu-id="7edb9-371">`throw` deyimler ve `try` deyimler.</span><span class="sxs-lookup"><span data-stu-id="7edb9-371">`throw` statements and `try` statements.</span></span>
* <span data-ttu-id="7edb9-372">`checked` ve `unchecked` deyimleri.</span><span class="sxs-lookup"><span data-stu-id="7edb9-372">`checked` and `unchecked` statements.</span></span>
* <span data-ttu-id="7edb9-373">`lock` Ekstre.</span><span class="sxs-lookup"><span data-stu-id="7edb9-373">`lock` statement.</span></span>
* <span data-ttu-id="7edb9-374">`using` Ekstre.</span><span class="sxs-lookup"><span data-stu-id="7edb9-374">`using` statement.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="7edb9-375">[Önceki](types.md) 
> [Sonraki](features.md)</span><span class="sxs-lookup"><span data-stu-id="7edb9-375">[Previous](types.md)
[Next](features.md)</span></span>
